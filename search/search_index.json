{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hyper Protect Virtual Servers Hosted Trial \u00b6 IBM Hyper Protect Virtual Servers is a secure virtualization platform that protects your critical Linux applications throughout the DevSecOps lifecycle. It enables users to securely run containerized Linux workloads on IBM Z and LinuxONE by providing an encrypted environment (data at rest, data in flight), with peer to peer and peer to host isolation protecting container applications from access via privileged credentials, whether access is accidental or malicious, internal or external to an organization. IBM Hyper Protect Virtual Servers also ensures your applications can be deployed and managed from trusted sources without the infrastructure team being able to access the data, secrets or application. The Hyper Protect Virtual Servers Hosted Trial provides a primer on Hyper Protect Virtual Servers and practical use cases relevant to the enterprise. With the provided Command Line Interface (CLI) tool, you will gain hands-on experience in the following: - Utilizing IBM\u2019s unique Secure Build process to build a secure image and deploy it inside a secure memory enclave. - Deploying your own Linux-based container image to the Hyper Protect Virtual Server environment i.e. utilize the Bring Your Own Image feature. - Accessing the Hyper Protect Virtual Servers' crypto service built on a FIPS 140-2 Level 4-compliant Hardware Security Module (HSM).","title":"Home"},{"location":"#hyper-protect-virtual-servers-hosted-trial","text":"IBM Hyper Protect Virtual Servers is a secure virtualization platform that protects your critical Linux applications throughout the DevSecOps lifecycle. It enables users to securely run containerized Linux workloads on IBM Z and LinuxONE by providing an encrypted environment (data at rest, data in flight), with peer to peer and peer to host isolation protecting container applications from access via privileged credentials, whether access is accidental or malicious, internal or external to an organization. IBM Hyper Protect Virtual Servers also ensures your applications can be deployed and managed from trusted sources without the infrastructure team being able to access the data, secrets or application. The Hyper Protect Virtual Servers Hosted Trial provides a primer on Hyper Protect Virtual Servers and practical use cases relevant to the enterprise. With the provided Command Line Interface (CLI) tool, you will gain hands-on experience in the following: - Utilizing IBM\u2019s unique Secure Build process to build a secure image and deploy it inside a secure memory enclave. - Deploying your own Linux-based container image to the Hyper Protect Virtual Server environment i.e. utilize the Bring Your Own Image feature. - Accessing the Hyper Protect Virtual Servers' crypto service built on a FIPS 140-2 Level 4-compliant Hardware Security Module (HSM).","title":"Hyper Protect Virtual Servers Hosted Trial"},{"location":"glossary/","text":"This glossary of terms consolidates the terms for the Hyper Protect Virtual Servers offering in alphabetical order to help both customers and internal team members to understand our offering better. Appliance \u00b6 IBM Secure Service Container based appliance provided by an Appliance Vendor. From Hosting Appliance perspective, it is the combination of IBM Secure Service Container and the Hyper Protect Servers Hosting Appliance. Appliance Administrator \u00b6 The person administrating an appliance which includes tasks, such as configuring storage, or memory to the appliance or performing other configuration tasks through the API provided by SSC/the Hosting Appliance. Appliance Operational Data \u00b6 Metrics, logs, appliance dump data, error logs, stack traces, kernel dump, etc. Appliance Protected Data \u00b6 Appliance secrets, workload data, configuration data, settings, and other internal information stored by an appliance. Appliance Vendor \u00b6 An internal, or external exploiter of SSC, packaging SSC into an appliance. BYOK \u00b6 The abbreviation of Bring Your Own Key, which allows you to import your existing keys to Hyper Protect Crypto Services service instances that protect your keys with advanced encryption. BYOI \u00b6 The abbreviation of Bring Your Own Image, which is a part of the IBM Hyper Protect Virtual Servers solution to support the development and deployment of your own container images on top of the Secure Service Container framework. Container \u00b6 A runtime instance of an Open Container Image (OCI) image. Crypto administrator \u00b6 The person who signs commands that are issued to the crypto units. Multiple administrators can be added to one crypto unit to increase security. Crypto units \u00b6 A single unit that represents a hardware security module and the corresponding software stack that is dedicated to the hardware security module for cryptography. Data encryption keys \u00b6 A cryptographic key used to encrypt data that is stored in an application. Datapool \u00b6 Synonyms for Storage Pool. Docker Content Trust \u00b6 Docker Content Trust (DCT) is a feature in the Docker containerization platform that provides the ability to use digital signatures for data sent to and received from remote Docker registries. These signatures allow client-side or runtime verification of the integrity and publisher of specific image tags. Through DCT, image publishers can sign their images and image consumers can ensure that the images they pull are signed. Publishers could be individuals or organizations manually signing their content or automated software supply chains signing content as part of their release process. Docker registry \u00b6 A Docker registry is a storage and content delivery system, holding named Docker images, available in different tagged versions. EP11 \u00b6 The abbreviation of Enterprise PKCS #11, which is specifically designed for customers seeking support for open standards and enhanced security. The EP11 library provides an interface very similar to the industry-standard PKCS #11 API. Envelope encryption \u00b6 The process of encrypting data with a data encryption key and then encrypting the key with a root key that can be fully managed. FIPS 140-2 compliance \u00b6 An organization\u2019s adherence to the Federal Information Processing Standards (FIPS) 140-2 standards. This standard specifies the security requirements that will be satisfied by a cryptographic module utilized within a security system protecting sensitive information. FIPS 140-2 outlines four levels of security: Level 1 - the lowest level of security. It covers the basic security features in a cryptographic module. Level 2 - improves the physical security aspects of cryptographic modules. Examples of required physical security measures are tamper-evident coatings, seals, or pick-resistant locks. Role-based authentication is included in this security level and ensures the operator accessing the module is authorized and is limited to their assigned actions. Level 3 - requires enhanced physical security, potentially with products available from the private sector. A multi-chip embedded module has to be contained in a strong enclosure that zeroizes critical security parameters when it is removed. This security level also uses identity-based authentication. Level 4 - requires tamper detection circuits to be able to detect any device penetration. This level is best for when cryptographic modules are in a physically unprotected environment that intruders can access. Modules must be able to detect fluctuations and zeroize themselves. Level 4 also protects against security compromises due to environmental conditions. FIPS 197 compliance \u00b6 An organization\u2019s adherence to Federal Information Processing Standards (FIPS) 197 which is an algorithmic standard that addresses the Advanced Encryption Standard (AES). AES specifies a FIPS-approved cryptographic algorithm that can be used to protect electronic data. The AES algorithm is a symmetric block cipher that can encrypt and decrypt information. GPG \u00b6 The abbreviation of Gnu Privacy Guard, which is an open standard used for signing, encrypting, and decrypting texts with public and private keys to increase the security of communications. GREP11 \u00b6 Represents Enterprise PKCS #11 (EP11) APIs over gRPC calls, which is designed to be a stateless interface for cryptographic operations on cloud. gRPC \u00b6 A modern open source high performance remote procedure call (RPC) framework that can connect services in and across data centers for load balancing, tracing, health checking, and authentication. Hardware security module \u00b6 A physical appliance that provides on-demand encryption, key management, and key storage as a managed service. Hosting Appliance \u00b6 A technical component within IBM Secure Service Container based appliances, providing the enablement for running Docker-based workloads. Image \u00b6 The basis of the containers. An image is an ordered collection of root file system changes and the corresponding execution parameters for use within a container runtime. ISV \u00b6 The abbreviation of Independent Software Vendor, who provides software solutions by developing and deploying containerized applications to the Secure Service Container partitions. Master key \u00b6 An encryption key that is used to protect a crypto unit. The master key provides full control of the hardware security module and ownership of the root of trust that encrypts the chain keys, including the root key and standard key. Management Utilities \u00b6 A set of applications to provide an alternate way of configuring Hyper Protect Crypto Services service instances using signature keys and master key parts stored on smart cards. Management server \u00b6 An x86 or s390x Linux management server used to run the commands provided by the Hyper Protect Virtual Servers offering, and administer the offering. Manifest \u00b6 A manifest is generated by the Secure Build for audit purpose, which contains a copy of the github project cloned by the Secure Build container, a copy of the build log, and a build.json with the build status. Manifest public key \u00b6 A manifest public key is used to verify the manifest generated by the Secure Build. Manifest private key \u00b6 A manifest private key is used to sign the manifest during the Secure Build. Mutual TLS \u00b6 Mutual authentication or two-way authentication refers to two parties authenticating each other at the same time. Mutual TLS is doing this over the TLS protocol. Namespace \u00b6 A namespace such as ibmzcontainers that contains a number of unique images. For examples, the images include hpvsop-base, hyperpcons-worker, hyperpcons-riaas, and so on. Partition \u00b6 A partition is the logic partition (LPAR) on the mainframe, and can be created by using the logic partitioning tools such as Hardware Management Console (HMC) or other logical partitioning tools. PKCS #11 \u00b6 The abbreviation of Public-Key Cryptography Standards #11, which defines a platform-independent API to cryptographic tokens, such as HSM and smart cards. Protected memory enclave \u00b6 Defined private regions of memory whose contents are protected and unable to be read or saved to any process outside the enclave itself. Quotagroup \u00b6 The storage assigned to a workload running on an appliance. The appliance administrator assigns FCP, or ECKD based storage to an appliance. He then creates quotagroups, representing parts of the underlying storage. He finally assigns quotagroups to workloads through the appliance API. Root keys \u00b6 A symmetric wrapping key that is used for encrypting and decrypting other keys that are stored in a data service. Registry \u00b6 A Registry is a hosted service containing repositories of container images that responds to the Registry API. For example, Docker Hub. Repository \u00b6 A repository is a set of containerized images. A repository can be shared by pushing it to a registry server. Different images in the repository can be labeled using tags. For example, hpvsop-base. Repository definition files \u00b6 An encrypted registration file or a repository definition file is used to register the repository, for authentication or validation reasons, such that a Hosting Appliance will trust that the image, when pulled from the registry, is authentic. Repository registration files \u00b6 A cleartext Python or JSON format file, which is generated by the Secure Build container when the container is created. The JSON format repository registration file can be used as the direct input to generate an encrypted repository definition file. runc \u00b6 A CLI tool for spawning and running containers according to the Open Container Initiative (OCI) specification. runq \u00b6 An open-sourced hypervisor-based Docker runtime environment, which is based on runc to run regular containerized images in a lightweight KVM or Qemu virtual machine. s390x \u00b6 The underlying architecture of IBM Z or LinuxONE mainframe. Secondary node \u00b6 A cluster member that replicates the contents of the primary database in Hyper Protect DBaaS. Smart cards \u00b6 An HSM that looks like a credit card with an embedded chip. The chip is capable of performing a limited set of cryptographic operations and is loaded with custom software. Smart card readers \u00b6 A device that attaches to a workstation and allows the workstation to communicate with a smart card. Smart Card Utility Program \u00b6 The application installed as part of the Management Utilities. It sets up and manages the smart cards used by the Trusted Key Entry (TKE) application. Signature key \u00b6 An encryption key that is used by the crypto unit administrator to sign commands that are issued to the crypto unit. Standard key \u00b6 Another resource in Hyper Protect Crypto Services to directly encrypt and decrypt data. Secure Build / Secure Image Build \u00b6 The process of building the application code from a Git-like source repository into a container image for s390x architecture, signing the image by using the authentication keys, and publishing the image to the remote repository for later integration. Secure Service Container \u00b6 A container framework based on the runq technology, that is supported by the IBM Z or LinuxONE servers. Secure Service Container partition \u00b6 A type of logic partitions (LPARs) on the mainframe that runs the Secure Service Container framework. SSH \u00b6 The abbreviation of Secure Shell, which is a cryptographic network protocol for operating network services securely over an unsecured network by using public and private keys. Storage Pool \u00b6 A storage pool is a uniquely named collection of storage disks on which the appliance file system is mounted. System Administrator \u00b6 This role includes the system administrator of a machine, storage administrators, and network administrators. tag \u00b6 A tag is used to version images in a repository. For example, latest, 1.2.3.4-develop-a0d3aea, or s390x-develop-54a9045. Trusted Key Entry application \u00b6 The application installed as part of the Management Utilities. It uses smart cards to load master keys in service instances and to perform other configuration tasks for service instances. Workload \u00b6 The application and data provided and generated by a (running) Workload Image. Workload Data \u00b6 Workload user or workload client data, workload logs, workload secrets stored in the appliance. Workload Image \u00b6 A container-based image, provided by the Workload Vendor. An appliance only runs workload images which have been registered with the appliance through a repository definition file. Workload User \u00b6 The end-user of a workload. Workload Vendor \u00b6 The creator of a Docker image running on top of Hosting Appliance.","title":"Glossary of terms"},{"location":"glossary/#appliance","text":"IBM Secure Service Container based appliance provided by an Appliance Vendor. From Hosting Appliance perspective, it is the combination of IBM Secure Service Container and the Hyper Protect Servers Hosting Appliance.","title":"Appliance"},{"location":"glossary/#appliance-administrator","text":"The person administrating an appliance which includes tasks, such as configuring storage, or memory to the appliance or performing other configuration tasks through the API provided by SSC/the Hosting Appliance.","title":"Appliance Administrator"},{"location":"glossary/#appliance-operational-data","text":"Metrics, logs, appliance dump data, error logs, stack traces, kernel dump, etc.","title":"Appliance Operational Data"},{"location":"glossary/#appliance-protected-data","text":"Appliance secrets, workload data, configuration data, settings, and other internal information stored by an appliance.","title":"Appliance Protected Data"},{"location":"glossary/#appliance-vendor","text":"An internal, or external exploiter of SSC, packaging SSC into an appliance.","title":"Appliance Vendor"},{"location":"glossary/#byok","text":"The abbreviation of Bring Your Own Key, which allows you to import your existing keys to Hyper Protect Crypto Services service instances that protect your keys with advanced encryption.","title":"BYOK"},{"location":"glossary/#byoi","text":"The abbreviation of Bring Your Own Image, which is a part of the IBM Hyper Protect Virtual Servers solution to support the development and deployment of your own container images on top of the Secure Service Container framework.","title":"BYOI"},{"location":"glossary/#container","text":"A runtime instance of an Open Container Image (OCI) image.","title":"Container"},{"location":"glossary/#crypto-administrator","text":"The person who signs commands that are issued to the crypto units. Multiple administrators can be added to one crypto unit to increase security.","title":"Crypto administrator"},{"location":"glossary/#crypto-units","text":"A single unit that represents a hardware security module and the corresponding software stack that is dedicated to the hardware security module for cryptography.","title":"Crypto units"},{"location":"glossary/#data-encryption-keys","text":"A cryptographic key used to encrypt data that is stored in an application.","title":"Data encryption keys"},{"location":"glossary/#datapool","text":"Synonyms for Storage Pool.","title":"Datapool"},{"location":"glossary/#docker-content-trust","text":"Docker Content Trust (DCT) is a feature in the Docker containerization platform that provides the ability to use digital signatures for data sent to and received from remote Docker registries. These signatures allow client-side or runtime verification of the integrity and publisher of specific image tags. Through DCT, image publishers can sign their images and image consumers can ensure that the images they pull are signed. Publishers could be individuals or organizations manually signing their content or automated software supply chains signing content as part of their release process.","title":"Docker Content Trust"},{"location":"glossary/#docker-registry","text":"A Docker registry is a storage and content delivery system, holding named Docker images, available in different tagged versions.","title":"Docker registry"},{"location":"glossary/#ep11","text":"The abbreviation of Enterprise PKCS #11, which is specifically designed for customers seeking support for open standards and enhanced security. The EP11 library provides an interface very similar to the industry-standard PKCS #11 API.","title":"EP11"},{"location":"glossary/#envelope-encryption","text":"The process of encrypting data with a data encryption key and then encrypting the key with a root key that can be fully managed.","title":"Envelope encryption"},{"location":"glossary/#fips-140-2-compliance","text":"An organization\u2019s adherence to the Federal Information Processing Standards (FIPS) 140-2 standards. This standard specifies the security requirements that will be satisfied by a cryptographic module utilized within a security system protecting sensitive information. FIPS 140-2 outlines four levels of security: Level 1 - the lowest level of security. It covers the basic security features in a cryptographic module. Level 2 - improves the physical security aspects of cryptographic modules. Examples of required physical security measures are tamper-evident coatings, seals, or pick-resistant locks. Role-based authentication is included in this security level and ensures the operator accessing the module is authorized and is limited to their assigned actions. Level 3 - requires enhanced physical security, potentially with products available from the private sector. A multi-chip embedded module has to be contained in a strong enclosure that zeroizes critical security parameters when it is removed. This security level also uses identity-based authentication. Level 4 - requires tamper detection circuits to be able to detect any device penetration. This level is best for when cryptographic modules are in a physically unprotected environment that intruders can access. Modules must be able to detect fluctuations and zeroize themselves. Level 4 also protects against security compromises due to environmental conditions.","title":"FIPS 140-2 compliance"},{"location":"glossary/#fips-197-compliance","text":"An organization\u2019s adherence to Federal Information Processing Standards (FIPS) 197 which is an algorithmic standard that addresses the Advanced Encryption Standard (AES). AES specifies a FIPS-approved cryptographic algorithm that can be used to protect electronic data. The AES algorithm is a symmetric block cipher that can encrypt and decrypt information.","title":"FIPS 197 compliance"},{"location":"glossary/#gpg","text":"The abbreviation of Gnu Privacy Guard, which is an open standard used for signing, encrypting, and decrypting texts with public and private keys to increase the security of communications.","title":"GPG"},{"location":"glossary/#grep11","text":"Represents Enterprise PKCS #11 (EP11) APIs over gRPC calls, which is designed to be a stateless interface for cryptographic operations on cloud.","title":"GREP11"},{"location":"glossary/#grpc","text":"A modern open source high performance remote procedure call (RPC) framework that can connect services in and across data centers for load balancing, tracing, health checking, and authentication.","title":"gRPC"},{"location":"glossary/#hardware-security-module","text":"A physical appliance that provides on-demand encryption, key management, and key storage as a managed service.","title":"Hardware security module"},{"location":"glossary/#hosting-appliance","text":"A technical component within IBM Secure Service Container based appliances, providing the enablement for running Docker-based workloads.","title":"Hosting Appliance"},{"location":"glossary/#image","text":"The basis of the containers. An image is an ordered collection of root file system changes and the corresponding execution parameters for use within a container runtime.","title":"Image"},{"location":"glossary/#isv","text":"The abbreviation of Independent Software Vendor, who provides software solutions by developing and deploying containerized applications to the Secure Service Container partitions.","title":"ISV"},{"location":"glossary/#master-key","text":"An encryption key that is used to protect a crypto unit. The master key provides full control of the hardware security module and ownership of the root of trust that encrypts the chain keys, including the root key and standard key.","title":"Master key"},{"location":"glossary/#management-utilities","text":"A set of applications to provide an alternate way of configuring Hyper Protect Crypto Services service instances using signature keys and master key parts stored on smart cards.","title":"Management Utilities"},{"location":"glossary/#management-server","text":"An x86 or s390x Linux management server used to run the commands provided by the Hyper Protect Virtual Servers offering, and administer the offering.","title":"Management server"},{"location":"glossary/#manifest","text":"A manifest is generated by the Secure Build for audit purpose, which contains a copy of the github project cloned by the Secure Build container, a copy of the build log, and a build.json with the build status.","title":"Manifest"},{"location":"glossary/#manifest-public-key","text":"A manifest public key is used to verify the manifest generated by the Secure Build.","title":"Manifest public key"},{"location":"glossary/#manifest-private-key","text":"A manifest private key is used to sign the manifest during the Secure Build.","title":"Manifest private key"},{"location":"glossary/#mutual-tls","text":"Mutual authentication or two-way authentication refers to two parties authenticating each other at the same time. Mutual TLS is doing this over the TLS protocol.","title":"Mutual TLS"},{"location":"glossary/#namespace","text":"A namespace such as ibmzcontainers that contains a number of unique images. For examples, the images include hpvsop-base, hyperpcons-worker, hyperpcons-riaas, and so on.","title":"Namespace"},{"location":"glossary/#partition","text":"A partition is the logic partition (LPAR) on the mainframe, and can be created by using the logic partitioning tools such as Hardware Management Console (HMC) or other logical partitioning tools.","title":"Partition"},{"location":"glossary/#pkcs-11","text":"The abbreviation of Public-Key Cryptography Standards #11, which defines a platform-independent API to cryptographic tokens, such as HSM and smart cards.","title":"PKCS #11"},{"location":"glossary/#protected-memory-enclave","text":"Defined private regions of memory whose contents are protected and unable to be read or saved to any process outside the enclave itself.","title":"Protected memory enclave"},{"location":"glossary/#quotagroup","text":"The storage assigned to a workload running on an appliance. The appliance administrator assigns FCP, or ECKD based storage to an appliance. He then creates quotagroups, representing parts of the underlying storage. He finally assigns quotagroups to workloads through the appliance API.","title":"Quotagroup"},{"location":"glossary/#root-keys","text":"A symmetric wrapping key that is used for encrypting and decrypting other keys that are stored in a data service.","title":"Root keys"},{"location":"glossary/#registry","text":"A Registry is a hosted service containing repositories of container images that responds to the Registry API. For example, Docker Hub.","title":"Registry"},{"location":"glossary/#repository","text":"A repository is a set of containerized images. A repository can be shared by pushing it to a registry server. Different images in the repository can be labeled using tags. For example, hpvsop-base.","title":"Repository"},{"location":"glossary/#repository-definition-files","text":"An encrypted registration file or a repository definition file is used to register the repository, for authentication or validation reasons, such that a Hosting Appliance will trust that the image, when pulled from the registry, is authentic.","title":"Repository definition files"},{"location":"glossary/#repository-registration-files","text":"A cleartext Python or JSON format file, which is generated by the Secure Build container when the container is created. The JSON format repository registration file can be used as the direct input to generate an encrypted repository definition file.","title":"Repository registration files"},{"location":"glossary/#runc","text":"A CLI tool for spawning and running containers according to the Open Container Initiative (OCI) specification.","title":"runc"},{"location":"glossary/#runq","text":"An open-sourced hypervisor-based Docker runtime environment, which is based on runc to run regular containerized images in a lightweight KVM or Qemu virtual machine.","title":"runq"},{"location":"glossary/#s390x","text":"The underlying architecture of IBM Z or LinuxONE mainframe.","title":"s390x"},{"location":"glossary/#secondary-node","text":"A cluster member that replicates the contents of the primary database in Hyper Protect DBaaS.","title":"Secondary node"},{"location":"glossary/#smart-cards","text":"An HSM that looks like a credit card with an embedded chip. The chip is capable of performing a limited set of cryptographic operations and is loaded with custom software.","title":"Smart cards"},{"location":"glossary/#smart-card-readers","text":"A device that attaches to a workstation and allows the workstation to communicate with a smart card.","title":"Smart card readers"},{"location":"glossary/#smart-card-utility-program","text":"The application installed as part of the Management Utilities. It sets up and manages the smart cards used by the Trusted Key Entry (TKE) application.","title":"Smart Card Utility Program"},{"location":"glossary/#signature-key","text":"An encryption key that is used by the crypto unit administrator to sign commands that are issued to the crypto unit.","title":"Signature key"},{"location":"glossary/#standard-key","text":"Another resource in Hyper Protect Crypto Services to directly encrypt and decrypt data.","title":"Standard key"},{"location":"glossary/#secure-build-secure-image-build","text":"The process of building the application code from a Git-like source repository into a container image for s390x architecture, signing the image by using the authentication keys, and publishing the image to the remote repository for later integration.","title":"Secure Build / Secure Image Build"},{"location":"glossary/#secure-service-container","text":"A container framework based on the runq technology, that is supported by the IBM Z or LinuxONE servers.","title":"Secure Service Container"},{"location":"glossary/#secure-service-container-partition","text":"A type of logic partitions (LPARs) on the mainframe that runs the Secure Service Container framework.","title":"Secure Service Container partition"},{"location":"glossary/#ssh","text":"The abbreviation of Secure Shell, which is a cryptographic network protocol for operating network services securely over an unsecured network by using public and private keys.","title":"SSH"},{"location":"glossary/#storage-pool","text":"A storage pool is a uniquely named collection of storage disks on which the appliance file system is mounted.","title":"Storage Pool"},{"location":"glossary/#system-administrator","text":"This role includes the system administrator of a machine, storage administrators, and network administrators.","title":"System Administrator"},{"location":"glossary/#tag","text":"A tag is used to version images in a repository. For example, latest, 1.2.3.4-develop-a0d3aea, or s390x-develop-54a9045.","title":"tag"},{"location":"glossary/#trusted-key-entry-application","text":"The application installed as part of the Management Utilities. It uses smart cards to load master keys in service instances and to perform other configuration tasks for service instances.","title":"Trusted Key Entry application"},{"location":"glossary/#workload","text":"The application and data provided and generated by a (running) Workload Image.","title":"Workload"},{"location":"glossary/#workload-data","text":"Workload user or workload client data, workload logs, workload secrets stored in the appliance.","title":"Workload Data"},{"location":"glossary/#workload-image","text":"A container-based image, provided by the Workload Vendor. An appliance only runs workload images which have been registered with the appliance through a repository definition file.","title":"Workload Image"},{"location":"glossary/#workload-user","text":"The end-user of a workload.","title":"Workload User"},{"location":"glossary/#workload-vendor","text":"The creator of a Docker image running on top of Hosting Appliance.","title":"Workload Vendor"},{"location":"prerequisites/","text":"Prerequisites \u00b6 The Hosted trial environment already has sample applications that you can try for the Secure Build, and Bring Your Own Image features. However, if you would like to use your own applications, you must complete the tasks detailed in Setting up the environment , before you proceed. Accessing the Linux management server and the Secure Service Container Partition \u00b6 You will be provided the details to connect to the Linux management server by using the VPN. The details about the IP addresses, username, and password will be shared with you by email. Support contact \u00b6 You can contact IBM support personnel by using the slack channel details that are shared with you by email, for troubleshooting or queries about using IBM Hyper Protect Virtual Servers. Creating the server configuration YAML file \u00b6 You can find examples of the virtual server template file and virtual server configuration files in the $HOME/hpvs/config/ directory. The virtual server configuration files contain the configuration details of the virtual server, and this configuration file refers to the corresponding sections of the virtualserver.template.yml file when you run the hpvs deploy command. The following is an example of the virtualserver.template.yml file that is present in the $HOME/hpvs/config/templates/ directory. Example of a virtualserver-template file version: v1 type: virtualserver-template networktemplates: - name: external_network subnet: \"10.20.4.0/22\" gateway: \"10.20.4.1\" parent: \"encf900\" driver: \"macvlan\" - name: internal_network subnet: \"192.168.40.0/24\" gateway: \"192.168.40.1\" parent: \"encf900\" driver: \"bridge\" quotagrouptemplates: # Passthrough quotagroup templates - A quotagroup will be dynamically created based # on the template and attached as single volume mount point to the virtual server. # Allowed filesystem types for the passthrough type quogagroup are btrfs, ext4, xfs - name: p-small size: 20GB filesystem : ext4 passthrough: true - name: p-medium size: 50GB filesystem : ext4 passthrough: true - name: p-large size: 100GB filesystem : ext4 passthrough: true - name: p-xlarge size: 200GB filesystem : ext4 passthrough: true - name: p-xxlarge size: 400GB filesystem : ext4 passthrough: true # Non passthrough quotagroup definitions - This quotagroups can be shared by # creating multiple volume mountpoints with the same virtual server or multiple # virtual server. A non passthrough quotagroup will be dynamically created based # on the template and attached as volume mount points to the virtual server. # Only brtfs filesystem is supported in non passthrough quotagroups # mount points attached to virtual server can have filesystem btrfs, ext4, xfs - name: np-small size: 20GB passthrough: false - name: np-medium size: 50GB passthrough: false - name: np-large size: 100GB passthrough: false - name: np-xlarge size: 200GB passthrough: false - name: np-xxlarge size: 400GB passthrough: false resourcedefinitiontemplates: - name: default cpu: 1 memory: 4096 - name: small cpu: 2 memory: 6192 - name: large cpu: 4 memory: 8192 - name: xl cpu: 8 memory: 16656 - name: xxl cpu: 12 memory: 32565 You can find examples of the virtual server configuration file in the following topics: - Create your HPVS Secure Build Server by using a configuration file - Deploying your applications securely","title":"Prerequisites"},{"location":"prerequisites/#prerequisites","text":"The Hosted trial environment already has sample applications that you can try for the Secure Build, and Bring Your Own Image features. However, if you would like to use your own applications, you must complete the tasks detailed in Setting up the environment , before you proceed.","title":"Prerequisites"},{"location":"prerequisites/#accessing-the-linux-management-server-and-the-secure-service-container-partition","text":"You will be provided the details to connect to the Linux management server by using the VPN. The details about the IP addresses, username, and password will be shared with you by email.","title":"Accessing the Linux management server and the Secure Service Container Partition"},{"location":"prerequisites/#support-contact","text":"You can contact IBM support personnel by using the slack channel details that are shared with you by email, for troubleshooting or queries about using IBM Hyper Protect Virtual Servers.","title":"Support contact"},{"location":"prerequisites/#creating-the-server-configuration-yaml-file","text":"You can find examples of the virtual server template file and virtual server configuration files in the $HOME/hpvs/config/ directory. The virtual server configuration files contain the configuration details of the virtual server, and this configuration file refers to the corresponding sections of the virtualserver.template.yml file when you run the hpvs deploy command. The following is an example of the virtualserver.template.yml file that is present in the $HOME/hpvs/config/templates/ directory. Example of a virtualserver-template file version: v1 type: virtualserver-template networktemplates: - name: external_network subnet: \"10.20.4.0/22\" gateway: \"10.20.4.1\" parent: \"encf900\" driver: \"macvlan\" - name: internal_network subnet: \"192.168.40.0/24\" gateway: \"192.168.40.1\" parent: \"encf900\" driver: \"bridge\" quotagrouptemplates: # Passthrough quotagroup templates - A quotagroup will be dynamically created based # on the template and attached as single volume mount point to the virtual server. # Allowed filesystem types for the passthrough type quogagroup are btrfs, ext4, xfs - name: p-small size: 20GB filesystem : ext4 passthrough: true - name: p-medium size: 50GB filesystem : ext4 passthrough: true - name: p-large size: 100GB filesystem : ext4 passthrough: true - name: p-xlarge size: 200GB filesystem : ext4 passthrough: true - name: p-xxlarge size: 400GB filesystem : ext4 passthrough: true # Non passthrough quotagroup definitions - This quotagroups can be shared by # creating multiple volume mountpoints with the same virtual server or multiple # virtual server. A non passthrough quotagroup will be dynamically created based # on the template and attached as volume mount points to the virtual server. # Only brtfs filesystem is supported in non passthrough quotagroups # mount points attached to virtual server can have filesystem btrfs, ext4, xfs - name: np-small size: 20GB passthrough: false - name: np-medium size: 50GB passthrough: false - name: np-large size: 100GB passthrough: false - name: np-xlarge size: 200GB passthrough: false - name: np-xxlarge size: 400GB passthrough: false resourcedefinitiontemplates: - name: default cpu: 1 memory: 4096 - name: small cpu: 2 memory: 6192 - name: large cpu: 4 memory: 8192 - name: xl cpu: 8 memory: 16656 - name: xxl cpu: 12 memory: 32565 You can find examples of the virtual server configuration file in the following topics: - Create your HPVS Secure Build Server by using a configuration file - Deploying your applications securely","title":"Creating the server configuration YAML file"},{"location":"resources/","text":"Other Resources \u00b6 Hyper Protect Virtual Server Resources \u00b6 Knowledge Center IBM Hyper Protect Virtual Servers content solution IBM Hyper Protect Virtual Servers Redbook Hyper Protect Resources \u00b6 IBM Cloud Hyper Protect Services Hyper Protect Digital Assets Platform","title":"Other resources"},{"location":"resources/#other-resources","text":"","title":"Other Resources"},{"location":"resources/#hyper-protect-virtual-server-resources","text":"Knowledge Center IBM Hyper Protect Virtual Servers content solution IBM Hyper Protect Virtual Servers Redbook","title":"Hyper Protect Virtual Server Resources"},{"location":"resources/#hyper-protect-resources","text":"IBM Cloud Hyper Protect Services Hyper Protect Digital Assets Platform","title":"Hyper Protect Resources"},{"location":"setenv/","text":"Explore the Hyper Protect Virtual Servers CLI \u00b6 Info In this trial, you will use the Hyper Protect Virtual Servers CLI ( hpvs command) to interact with the Hyper Protect Virtual Servers Hosting Appliance in order to perform the various actions necessary for Secure Build, or Bring Your Own Image. Here is a quick introduction to the commands available through this CLI. See the different commands you could enter with: hpvs --help Example Output IBM\u00ae Hyper Protect Virtual Servers, the evolution of the IBM\u00ae Secure Service Container for IBM\u00ae Cloud Private offering, protects Linux workloads on IBM Z and LinuxONE throughout their lifecycle build management and deployment. This solution delivers the security needed to protect mission critical applications in hybrid multi-cloud deployments. Usage: hpvs [ command ] Available Commands: crypto Crypto command deploy Deploy command help Help about any command host Host command image Image Command network Network command quotagroup Quotagroup command regfile Generate encrypted repository registration file. If you have already image build on s390x arch registry Registry command repository Repository command sb SecureBuild command snapshot Snapshot command version Print hpvs version vs Virtual Server command Flags: --debug If --debug is passed, it will enable debug logs -h, --help Help for hpvs --host string Host LPAR name --log-output-dir string Set log output directory Use \"hpvs [command] --help\" for more information about a command. For further exploration of the Hyper Protect Virtual Servers CLI see the Knowledge Center .","title":"Explore the Hyper Protect Virtual Servers CLI"},{"location":"setenv/#explore-the-hyper-protect-virtual-servers-cli","text":"Info In this trial, you will use the Hyper Protect Virtual Servers CLI ( hpvs command) to interact with the Hyper Protect Virtual Servers Hosting Appliance in order to perform the various actions necessary for Secure Build, or Bring Your Own Image. Here is a quick introduction to the commands available through this CLI. See the different commands you could enter with: hpvs --help Example Output IBM\u00ae Hyper Protect Virtual Servers, the evolution of the IBM\u00ae Secure Service Container for IBM\u00ae Cloud Private offering, protects Linux workloads on IBM Z and LinuxONE throughout their lifecycle build management and deployment. This solution delivers the security needed to protect mission critical applications in hybrid multi-cloud deployments. Usage: hpvs [ command ] Available Commands: crypto Crypto command deploy Deploy command help Help about any command host Host command image Image Command network Network command quotagroup Quotagroup command regfile Generate encrypted repository registration file. If you have already image build on s390x arch registry Registry command repository Repository command sb SecureBuild command snapshot Snapshot command version Print hpvs version vs Virtual Server command Flags: --debug If --debug is passed, it will enable debug logs -h, --help Help for hpvs --host string Host LPAR name --log-output-dir string Set log output directory Use \"hpvs [command] --help\" for more information about a command. For further exploration of the Hyper Protect Virtual Servers CLI see the Knowledge Center .","title":"Explore the Hyper Protect Virtual Servers CLI"},{"location":"setting_upenv/","text":"Setting up the environment \u00b6 When you want to use your own applications for exploring Secure Build, you must register the base images in the remote registry server (Docker Hub or IBM Cloud Container Registry) by using your Docker Hub or IBM Cloud Container Registry user ID and password. In the hosted trial environment, the base images are located at $HOME/hpvs/config/hpvsopbase/images , and $HOME/hpvs/config/hpvsopbasessh . Before you begin \u00b6 Check that you have the account ID and password on the remote docker registry server to create repositories for base images. For example, docker_base_user is your user ID on the remote docker registry server. Check that you have installed the GPG command line tool on the x86 or Linux on IBM Z/LinuxONE (i.e., s390x architecture) management server. For more information, see GNU Privacy Guard . Check that you have enabled Docker Content Trust (DCT) for your remote docker registry server. For more information, see Content trust in Docker or Setting up your trusted content environment for IBM Container Registry . export DOCKER_CONTENT_TRUST=1 Procedure \u00b6 Complete the following steps. Create a GitHub account (if you do not already have one) here . Create a Docker Hub account (if you do not already have one) by following the instructions here . Create a Docker access token for Docker Hub access during the trial (you will delete it if after finishing the trial) by following the instructions here . Log in to the remote docker repository. For Docker Hub, run the docker login command. For more information, see Docker Login command . For IBM Cloud Container Registry, run docker login -u iamapikey -p <iam_api_key> <region>.icr.io command. For more information, see Using Docker to authenticate with an API key . Run the command: docker images , to check whether the base images are loaded into the local registry successfully. REPOSITORY TAG IMAGE ID CREATED SIZE ibmzcontainers/hpvsop-base 1.2.3-release-d0651e4 a53aae01b3ef 13 days ago 1.37GB ibmzcontainers/hpvsop-base-ssh 1.2.3-release-d0651e4 cd4e5704ae92 13 days ago 1.31GB Create two repositories in your namespace for both the hpvsop-base image and the hpvsop-base-ssh image on the Docker Hub . For example, docker_base_user/hpvsop-base and docker_base_user/hpvsop-base-ssh . Note that the repository name must match the image name. Use the docker tag command to tag base images with the same ID used by the CLI tool. Run the following commands to tag both base images. docker tag ibmzcontainers/hpvsop-base:1.2.3-release-d0651e4 docker_base_user/hpvsop-base:1.2.3-release-d0651e4 docker tag ibmzcontainers/hpvsop-base-ssh:1.2.3-release-d0651e4 docker_base_user/hpvsop-base-ssh:1.2.3-release-d0651e4 Run the docker images command to check whether the tags for the base images are as expected. REPOSITORY TAG IMAGE ID CREATED SIZE ... ibmzcontainers/hpvsop-base 1.2.3-release-d0651e4 a53aae01b3ef 6 days ago 1.37GB docker_base_user/hpvsop-base 1.2.3-release-d0651e4 a53aae01b3ef 6 days ago 1.37GB ibmzcontainers/hpvsop-base-ssh 1.2.3-release-d0651e4 cd4e5704ae92 6 days ago 1.31GB docker_base_user/hpvsop-base-ssh 1.2.3-release-d0651e4 cd4e5704ae92 6 days ago 1.31GB ... Push the base images to your remote docker repositories. For example: docker login docker push docker_base_user/hpvsop-base:1.2.3-release-d0651e4 docker push docker_base_user/hpvsop-base-ssh:1.2.3-release-d0651e4 Document the credentials you will use to build your application with the Secure Build container. Your Docker Hub ID account used to register the base images. For example, docker_base_user Your Docker Hub ID password. For example, passw0rd","title":"Setting up the environment"},{"location":"setting_upenv/#setting-up-the-environment","text":"When you want to use your own applications for exploring Secure Build, you must register the base images in the remote registry server (Docker Hub or IBM Cloud Container Registry) by using your Docker Hub or IBM Cloud Container Registry user ID and password. In the hosted trial environment, the base images are located at $HOME/hpvs/config/hpvsopbase/images , and $HOME/hpvs/config/hpvsopbasessh .","title":"Setting up the environment"},{"location":"setting_upenv/#before-you-begin","text":"Check that you have the account ID and password on the remote docker registry server to create repositories for base images. For example, docker_base_user is your user ID on the remote docker registry server. Check that you have installed the GPG command line tool on the x86 or Linux on IBM Z/LinuxONE (i.e., s390x architecture) management server. For more information, see GNU Privacy Guard . Check that you have enabled Docker Content Trust (DCT) for your remote docker registry server. For more information, see Content trust in Docker or Setting up your trusted content environment for IBM Container Registry . export DOCKER_CONTENT_TRUST=1","title":"Before you begin"},{"location":"setting_upenv/#procedure","text":"Complete the following steps. Create a GitHub account (if you do not already have one) here . Create a Docker Hub account (if you do not already have one) by following the instructions here . Create a Docker access token for Docker Hub access during the trial (you will delete it if after finishing the trial) by following the instructions here . Log in to the remote docker repository. For Docker Hub, run the docker login command. For more information, see Docker Login command . For IBM Cloud Container Registry, run docker login -u iamapikey -p <iam_api_key> <region>.icr.io command. For more information, see Using Docker to authenticate with an API key . Run the command: docker images , to check whether the base images are loaded into the local registry successfully. REPOSITORY TAG IMAGE ID CREATED SIZE ibmzcontainers/hpvsop-base 1.2.3-release-d0651e4 a53aae01b3ef 13 days ago 1.37GB ibmzcontainers/hpvsop-base-ssh 1.2.3-release-d0651e4 cd4e5704ae92 13 days ago 1.31GB Create two repositories in your namespace for both the hpvsop-base image and the hpvsop-base-ssh image on the Docker Hub . For example, docker_base_user/hpvsop-base and docker_base_user/hpvsop-base-ssh . Note that the repository name must match the image name. Use the docker tag command to tag base images with the same ID used by the CLI tool. Run the following commands to tag both base images. docker tag ibmzcontainers/hpvsop-base:1.2.3-release-d0651e4 docker_base_user/hpvsop-base:1.2.3-release-d0651e4 docker tag ibmzcontainers/hpvsop-base-ssh:1.2.3-release-d0651e4 docker_base_user/hpvsop-base-ssh:1.2.3-release-d0651e4 Run the docker images command to check whether the tags for the base images are as expected. REPOSITORY TAG IMAGE ID CREATED SIZE ... ibmzcontainers/hpvsop-base 1.2.3-release-d0651e4 a53aae01b3ef 6 days ago 1.37GB docker_base_user/hpvsop-base 1.2.3-release-d0651e4 a53aae01b3ef 6 days ago 1.37GB ibmzcontainers/hpvsop-base-ssh 1.2.3-release-d0651e4 cd4e5704ae92 6 days ago 1.31GB docker_base_user/hpvsop-base-ssh 1.2.3-release-d0651e4 cd4e5704ae92 6 days ago 1.31GB ... Push the base images to your remote docker repositories. For example: docker login docker push docker_base_user/hpvsop-base:1.2.3-release-d0651e4 docker push docker_base_user/hpvsop-base-ssh:1.2.3-release-d0651e4 Document the credentials you will use to build your application with the Secure Build container. Your Docker Hub ID account used to register the base images. For example, docker_base_user Your Docker Hub ID password. For example, passw0rd","title":"Procedure"},{"location":"byoi/byoi/","text":"Deploying your applications securely \u00b6 This topic provides information about how you can deploy your own Linux-based container image (bring your own image) as a Hyper Protect Virtual Server on the IBM Hyper Protect Virtual Servers. Prerequisites \u00b6 The following are the prerequisites for being able to deploy your own image into the IBM Hyper Protect Virtual Servers: Ensure your Linux-based container image are built for the IBM LinuxONE and IBM Z platform (s390x architecture), and available on DockerHub . Ensure your Linux-based container images are signed using Docker Content Trust . If not signed by using Docker Content Trust, follow the steps listed in Sign your image by using Docker Content Trust . Complete the following steps with root user authority. Sign your image by using Docker Content Trust Adding the registry Generating the signing keys Preparing the configuration Deploy your image step_1 \u00b6 Sign your image by using Docker Content Trust Log in to Docker hub using your Docker Hub credentials, if you are not logged-in yet. Example output docker login Login with your Docker ID to push and pull images from Docker Hub. If you do not have a Docker ID, go to https://hub.docker.com to create one. Username: hpvsdemo Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded Enable Docker Content Trust (DCT), specify the server for the Docker Content Trust service by running the following command. export DOCKER_CONTENT_TRUST=1 export DOCKER_CONTENT_TRUST_SERVER=https://notary.docker.io Run the following command to load the image (Nginx application) from the DockerHub onto your management server. docker image pull <your_docker_id>/<result_image_name>:<tag> Example output docker image pull s390x/nginx:latest latest: Pulling from s390x/nginx 405e75bf6bb0: Pull complete 513ab99245be: Pull complete 0057372a1eb7: Pull complete e8a2963860c1: Pull complete ed9d8c330029: Pull complete Digest: sha256:9b47e7c64b1f9149832d1ef7cbf9d80b9b55466a9c6c8212f30d15966fd9f1a6 Status: Downloaded newer image for s390x/nginx:latest docker.io/s390x/nginx:latest Re-tag your docker images by running the following command. Build your Linux-based container image for s390x architecture by using a build tool such as docker build . For example, your source code is stored in a github repository and the result s390x architecture container image will be pushed to a remote Docker repository with DCT enabled. docker tag <your_docker_id>/<result_image_name>:<tag> <your_docker_id>/<result_image_name>:<new-tag> Example output docker tag s390x/nginx:latest hpvsdemo/hpvsdemo_secureapp:secureapp Push your images to the DockerHub by running the following command. docker push <your_docker_id>/<result_image_name>:<new-tag> Example output docker push hpvsdemo/hpvsdemo_secureapp:secureapp The push refers to repository [ docker.io/hpvsdemo/hpvsdemo_secureapp ] ac2dc34ad3c9: Mounted from hpvsdemo/secure_app_nginx_new b2ef6e716a0f: Mounted from hpvsdemo/secure_app_nginx_new cb2071142d0b: Mounted from hpvsdemo/secure_app_nginx_new b60202bb076f: Mounted from hpvsdemo/secure_app_nginx 563b53cd7a3f: Mounted from hpvsdemo/secure_app_nginx_new secureapp: digest: sha256:9b47e7c64b1f9149832d1ef7cbf9d80b9b55466a9c6c8212f30d15966fd9f1a6 size: 1362 Signing and pushing trust metadata Enter passphrase for root key with ID 1bec86a: Enter passphrase for root key with ID 1bec86a: Enter passphrase for new repository key with ID 3237039 : Repeat passphrase for new repository key with ID 3237039 : Finished initializing \"docker.io/hpvsdemo/hpvsdemo_secureapp\" Successfully signed docker.io/hpvsdemo/hpvsdemo_secureapp:secureapp Enter your root passphrase and repository passphrase when you are prompted to. The generated public key is stored in ~/.docker/trust/tuf/docker.io/<your_docker_id>/<result_image_name>/metadata/root.json / step_2 \u00b6 Adding the registry Verify whether you already have a registry by running the following command. hpvs registry list If there are no registries displayed, then add a registry by running the following command. hpvs registry add --name registry_name --user <username> --dct https://notary.docker.io --url docker.io Where name - Specify a name for your registry. user - Docker registry username. step_3 \u00b6 Generating the signing keys To generate the signing keys, follow the instructions listed in the topic Generating the signing keys . step_4 \u00b6 Preparing the configuration Create the configuration yaml secure_create.yaml file so that the repository registration file for your image can be generated. You can use the $HOME/hpvs/config/securebuild/secure_create.yaml.example example file as a reference when updating the file. Example of a secure_create.yaml file repository_registration: docker: repo: 'hpvsdemo/nginx' pull_server: 'docker_reg' # this root.json you will get after once you will push image to DockerHub using Docker Content Trust content_trust_json_file_path: 'home/hpvs_user/hpvs/config/reg.json' env: whitelist: [\"ROOT_SSH_KEY\",\"SERVER_KEY\", \"RUNQ_ROOTDISK\", \"LOGTARGET\", \"ROOTFS_LOCK\"] signing_key: # complete path of signing private key private_key_path: '/home/hpvs_user/.ssh/hpvs_user/isv_user.private' # complete path of signing public key public_key_path: '/home/hpvs_user/.ssh/hpvs_user/isv_user.pub'. Note : If you want to use your own image instead of the sample application provided, see Deploying your applications securely , for instructions. Generate the repository registration file for your image. hpvs regfile create --config $HOME/hpvs/config/securebuild/secure_create.yaml --out $HOME/hpvs/config/securebuild/regfiles/encryptedRegfile.enc Example of the command hpvs regfile create --config $HOME/hpvs/config/securebuild/secure_create.yaml --out $HOME/hpvs/config/securebuild/regfiles/Ngnix.enc step_5 \u00b6 Deploy your image Complete the following steps to deploy your own image by using the hpvs deploy command. Create the \"nginx_demo_byoi.yml\" file by referring to the example vs_configfile_readme.yaml available in $HOME/home/hpvs/config . Example of the nginx_demo_byoi.yml file version: v1 type: virtualserver virtualservers: - name: test-nginx host: test2 repoid: Nginx imagetag: latest reporegfile: $HOME/hpvs/config/securebuild/regfiles/Nginx.enc resourcedefinition: ref: small networks: # - ref: external_network # ipaddress: 129.40.15.20 environment: - key: LOGTARGET - value: /dev/console - key: ROOTFS_LOCK - value: Y - key: ROOT_SSH_KEY - value: '@/home/hpvs_user/.ssh/id-rsa' - key: RUNQ_ROOTDISK - value: new_qg_nginx volumes: - mounts: - filesystem: ext4 mount_id: new_qg_nginx mountpoint: /newroot size: 10GB - filesystem: ext4 mount_id: data mountpoint: /data size: 10GB - name: qg_hpvs_nginx ref : np-medium Note : You can view the example configuration files at home/hpvs_user/HPVS1221_Production/config/yaml . Deploy the image by using the configurations in the yaml file. hpvs deploy --config $HOME/hpvs/config/vs_configfile_readme.yaml --templatefile ../../templates/virtualserver.template.yml Example of the command hpvs deploy --config $HOME/home/hpvs/config/nginx_demo.yml --templatefile ../../templates/virtualserver.template.yml Example output You can update the resources or configuration of a virtual server after the completion of the deploy operation by using the -u , or the --update flag of the hpvs deploy command. For more information about this command, see Updating virtual servers .","title":"Deploying your applications securely"},{"location":"byoi/byoi/#deploying-your-applications-securely","text":"This topic provides information about how you can deploy your own Linux-based container image (bring your own image) as a Hyper Protect Virtual Server on the IBM Hyper Protect Virtual Servers.","title":"Deploying your applications securely"},{"location":"byoi/byoi/#prerequisites","text":"The following are the prerequisites for being able to deploy your own image into the IBM Hyper Protect Virtual Servers: Ensure your Linux-based container image are built for the IBM LinuxONE and IBM Z platform (s390x architecture), and available on DockerHub . Ensure your Linux-based container images are signed using Docker Content Trust . If not signed by using Docker Content Trust, follow the steps listed in Sign your image by using Docker Content Trust . Complete the following steps with root user authority. Sign your image by using Docker Content Trust Adding the registry Generating the signing keys Preparing the configuration Deploy your image","title":"Prerequisites"},{"location":"byoi/byoi/#step_1","text":"Sign your image by using Docker Content Trust Log in to Docker hub using your Docker Hub credentials, if you are not logged-in yet. Example output docker login Login with your Docker ID to push and pull images from Docker Hub. If you do not have a Docker ID, go to https://hub.docker.com to create one. Username: hpvsdemo Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded Enable Docker Content Trust (DCT), specify the server for the Docker Content Trust service by running the following command. export DOCKER_CONTENT_TRUST=1 export DOCKER_CONTENT_TRUST_SERVER=https://notary.docker.io Run the following command to load the image (Nginx application) from the DockerHub onto your management server. docker image pull <your_docker_id>/<result_image_name>:<tag> Example output docker image pull s390x/nginx:latest latest: Pulling from s390x/nginx 405e75bf6bb0: Pull complete 513ab99245be: Pull complete 0057372a1eb7: Pull complete e8a2963860c1: Pull complete ed9d8c330029: Pull complete Digest: sha256:9b47e7c64b1f9149832d1ef7cbf9d80b9b55466a9c6c8212f30d15966fd9f1a6 Status: Downloaded newer image for s390x/nginx:latest docker.io/s390x/nginx:latest Re-tag your docker images by running the following command. Build your Linux-based container image for s390x architecture by using a build tool such as docker build . For example, your source code is stored in a github repository and the result s390x architecture container image will be pushed to a remote Docker repository with DCT enabled. docker tag <your_docker_id>/<result_image_name>:<tag> <your_docker_id>/<result_image_name>:<new-tag> Example output docker tag s390x/nginx:latest hpvsdemo/hpvsdemo_secureapp:secureapp Push your images to the DockerHub by running the following command. docker push <your_docker_id>/<result_image_name>:<new-tag> Example output docker push hpvsdemo/hpvsdemo_secureapp:secureapp The push refers to repository [ docker.io/hpvsdemo/hpvsdemo_secureapp ] ac2dc34ad3c9: Mounted from hpvsdemo/secure_app_nginx_new b2ef6e716a0f: Mounted from hpvsdemo/secure_app_nginx_new cb2071142d0b: Mounted from hpvsdemo/secure_app_nginx_new b60202bb076f: Mounted from hpvsdemo/secure_app_nginx 563b53cd7a3f: Mounted from hpvsdemo/secure_app_nginx_new secureapp: digest: sha256:9b47e7c64b1f9149832d1ef7cbf9d80b9b55466a9c6c8212f30d15966fd9f1a6 size: 1362 Signing and pushing trust metadata Enter passphrase for root key with ID 1bec86a: Enter passphrase for root key with ID 1bec86a: Enter passphrase for new repository key with ID 3237039 : Repeat passphrase for new repository key with ID 3237039 : Finished initializing \"docker.io/hpvsdemo/hpvsdemo_secureapp\" Successfully signed docker.io/hpvsdemo/hpvsdemo_secureapp:secureapp Enter your root passphrase and repository passphrase when you are prompted to. The generated public key is stored in ~/.docker/trust/tuf/docker.io/<your_docker_id>/<result_image_name>/metadata/root.json /","title":"step_1"},{"location":"byoi/byoi/#step_2","text":"Adding the registry Verify whether you already have a registry by running the following command. hpvs registry list If there are no registries displayed, then add a registry by running the following command. hpvs registry add --name registry_name --user <username> --dct https://notary.docker.io --url docker.io Where name - Specify a name for your registry. user - Docker registry username.","title":"step_2"},{"location":"byoi/byoi/#step_3","text":"Generating the signing keys To generate the signing keys, follow the instructions listed in the topic Generating the signing keys .","title":"step_3"},{"location":"byoi/byoi/#step_4","text":"Preparing the configuration Create the configuration yaml secure_create.yaml file so that the repository registration file for your image can be generated. You can use the $HOME/hpvs/config/securebuild/secure_create.yaml.example example file as a reference when updating the file. Example of a secure_create.yaml file repository_registration: docker: repo: 'hpvsdemo/nginx' pull_server: 'docker_reg' # this root.json you will get after once you will push image to DockerHub using Docker Content Trust content_trust_json_file_path: 'home/hpvs_user/hpvs/config/reg.json' env: whitelist: [\"ROOT_SSH_KEY\",\"SERVER_KEY\", \"RUNQ_ROOTDISK\", \"LOGTARGET\", \"ROOTFS_LOCK\"] signing_key: # complete path of signing private key private_key_path: '/home/hpvs_user/.ssh/hpvs_user/isv_user.private' # complete path of signing public key public_key_path: '/home/hpvs_user/.ssh/hpvs_user/isv_user.pub'. Note : If you want to use your own image instead of the sample application provided, see Deploying your applications securely , for instructions. Generate the repository registration file for your image. hpvs regfile create --config $HOME/hpvs/config/securebuild/secure_create.yaml --out $HOME/hpvs/config/securebuild/regfiles/encryptedRegfile.enc Example of the command hpvs regfile create --config $HOME/hpvs/config/securebuild/secure_create.yaml --out $HOME/hpvs/config/securebuild/regfiles/Ngnix.enc","title":"step_4"},{"location":"byoi/byoi/#step_5","text":"Deploy your image Complete the following steps to deploy your own image by using the hpvs deploy command. Create the \"nginx_demo_byoi.yml\" file by referring to the example vs_configfile_readme.yaml available in $HOME/home/hpvs/config . Example of the nginx_demo_byoi.yml file version: v1 type: virtualserver virtualservers: - name: test-nginx host: test2 repoid: Nginx imagetag: latest reporegfile: $HOME/hpvs/config/securebuild/regfiles/Nginx.enc resourcedefinition: ref: small networks: # - ref: external_network # ipaddress: 129.40.15.20 environment: - key: LOGTARGET - value: /dev/console - key: ROOTFS_LOCK - value: Y - key: ROOT_SSH_KEY - value: '@/home/hpvs_user/.ssh/id-rsa' - key: RUNQ_ROOTDISK - value: new_qg_nginx volumes: - mounts: - filesystem: ext4 mount_id: new_qg_nginx mountpoint: /newroot size: 10GB - filesystem: ext4 mount_id: data mountpoint: /data size: 10GB - name: qg_hpvs_nginx ref : np-medium Note : You can view the example configuration files at home/hpvs_user/HPVS1221_Production/config/yaml . Deploy the image by using the configurations in the yaml file. hpvs deploy --config $HOME/hpvs/config/vs_configfile_readme.yaml --templatefile ../../templates/virtualserver.template.yml Example of the command hpvs deploy --config $HOME/home/hpvs/config/nginx_demo.yml --templatefile ../../templates/virtualserver.template.yml Example output You can update the resources or configuration of a virtual server after the completion of the deploy operation by using the -u , or the --update flag of the hpvs deploy command. For more information about this command, see Updating virtual servers .","title":"step_5"},{"location":"byoi/gen_sign_key/","text":"Generating the signing keys \u00b6 You can generate the key pair for signing the repository registration file by using the GnuPG tool. This procedure is intended for users with the role cloud administrator and app developer or ISV . Procedure \u00b6 List the GPG keys by running the following command. gpg --list-keys gpg --list-secret-keys The following commands create a GPG key pair, export the public key isv_user.pub and the private key isv_user.private . The key pair is protected by using the passphrase over-the-lazy-dog . If isv_user is listed when you run the gpg --list-keys command, then you must use another name. export keyName=isv_user export passphrase=over-the-lazy-dog cat >isv_definition_keys <<EOF %echo Generating registration definition key Key-Type: RSA Key-Length: 4096 Subkey-Type: RSA Subkey-Length: 4096 Name-Real: isv_user Expire-Date: 0 Passphrase: over-the-lazy-dog # Do a commit here, so that we can later print \"done\" :-) %commit %echo done EOF gpg -a --batch --generate-key isv_definition_keys gpg --armor --pinentry-mode=loopback --passphrase ${passphrase} --export-secret-keys ${keyName} > ${keyName}.private gpg --armor --export ${keyName} > ${keyName}.pub The \"export keyName=isv_user\" and \"Name-Real: isv_user\" must be unique. You cannot use the same keys to sign multiple images. You should not have multiple keys with same username, also you should not have multiple images singed with same key in a Secure Service Container. Copy the generated key pair isv_user.pub and isv_user.private to the <$HOME/hpvs>/config directory on your x86 or Linux on IBM Z/LinuxONE (i.e., s390x architecture) management server.","title":"Generating signing keys"},{"location":"byoi/gen_sign_key/#generating-the-signing-keys","text":"You can generate the key pair for signing the repository registration file by using the GnuPG tool. This procedure is intended for users with the role cloud administrator and app developer or ISV .","title":"Generating the signing keys"},{"location":"byoi/gen_sign_key/#procedure","text":"List the GPG keys by running the following command. gpg --list-keys gpg --list-secret-keys The following commands create a GPG key pair, export the public key isv_user.pub and the private key isv_user.private . The key pair is protected by using the passphrase over-the-lazy-dog . If isv_user is listed when you run the gpg --list-keys command, then you must use another name. export keyName=isv_user export passphrase=over-the-lazy-dog cat >isv_definition_keys <<EOF %echo Generating registration definition key Key-Type: RSA Key-Length: 4096 Subkey-Type: RSA Subkey-Length: 4096 Name-Real: isv_user Expire-Date: 0 Passphrase: over-the-lazy-dog # Do a commit here, so that we can later print \"done\" :-) %commit %echo done EOF gpg -a --batch --generate-key isv_definition_keys gpg --armor --pinentry-mode=loopback --passphrase ${passphrase} --export-secret-keys ${keyName} > ${keyName}.private gpg --armor --export ${keyName} > ${keyName}.pub The \"export keyName=isv_user\" and \"Name-Real: isv_user\" must be unique. You cannot use the same keys to sign multiple images. You should not have multiple keys with same username, also you should not have multiple images singed with same key in a Secure Service Container. Copy the generated key pair isv_user.pub and isv_user.private to the <$HOME/hpvs>/config directory on your x86 or Linux on IBM Z/LinuxONE (i.e., s390x architecture) management server.","title":"Procedure"},{"location":"byoi/overview_byoi/","text":"Bring your own image overview \u00b6 You can deploy your own Linux-based container image as a Hyper Protect Virtual Server on the IBM Hyper Protect Virtual Servers. This feature is also known as bring your own image (BYOI) . This procedure is intended for users with the role cloud administrator and app developer or ISV . App developer or ISV prepares Linux-based container image for s390x architecture. Cloud administrator registers the repository for the App developer or ISV. App developer or ISV can later deploy the images into the IBM Hyper Protect Virtual Servers. Prerequisites \u00b6 See the Prerequisites page to complete the prerequisites for this trial. You must complete the prerequisites listed if you want to use your own image. This includes creating accounts and credentials to access the Docker Image Management (Docker Registry) Docker Hub . Also, ensure that your Linux-based container images are built for the IBM LinuxONE and IBM Z platform (s390x architecture). BYOI Process \u00b6 The following are the steps that comprises this process: 1. Setup 2. Sign your image by using Docker Content Trust 3. Adding the registry 4. Generating the signing keys 5. Preparing the configuration 6. Deploy your image After you complete the process listed above, you can clean up your environment for future users.","title":"Bring your own image overview"},{"location":"byoi/overview_byoi/#bring-your-own-image-overview","text":"You can deploy your own Linux-based container image as a Hyper Protect Virtual Server on the IBM Hyper Protect Virtual Servers. This feature is also known as bring your own image (BYOI) . This procedure is intended for users with the role cloud administrator and app developer or ISV . App developer or ISV prepares Linux-based container image for s390x architecture. Cloud administrator registers the repository for the App developer or ISV. App developer or ISV can later deploy the images into the IBM Hyper Protect Virtual Servers.","title":"Bring your own image overview"},{"location":"byoi/overview_byoi/#prerequisites","text":"See the Prerequisites page to complete the prerequisites for this trial. You must complete the prerequisites listed if you want to use your own image. This includes creating accounts and credentials to access the Docker Image Management (Docker Registry) Docker Hub . Also, ensure that your Linux-based container images are built for the IBM LinuxONE and IBM Z platform (s390x architecture).","title":"Prerequisites"},{"location":"byoi/overview_byoi/#byoi-process","text":"The following are the steps that comprises this process: 1. Setup 2. Sign your image by using Docker Content Trust 3. Adding the registry 4. Generating the signing keys 5. Preparing the configuration 6. Deploy your image After you complete the process listed above, you can clean up your environment for future users.","title":"BYOI Process"},{"location":"grep11/exercise-overview/","text":"An overview of the exercises \u00b6 Expand the lab folder in your Visual Studio Code explorer pane so that you can see the source code files in the folder, similar to what is shown in the screen snippet below: Running the go test -v command in the golang/examples directory was good for ensuring that our GREP11 server setup works and that our client application can access it. But there is not a lot of output produced by this test, so we took the functions used in the test and added statements in many places to produce output for educational purposes. We also added some flexibility to the functions by adding some function arguments that would let us modify function behavior, again, for educational purposes. We left the golang/examples directory intact, and copied the source code into a new directory that we created, golang/lab , and made our program modifications in that directory. Note These exercises are meant to illustrate various concepts for learning about the functionality that the GREP11 server and the Crypto Express card in EP11 mode provide, and are not meant to illustrate Go programming lanuage best practices. In fact, we violated one best practice (DRY - Don't Repeat Yourself) when we copied the examples directory into the lab directory! Feel free to copy our source code and use it as you see fit, but it is provided \"as is\", without support or warranty of any kind. Other than adding a whole bunch of statements to print output, at a high level, the following changes in program structure were made after copying the source code from golang/examples into golang/labs The routine to set the variables needed to connect to the GREP11 server was moved into a separate file, callopt.go . This routine specifies the IP address and port where the GREP11 server is listening, and it also contains variables specifying the certificates and keys necessary to establish a session between our program and the GREP11 server using mutual TLS authentication. Note The information in the callopt.go file is the type of information that would be provided by an administrator, such as the Hyper Protect Virtual Servers administrator for hostname or IP address and port for connection, and perhaps the same or a different security administrator for the certficates and keys necessary to successfully establish the connection with mutual TLS authentication. A main() function, which is the entry point for the program, was created, in the file main.go . It uses arguments to determine which of the four exercises to invoke. (You can actually invoke any combination of them in one program invocation but in our lab instructions we only have you do one at a time). We added some extra arguments that work with exercises two, three, and four, in order to illustrate concepts of interest. There are four separate source files, exercise1.go , exercise2.go , exercise3.go , and exercise4.go each of which was created by copying one of the Example_ test functions from golang/examples/server_test.go , modifying the name of the function to remove Example_ from its name to reinforce the point that it was no longer a function suitable for using with the go test command. exercise1.go began life as Example_getMechanismInfo() exercise2.go started out as Example_encryptAndDecrypt() exercise3.go was Example_signAndVerifyUsingECDSAKeyPair() exercise4.go had its origins as Example_wrapAndUnwrapKey() We deleted some of the files that we copied over that were not needed to run our lab exercises. It's time to start the first exercise. Enjoy!","title":"An overview of the Exercises"},{"location":"grep11/exercise-overview/#an-overview-of-the-exercises","text":"Expand the lab folder in your Visual Studio Code explorer pane so that you can see the source code files in the folder, similar to what is shown in the screen snippet below: Running the go test -v command in the golang/examples directory was good for ensuring that our GREP11 server setup works and that our client application can access it. But there is not a lot of output produced by this test, so we took the functions used in the test and added statements in many places to produce output for educational purposes. We also added some flexibility to the functions by adding some function arguments that would let us modify function behavior, again, for educational purposes. We left the golang/examples directory intact, and copied the source code into a new directory that we created, golang/lab , and made our program modifications in that directory. Note These exercises are meant to illustrate various concepts for learning about the functionality that the GREP11 server and the Crypto Express card in EP11 mode provide, and are not meant to illustrate Go programming lanuage best practices. In fact, we violated one best practice (DRY - Don't Repeat Yourself) when we copied the examples directory into the lab directory! Feel free to copy our source code and use it as you see fit, but it is provided \"as is\", without support or warranty of any kind. Other than adding a whole bunch of statements to print output, at a high level, the following changes in program structure were made after copying the source code from golang/examples into golang/labs The routine to set the variables needed to connect to the GREP11 server was moved into a separate file, callopt.go . This routine specifies the IP address and port where the GREP11 server is listening, and it also contains variables specifying the certificates and keys necessary to establish a session between our program and the GREP11 server using mutual TLS authentication. Note The information in the callopt.go file is the type of information that would be provided by an administrator, such as the Hyper Protect Virtual Servers administrator for hostname or IP address and port for connection, and perhaps the same or a different security administrator for the certficates and keys necessary to successfully establish the connection with mutual TLS authentication. A main() function, which is the entry point for the program, was created, in the file main.go . It uses arguments to determine which of the four exercises to invoke. (You can actually invoke any combination of them in one program invocation but in our lab instructions we only have you do one at a time). We added some extra arguments that work with exercises two, three, and four, in order to illustrate concepts of interest. There are four separate source files, exercise1.go , exercise2.go , exercise3.go , and exercise4.go each of which was created by copying one of the Example_ test functions from golang/examples/server_test.go , modifying the name of the function to remove Example_ from its name to reinforce the point that it was no longer a function suitable for using with the go test command. exercise1.go began life as Example_getMechanismInfo() exercise2.go started out as Example_encryptAndDecrypt() exercise3.go was Example_signAndVerifyUsingECDSAKeyPair() exercise4.go had its origins as Example_wrapAndUnwrapKey() We deleted some of the files that we copied over that were not needed to run our lab exercises. It's time to start the first exercise. Enjoy!","title":"An overview of the exercises"},{"location":"grep11/grep11-display/","text":"Displaying your GREP11 environment \u00b6 List Crypto Domains on your Hyper Protect Virtual Servers LPAR \u00b6 List your available domains with the Hyper Protect Virtual Server CLI: hpvs crypto list Example output hpvs crypto list +---------------+--------+ | CRYPTO.DOMAIN | STATUS | +---------------+--------+ | 08.0016 | in use | | 0a.0016 | in use | +---------------+--------+ A value of in use in the STATUS column indicates that each crypto domain has a GREP11 server connected to it. Display the GREP11 servers \u00b6 Display the virtual servers running on the Hyper Protect Virtual Servers LPAR: hpvs vs list Example output +----------------------+---------+-------------+---------------------------------------+ | NAMES | STATE | STATUS | IMAGE | +----------------------+---------+-------------+---------------------------------------+ | grep11-08-0016-9876 | running | Up 16 hours | ibmzcontainers/hpcs-grep11-prod:1.2.1 | | grep11-0a-0016-19876 | running | Up 16 hours | ibmzcontainers/hpcs-grep11-prod:1.2.1 | | monitoring | running | Up 4 weeks | ibmzcontainers/monitoring:1.2.1 | | collectd | running | Up 4 weeks | ibmzcontainers/collectd-host:1.2.1 | | hpvs_grafana | running | Up 3 weeks | jinxiong/hpvs_grafana:latest | | prom0630_19 | running | Up 3 weeks | jinxiong/prom0630:latest | +----------------------+---------+-------------+---------------------------------------+ Observe that there are two servers listed whose name starts with grep11 . These are the two GREP11 servers that we have provided. One accessible from host port 9876 and one from host port 19876. Note The list you see may differ from what is shown in our example, but you should see the two GREP11 servers whose names are highlighted in our example. Display details about one of the GREP11 servers with this command: hpvs vs show --name grep11-08-0016-9876 Example output +-------------+------------------------------+ | PROPERTIES | VALUES | +-------------+------------------------------+ | Name | grep11-08-0016-9876 | | Status | Up 16 hours | | CPU | 2 | | Memory | 2048 | | Networks | Network:bridge | | | IPAddress:172.31.0.4 | | | Gateway:172.31.0.1 | | | Subnet:16 | | | MacAddress:02:42:ac:1f:00:04 | | | | | | | | Ports | LocalPort:9876/tcp | | | GuestPort:9876 | | | | | Quotagroups | appliance_data | | | | | State | running | +-------------+------------------------------+ (Optional) Feel free to run the hpvs vs show command against the other GREP11 server. Please proceed to the next section of the lab.","title":"Displaying your GREP11 environment"},{"location":"grep11/grep11-display/#displaying-your-grep11-environment","text":"","title":"Displaying your GREP11 environment"},{"location":"grep11/grep11-display/#list-crypto-domains-on-your-hyper-protect-virtual-servers-lpar","text":"List your available domains with the Hyper Protect Virtual Server CLI: hpvs crypto list Example output hpvs crypto list +---------------+--------+ | CRYPTO.DOMAIN | STATUS | +---------------+--------+ | 08.0016 | in use | | 0a.0016 | in use | +---------------+--------+ A value of in use in the STATUS column indicates that each crypto domain has a GREP11 server connected to it.","title":"List Crypto Domains on your Hyper Protect Virtual Servers LPAR"},{"location":"grep11/grep11-display/#display-the-grep11-servers","text":"Display the virtual servers running on the Hyper Protect Virtual Servers LPAR: hpvs vs list Example output +----------------------+---------+-------------+---------------------------------------+ | NAMES | STATE | STATUS | IMAGE | +----------------------+---------+-------------+---------------------------------------+ | grep11-08-0016-9876 | running | Up 16 hours | ibmzcontainers/hpcs-grep11-prod:1.2.1 | | grep11-0a-0016-19876 | running | Up 16 hours | ibmzcontainers/hpcs-grep11-prod:1.2.1 | | monitoring | running | Up 4 weeks | ibmzcontainers/monitoring:1.2.1 | | collectd | running | Up 4 weeks | ibmzcontainers/collectd-host:1.2.1 | | hpvs_grafana | running | Up 3 weeks | jinxiong/hpvs_grafana:latest | | prom0630_19 | running | Up 3 weeks | jinxiong/prom0630:latest | +----------------------+---------+-------------+---------------------------------------+ Observe that there are two servers listed whose name starts with grep11 . These are the two GREP11 servers that we have provided. One accessible from host port 9876 and one from host port 19876. Note The list you see may differ from what is shown in our example, but you should see the two GREP11 servers whose names are highlighted in our example. Display details about one of the GREP11 servers with this command: hpvs vs show --name grep11-08-0016-9876 Example output +-------------+------------------------------+ | PROPERTIES | VALUES | +-------------+------------------------------+ | Name | grep11-08-0016-9876 | | Status | Up 16 hours | | CPU | 2 | | Memory | 2048 | | Networks | Network:bridge | | | IPAddress:172.31.0.4 | | | Gateway:172.31.0.1 | | | Subnet:16 | | | MacAddress:02:42:ac:1f:00:04 | | | | | | | | Ports | LocalPort:9876/tcp | | | GuestPort:9876 | | | | | Quotagroups | appliance_data | | | | | State | running | +-------------+------------------------------+ (Optional) Feel free to run the hpvs vs show command against the other GREP11 server. Please proceed to the next section of the lab.","title":"Display the GREP11 servers"},{"location":"grep11/grep11-setup/","text":"How to set up a GREP11 server \u00b6 Hyper Protect Virtual Servers LPAR setup \u00b6 Hyper Protect Virtual Servers runs in an LPAR that is defined in Secure Service Container (SSC) mode. Defining an LPAR is a normal task for an IBM Z or LinuxONE systems administrator, typically performed from the Hardware Management Console (HMC). The systems administrator must 1 dedicate one or more domains of one or more Crypto Express cards to the Hyper Protect Virtual Servers LPAR in order to use the GREP11 server. These Crypto Express cards must be defined in EP11 mode to your IBM Z or LinuxONE server in order to be used by a GREP11 server. These tasks are documented in the Hyper Protect Virtual Servers documentation, or in IBM publications referenced in the Hyper Protect Virtual Servers documentation. A GREP11 server communicates with one and only one Crypto Express domain, and vice versa. You can run multiple GREP11 servers if you have multiple domains configured to your Hyper Protect Virtual Servers LPAR. The GREP11 server is stateless, so desired levels of throughput and resilience can be achieved by loading the same master key in one or more domains of one or more Crypto Express 7S cards across one or more CECs across one or more geographies. Overview of GREP11 server setup \u00b6 This section provides an overview of what the remaining sections of this page will discuss in detail. The following steps are required: Create a Certification Authority (CA) certificate and key Create a GREP11 server X.509 certificate for Transport Layer Security (TLS) authentication Create an X.509 certificate for your client application for TLS authentication List Crypto Domains on your Hyper Protect Virtual Servers LPAR Create YAML and/or JSON configuration files for GREP11 server initialization Start the GREP11 server Important The commands shown on this page are for reference only - they have already been performed in order to set up the environment for you. Create a Certification Authority (CA) certificate and key \u00b6 The openssl utility is used to generate a private key and a certificate that will act as a certification authority (CA). This will be used in later steps to issue certificates for the GREP11 server and for the client application which will connect to the GREP11 server. Whenever you browse the web to a site with https , the server presents its certificate to your browser. This is known as server-side or one-way TLS authentication. Most websites do not ask you to present a certificate. The website makes itself available to anybody who browses to it. With mutual TLS authentication, the client does need to present a certificate. The server will only establish a session with a client who presents a certificate that is trusted by the server. This prevents our GREP11 server from being used by unauthorized clients. The following command was used to create the RSA private key which will be used by our soon to be created CA openssl genrsa -out atgz-hpvs-ca.key 2048 This created a file named atgz-hpvs-ca.key which is an RSA private key. In most cases (and mandatory from PKCS #11 version 2.4 onwards) the RSA private key contains enough information to reconstitute the public key. It is for this reason that the private key is used as input to the following command, which will create a Certification Authority X.509 certificate. X.509 certificates contain information identifying the certificate holder, the attributes of the certificate, including what the certificate can be used for, and, importantly, the public key. We used this command to create this certificate. openssl req -new -x509 -key atgz-hpvs-ca.key -out atgz-hpvs-ca.pem The atgz-hpvs-ca.key file was input to this command, and the atgz-hpvs-ca.pem file is the output of this command. This atgz-hpvs-ca.pem file is our \"homegrown\" certification authority root certificate. I will use the Linux cat command to get a raw listing of the root certificate we just created: cat atgz-hpvs-ca.pem Example output -----BEGIN CERTIFICATE----- MIIDcDCCAlgCCQDrH6CQd+lq9DANBgkqhkiG9w0BAQsFADB6MQswCQYDVQQGEwJV UzERMA8GA1UECAwIVmlyZ2luaWExEDAOBgNVBAcMB0hlcm5kb24xDDAKBgNVBAoM A0lCTTEmMCQGA1UECwwdSUJNIFdhc2hpbmd0b24gU3lzdGVtcyBDZW50ZXIxEDAO BgNVBAMMB3dzY2hwdnMwHhcNMjAwNzEyMTQ0MDUzWhcNMjEwODExMTQ0MDUzWjB6 MQswCQYDVQQGEwJVUzERMA8GA1UECAwIVmlyZ2luaWExEDAOBgNVBAcMB0hlcm5k b24xDDAKBgNVBAoMA0lCTTEmMCQGA1UECwwdSUJNIFdhc2hpbmd0b24gU3lzdGVt cyBDZW50ZXIxEDAOBgNVBAMMB3dzY2hwdnMwggEiMA0GCSqGSIb3DQEBAQUAA4IB DwAwggEKAoIBAQDRxnTkDFqdSmgDGlsrKHljg9+Lbf8HLLwuopXzdLukCoGvlIAf SzZPBsHd4JbMnYLqsxQzLDC1CGb7mz0wzk75wzy4yyhKXFqsEsSoZNMtA0HzWghZ MVrebaBh27oiKHNBMwZWTHeW4GkiVQFjDwXr63VKv6R03I9CdxARyErfF6qLp++e CoQz43BLVbaT9wCzRcqChg5BhnIwBuO9cghJLiWT9EalQ0mndr8YSwkWfhcOniqA iB6mHRKRLh0SoEL1Zoqbf585SpysjkRRM8yjB4Ju4EnyiLxmTDjjuaJ8CUOuNz+m PhJf4bax9sOO4IVI63jHpmSJUVR2yiUB0HYVAgMBAAEwDQYJKoZIhvcNAQELBQAD ggEBAH2amw0xySsZj4NNo5QYVN209wUqRGSjsNCyIqO6j0k2Sastm1nxX8Yv7hNJ WUqgKpHSLQVCOpgld6V7YZnBd+53Iq87iymbQ1oA5D5bjoQLzAtRHHku6Kf0p08D NCXQOS197Z41hNmMYT1sqbgSv+z2aahCoQKD3Wdh0lXHL621UEMk3Qo5SqfZ+RCm m69v5KpG7YT3irABSAkYi8z2dN/lzHVfgEUa7+Im4NEVVCQwBld/+hX/64pd2Op7 tyvWa0MXc0O//D5NLNVyzZJcnps2ru1P6IeBEEsdfwkVNEBqUXxK4i5eFBkar5Qx OCqkCywplgKoAyh8SGTPIkS4xhw= -----END CERTIFICATE----- The first and last lines are meant to assure you that this is a certificate, but the lines in between are less insightful, as it is base64-encoded binary data. Fortunately the openssl utility comes to our rescue and allows us to print the certificate in a form that a human can hope to understand: openssl x509 -in atgz-hpvs-ca.pem -text Example output Certificate: Data: Version: 3 ( 0x2 ) Serial Number: 42 :85:e5:33:4e:1a:e2:d4:9e:ed:8f:1d:27:2f:f1:10:29:ed:31:67 Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, ST = Virginia, L = Herndon, O = IBM, OU = IBM Washington Systems Center, CN = wschpvs Validity Not Before: Jul 23 21 :36:44 2020 GMT Not After : Aug 22 21 :36:44 2021 GMT Subject: C = US, ST = Virginia, L = Herndon, O = IBM, OU = IBM Washington Systems Center, CN = wschpvs Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: ( 2048 bit ) Modulus: 00 :dd:b6:fa:09:ab:21:6a:6c:fa:0b:e0:49:f9:f5: b6:fa:f8:4f:26:10:cf:ef:11:2a:16:c3:3a:cb:3f: 9f:da:d1:62:2b:2e:e4:5f:c3:b6:ab:29:29:54:b7: 9e:97:4e:59:e3:d1:b2:51:27:f9:02:2f:dd:33:95: a9:9d:14:63:c1:ea:6e:04:f4:5a:d2:51:d9:e7:ca: 31 :01:5a:86:09:94:9b:0d:1e:03:3b:cb:ae:51:df: 18 :ec:ec:86:a2:8f:34:6f:bd:80:c5:a6:af:be:c7: 0b:d1:1b:dd:e0:9c:7d:a3:4b:00:65:a3:a5:fe:1c: bc:8b:fa:02:9d:7a:0d:7e:52:d9:6d:44:1d:5f:d7: 2f:93:6b:f6:b8:e6:66:05:43:55:8d:9c:d6:ec:96: 18 :0b:71:c8:c4:ad:fe:08:18:4e:e6:33:e9:5d:c9: c7:83:0b:83:2f:c4:85:7d:40:1f:6f:76:41:9f:c9: 50 :15:7a:cc:57:94:df:ec:b5:5e:08:1f:95:09:ab: d6:b3:68:bb:df:39:6f:f1:ba:f3:e2:90:97:27:55: 15 :5a:03:82:48:f6:ca:02:f9:90:55:f4:11:cd:31: 34 :68:87:22:8b:6e:39:fc:53:ad:2e:26:9d:24:27: 31 :37:25:bd:b2:4b:fb:a7:57:9c:86:d6:d8:bf:4a: ad:eb Exponent: 65537 ( 0x10001 ) X509v3 extensions: X509v3 Subject Key Identifier: 9B:D8:7D:1B:C2:7F:44:21:CB:18:54:0D:0A:E2:B6:E4:78:F4:F3:E5 X509v3 Authority Key Identifier: keyid:9B:D8:7D:1B:C2:7F:44:21:CB:18:54:0D:0A:E2:B6:E4:78:F4:F3:E5 X509v3 Basic Constraints: critical CA:TRUE Signature Algorithm: sha256WithRSAEncryption 6e:ca:cf:a8:f8:0c:bf:59:d8:c9:85:48:bc:d8:3c:7a:a0:da: 18 :b7:23:b2:40:ce:df:44:a9:f1:e2:8d:0e:c1:e3:b7:00:48: 71 :81:01:b9:42:b8:61:87:9b:85:4e:ca:27:71:b5:d1:c4:46: cd:57:91:2a:04:54:b9:ab:f5:df:82:16:aa:80:11:27:7b:ba: ef:11:d3:88:b1:46:d3:43:32:fb:ac:04:3c:9d:f1:c6:53:74: 36 :bd:e2:cb:ff:d2:a6:56:fa:3c:97:f6:e9:7c:63:93:2a:46: d4:1c:bf:c1:86:4e:52:9d:f6:0a:b4:73:21:7b:52:93:0f:3b: d5:83:f1:f8:22:ec:6a:02:26:22:6f:d7:e0:0d:5f:83:94:40: 46 :f6:5e:af:bc:c1:9b:86:2c:aa:e8:95:59:f6:11:31:0a:5a: 1a:36:69:b8:b0:11:32:61:cb:16:3b:3d:7f:56:08:1a:5f:5b: 15 :e2:4e:2f:c8:46:4a:ce:02:12:90:af:74:b9:81:34:0c:dd: b7:0f:fc:88:49:d6:37:d0:25:72:4d:e1:b5:69:a0:79:b4:38: 02 :47:c1:30:cf:6b:14:12:e8:d8:b9:e2:c6:68:60:00:6a:e8: 14 :08:bd:7f:5c:df:d9:73:1a:51:f8:b9:4a:a6:0a:b8:6c:04: bf:34:94:49 -----BEGIN CERTIFICATE----- MIID1TCCAr2gAwIBAgIUQoXlM04a4tSe7Y8dJy/xECntMWcwDQYJKoZIhvcNAQEL BQAwejELMAkGA1UEBhMCVVMxETAPBgNVBAgMCFZpcmdpbmlhMRAwDgYDVQQHDAdI ZXJuZG9uMQwwCgYDVQQKDANJQk0xJjAkBgNVBAsMHUlCTSBXYXNoaW5ndG9uIFN5 c3RlbXMgQ2VudGVyMRAwDgYDVQQDDAd3c2NocHZzMB4XDTIwMDcyMzIxMzY0NFoX DTIxMDgyMjIxMzY0NFowejELMAkGA1UEBhMCVVMxETAPBgNVBAgMCFZpcmdpbmlh MRAwDgYDVQQHDAdIZXJuZG9uMQwwCgYDVQQKDANJQk0xJjAkBgNVBAsMHUlCTSBX YXNoaW5ndG9uIFN5c3RlbXMgQ2VudGVyMRAwDgYDVQQDDAd3c2NocHZzMIIBIjAN BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3bb6Cashamz6C+BJ+fW2+vhPJhDP 7xEqFsM6yz+f2tFiKy7kX8O2qykpVLeel05Z49GyUSf5Ai/dM5WpnRRjwepuBPRa 0lHZ58oxAVqGCZSbDR4DO8uuUd8Y7OyGoo80b72AxaavvscL0Rvd4Jx9o0sAZaOl /hy8i/oCnXoNflLZbUQdX9cvk2v2uOZmBUNVjZzW7JYYC3HIxK3+CBhO5jPpXcnH gwuDL8SFfUAfb3ZBn8lQFXrMV5Tf7LVeCB+VCavWs2i73zlv8brz4pCXJ1UVWgOC SPbKAvmQVfQRzTE0aIcii245/FOtLiadJCcxNyW9skv7p1echtbYv0qt6wIDAQAB o1MwUTAdBgNVHQ4EFgQUm9h9G8J/RCHLGFQNCuK25Hj08+UwHwYDVR0jBBgwFoAU m9h9G8J/RCHLGFQNCuK25Hj08+UwDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG9w0B AQsFAAOCAQEAbsrPqPgMv1nYyYVIvNg8eqDaGLcjskDO30Sp8eKNDsHjtwBIcYEB uUK4YYebhU7KJ3G10cRGzVeRKgRUuav134IWqoARJ3u67xHTiLFG00My+6wEPJ3x xlN0Nr3iy//Splb6PJf26XxjkypG1By/wYZOUp32CrRzIXtSkw871YPx+CLsagIm Im/X4A1fg5RARvZer7zBm4YsquiVWfYRMQpaGjZpuLARMmHLFjs9f1YIGl9bFeJO L8hGSs4CEpCvdLmBNAzdtw/8iEnWN9Alck3htWmgebQ4AkfBMM9rFBLo2Lnixmhg AGroFAi9f1zf2XMaUfi5SqYKuGwEvzSUSQ == -----END CERTIFICATE----- A few lines of the output above have been highlighted. Notice the highlighted line that says CA: TRUE . This attribute indicates that this certificate is acting as a certification authority and can issue other certificates. Notice the lines above it which have values for Subject Key Identifier and Authority Key Identifier . Subject Key Identifier is the identity of the holder of the certificate. Authority Key Identifier is the identity of the issuer of the certificate. You can see that the values for these are the same. This is known as a self-signed certificate . Certification authorities (CA) exist in a hierarchy- one CA can issue a certificate to another CA with the CA: TRUE attribute, and so forth. In our hosted trial we have this single, homegrown certification authority that we created, with its self-signed certificate that we created per the instructions in the Hyper Protect Virtual Servers documentation. Create a GREP11 server X.509 certificate for TLS authentication \u00b6 Once we created a \"homegrown\" certification authority, we next created an X.509 certificate for our GREP11 server. This certificate was issued by our certification authority. The first step was to create another RSA private key that our GREP11 server will use: openssl genrsa -out server80-9876-19876-key.pem 2048 Note The value of the -out argument, server80-9876-19876-key.pem can be whatever you want it to be. I named it what I did for a reason. the 80 in server80 is for the last octet of my Hyper Protect Virtual Servers LPAR's IP adresss, 192.168.22.80, and I intend to use this certificate for two GREP11 servers, one listening on port 9876 on one of the LPAR's Crypto Express 7S domains, and the second server will listen on port 19876 on the LPAR's second Crypto Express 7S domain. Then, this private key was used as input to openssl in order to create a certificate signing request : openssl req -new -key server80-9876-19876-key.pem -out server80-9876-19876.csr The certificate signing request will be passed to our certification authority which will use the information to create an X.509 certificate. We used openssl for this, too: openssl x509 -sha256 -req -in server80-9876-19876.csr -CA ca.pem -CAkey ca.key -set_serial 8086 -extfile openssl.cnf -extensions server -days 365 -outform PEM -out server80-9876-19876.pem For more information about creating the openssl.cnf file, see OpenSSL configuration examples . The file name of the certificate that was created by the preceding command is the value of the -out argument, server80-9876-19876.pem . openssl allows us to list this certificate in human-friendly form: openssl x509 -in server80-9876-19876.pem -noout -text Example output Certificate: Data: Version: 3 (0x2) Serial Number: 8086 (0x1f96) Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, ST = Virginia, L = Herndon, O = IBM, OU = IBM Washington Systems Center, CN = wschpvs Validity Not Before: Jul 23 21:47:22 2020 GMT Not After : Jul 23 21:47:22 2021 GMT Subject: C = US, ST = Virginia, L = Herndon, O = IBM, OU = IBM Washington Systems Center, CN = 192.168.22.80 Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (2048 bit) Modulus: 00:b8:1a:5d:37:d6:c5:5b:2a:40:90:e5:e9:7f:c7: 19:e4:83:fd:ce:f7:1b:f7:37:09:c1:f6:1f:03:10: 78:70:52:27:66:1c:49:20:75:03:12:2f:7c:1b:ea: 7b:37:0e:95:46:08:41:c9:7a:b8:89:f6:74:7f:84: 14:aa:3f:91:94:78:df:8d:b0:47:9b:1f:2e:88:67: eb:13:71:a7:57:a8:c3:cd:fe:22:ea:05:35:42:6f: 33:f5:46:05:27:c1:16:06:8c:66:14:fc:44:d3:56: ae:8f:60:1b:df:72:02:a0:cb:89:bc:50:56:5f:aa: 97:57:03:7e:71:bc:71:7d:f3:9c:53:ae:12:0e:56: f0:46:45:e6:61:de:37:fa:40:b0:3b:fa:7e:a5:26: b0:06:67:49:b0:c1:c0:a1:35:5c:3d:c1:1b:d7:79: bf:c3:93:d3:e4:fa:72:06:ec:84:1f:0c:6a:d0:92: 33:f4:8a:22:bf:af:53:78:48:bd:3d:63:f5:78:d0: 08:bf:52:a1:ea:40:4e:74:9a:89:dc:7a:b0:dd:c7: e3:fe:35:58:91:65:c9:d2:00:d3:e9:fb:34:1e:39: 77:ac:2a:49:79:53:37:aa:59:16:ce:8c:18:d6:99: af:e7:8f:9b:dc:b7:33:7e:00:41:3a:73:c0:5e:d7: 92:63 Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Basic Constraints: CA:FALSE X509v3 Key Usage: Digital Signature, Key Encipherment, Data Encipherment X509v3 Extended Key Usage: TLS Web Server Authentication Netscape Cert Type: SSL Server X509v3 CRL Distribution Points: Full Name: URI:http://localhost/ca.crl X509v3 Subject Alternative Name: DNS:192.168.22.80:9876, DNS:192.168.22.80:19876, IP Address:192.168.22.80 Signature Algorithm: sha256WithRSAEncryption 8f:f2:7e:60:69:de:80:85:7b:9a:3e:c8:8a:c7:ee:ee:66:29: d7:bc:5b:54:0d:ae:50:7a:1a:9e:86:2e:ba:77:51:53:d3:c5: 64:e6:ca:1c:69:45:3c:db:1a:a8:cb:b4:7b:f7:1d:16:59:cb: 3c:89:80:1b:89:a3:cf:f3:6d:08:40:83:6f:f5:f5:f3:87:1f: 3c:0a:42:e3:c6:7c:56:be:5c:50:15:f5:2b:e7:cb:33:03:43: 30:e9:30:81:91:66:d7:34:70:ac:7b:09:bf:b0:32:41:09:7d: 0d:7d:ee:6a:19:4b:0e:18:a8:8d:0c:d7:3b:c7:c2:28:7a:c3: c8:4a:34:cb:2a:90:2a:70:af:03:04:3c:93:6b:ee:3f:c0:47: 45:10:59:67:3d:36:50:29:30:38:b2:f7:ff:a7:06:b3:b5:3b: 66:64:21:87:ef:ab:0e:e7:e7:4c:4d:06:5a:3b:4c:1e:0f:d4: de:08:6c:cc:24:6f:c1:1b:03:3d:27:4c:62:ea:a6:79:ab:f3: a7:13:8a:26:e3:2a:e7:c2:bf:28:f4:de:58:6d:e2:d7:ed:e6: bf:a7:b4:eb:61:c6:89:0c:df:fc:41:6d:b0:9a:ae:64:59:a8: 4e:86:5d:11:7e:1d:f6:b1:df:98:02:97:d8:12:63:dc:bf:3a: 10:5e:46:6c Create an X.509 certificate for your client application for TLS authentication \u00b6 The client applications need a certificate that is issued by the same certification authority that the GREP11 server uses. The process is similar- create a private key, pass that as input for the creation of a certificte signing request, and then pass that to the certification authority in order to receive a certificate. We used these commands: openssl genrsa -out client-key.pem 2048 openssl req -new -key client-key.pem -out client.csr openssl x509 -req -days 1000 -in client.csr -CA atgz-hpvs-ca.pem -CAcreateserial -CAkey atgz-hpvs-ca.key -out client.pem Here is a listing of the client certificate that you will be using in the hosted trial. It will be configured properly for you so that your client program can present it to the GREP11 server: openssl x509 -in client.pem -noout -text Example Output Certificate: Data: Version: 1 (0x0) Serial Number: 4f:07:1f:6e:5e:09:33:8d:6f:39:52:01:36:06:3e:bb:28:50:c9:41 Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, ST = Virginia, L = Herndon, O = IBM, OU = IBM Washington Systems Center, CN = wschpvs Validity Not Before: Jul 23 21:52:13 2020 GMT Not After : Apr 19 21:52:13 2023 GMT Subject: C = US, ST = Virginia, L = Herndon, O = IBM, OU = IBM Washington Systems Center, CN = GREP11 Lab Students Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (2048 bit) Modulus: 00:c4:ab:d2:80:e2:38:b8:9d:6b:7f:f0:ae:09:72: c4:64:57:1a:32:f9:eb:b5:31:e9:bf:81:0b:c1:d7: 01:b6:6d:c7:7c:26:d3:49:6b:3b:fd:54:11:cc:5e: 7e:2f:be:59:54:4d:a4:c4:5c:08:87:1f:2b:0f:bc: cf:91:cd:21:a9:8e:bd:34:87:bb:3c:dd:e7:64:e4: e2:5e:30:d1:27:74:d4:7e:9f:3b:2f:40:68:3d:d9: 7d:d7:ff:e8:b6:ad:3a:ab:ca:d9:74:51:fa:12:59: a3:e1:2a:13:e2:20:34:01:6a:a3:6a:7c:36:be:81: 37:2a:cb:3b:85:a0:59:f1:60:ca:be:de:ce:d0:0d: ab:31:e4:09:09:31:39:06:cb:8d:48:73:56:ec:4f: 93:cd:85:d9:59:89:9a:f3:d2:e5:d6:de:8e:e5:a5: 4d:20:89:07:e0:1b:bd:a0:09:6f:94:92:e7:77:f6: 76:f3:da:16:01:7c:80:76:cf:29:11:39:bc:6d:71: 4a:bd:08:ca:29:da:d0:16:22:f5:f0:4d:c2:83:e4: 8c:72:9b:b4:17:bf:48:09:29:6b:bd:4d:35:3b:44: 9f:2f:75:7f:e2:a6:08:e7:ae:bb:4d:77:10:83:e6: cd:09:21:18:68:b2:ad:0a:f0:74:e5:47:ad:41:e5: 41:6d Exponent: 65537 (0x10001) Signature Algorithm: sha256WithRSAEncryption 3f:ce:22:e4:ba:6b:1d:68:aa:b4:07:35:22:0c:d7:55:e7:dc: 4f:21:ca:17:ca:14:cd:b9:7e:ad:f1:93:84:9f:e4:96:84:10: 39:d7:36:1f:66:2d:15:1b:40:96:a6:79:5e:e4:a2:00:c8:fa: fe:1a:42:9f:37:45:c4:c7:d9:21:c7:04:82:37:21:a0:41:ca: 92:b7:b8:15:db:62:55:c8:55:02:d6:d7:3a:fb:1d:96:33:54: c8:f2:fd:d7:65:39:7c:12:13:e6:b5:91:fd:0e:68:21:30:41: 82:f0:c0:74:a5:12:18:5e:e4:4b:83:1a:7f:a3:cc:f7:0a:aa: 8f:f0:4e:0a:01:45:64:98:10:9a:f1:41:48:46:ec:df:3b:db: c5:2f:bb:ec:f7:dc:77:f0:98:e2:99:f4:20:fc:ff:45:24:af: 8a:56:e7:60:2f:aa:cc:af:8a:ae:a8:1f:33:a0:8e:5e:3e:46: 69:10:f0:b9:6c:02:6d:b3:4e:ef:cd:ac:06:86:67:9b:c9:44: 73:00:37:61:06:df:32:ce:e5:c3:28:04:8f:c8:e4:81:ec:16: 2c:dd:63:37:bd:07:ab:fc:f9:ac:55:e2:4a:b0:9b:5e:5d:f5: f1:89:90:0b:59:50:da:21:cb:db:96:c7:6d:fa:54:e4:f2:74: 86:e2:71:6e Note For the hosted trial, you will use a copy of the same client certificate. In most production use cases each client would use their own certificate which uniquely identifies them. List Crypto Domains on your Hyper Protect Virtual Servers LPAR \u00b6 You can list your available domains with the Hyper Protect Virtual Server CLI: hpvs crypto list Example output hpvs crypto list +---------------+--------+ | CRYPTO.DOMAIN | STATUS | +---------------+--------+ | 08.0016 | online | | 0a.0016 | online | +---------------+--------+ The values shown in the CRYPTO.DOMAIN column are in hexadecimal. So, translating to decimal, our LPAR is using Crypto Express 7S cards 8 and 10, with domain 22 in both cards assigned to our LPAR. (A Crypto Express 7S card can have up to 85 domains- think of each domain as a \"virtual\" Crypto Express 7S card). Create YAML or JSON configuration files for GREP11 server \u00b6 There are two alternative ways to start your GREP11 server: Using hpvs deploy with a YAML file as input Using hpvs vs create with a JSON file as input I will show both the YAML and JSON files first, then I will show both methods of starting the GREP11 server, and then I'll explain the difference between the two start methods. YAML file for GREP11 server configuration \u00b6 This is the YAML file for a GREP11 server that will listen for client connections on port 9876, and will use domain 22 (hex 16) of Crypto Express 7S card 08: GREP11 server YAML configuration file version: v1 # # use this file with the 'hpvs deploy' command, e.g., # # hpvs deploy --config $HOME/hpvs/config/grep11/vs_grep11.yml # type: virtualserver virtualservers: - name: grep11-08-0016-9876 host: wsclpar80 repoid: hpcsKpGrep11_runq imagetag: 1 .2.3 imagefile: hpcsKpGrep11_runq.tar.gz crypto: crypto_matrix: - 08 .0016 environment: - key: EP11SERVER_EP11CRYPTO_DOMAIN value: \"08.0016\" # - key: EP11SERVER_EP11CRYPTO_CONNECTION_TLS_CERTFILEBYTES value: \"@/home/hyper-protect-lab/hpvs/config/grep11/keys/server80-9876-19876.pem\" - key: EP11SERVER_EP11CRYPTO_CONNECTION_TLS_KEYFILEBYTES value: \"@/home/hyper-protect-lab/hpvs/config/grep11/keys/server80-9876-19876-key.pem\" - key: EP11SERVER_EP11CRYPTO_CONNECTION_TLS_CACERTBYTES value: \"@/home/hyper-protect-lab/hpvs/config/grep11/keys/ca.pem\" - key: EP11SERVER_EP11CRYPTO_CONNECTION_TLS_ENABLED value: \"true\" - key: EP11SERVER_EP11CRYPTO_CONNECTION_TLS_MUTUAL value: \"true\" - key: TLS_GRPC_CERTS_DOMAIN_CRT value: \"\\\\n\" - key: TLS_GRPC_CERTS_DOMAIN_KEY value: \"\\\\n\" - key: TLS_GRPC_CERTS_ROOTCA_CRT value: \"\\\\n\" ports: - hostport: 9876 protocol: tcp containerport: 9876 JSON file for GREP11 server configuration \u00b6 This is a JSON file for a GREP11 server that will listen for client connections on port 9876, and will use domain 22 (hex 16) of Crypto Express 7S card 08: GREP11 server JSON configuration file { \"EP11SERVER_EP11CRYPTO_DOMAIN\":\"08.0016\", \"EP11SERVER_EP11CRYPTO_CONNECTION_TLS_CERTFILEBYTES\":\"@/home/hyper-protect-lab/hpvs/config/grep11/keys/server80-9876-19876.pem\", \"EP11SERVER_EP11CRYPTO_CONNECTION_TLS_KEYFILEBYTES\":\"@/home/hyper-protect-lab/hpvs/config/grep11/keys/server80-9876-19876-key.pem\", \"EP11SERVER_EP11CRYPTO_CONNECTION_TLS_CACERTBYTES\":\"@/home/hyper-protect-lab/hpvs/config/grep11/keys/ca.pem\", \"EP11SERVER_EP11CRYPTO_CONNECTION_TLS_ENABLED\":true, \"EP11SERVER_EP11CRYPTO_CONNECTION_TLS_MUTUAL\":true, \"TLS_GRPC_CERTS_DOMAIN_CRT\":\"\\\\n\", \"TLS_GRPC_CERTS_DOMAIN_KEY\":\"\\\\n\", \"TLS_GRPC_CERTS_ROOTCA_CRT\":\"\\\\n\" } Start the GREP11 server \u00b6 If you looked carefully at the JSON file and the YAML file in the previous section, you may have noticed that the YAML file contains more information than the JSON file contains. As a result, the syntax is simpler for the command that uses the YAML file. The command that uses the JSON file uses command line arguments to provide some of the information that the YAML file contained. Compare the two methods: Command to start the GREP11 server with the YAML file hpvs deploy --config $HOME/hpvs/config/grep11/vs_grep11.yml Command to start the GREP11 server with the JSON file hpvs vs create --name grep11 --repo hpcsKpGrep11_runq --tag 1.2.3 --crypto_matrix=08.0016 --cpu 2 --ram 2048 --envjsonpath ${HOME}/hpvs/config/grep11/grep11_env_08.0016.json --ports \"{containerport = 9876, protocol = tcp, hostport = 9876}\" Difference between the two commands The hpvs deploy method simpler than the long syntax of the hpvs vs create command. But the hpvs vs create command has a benefit- the hpvs deploy command uploads the GREP11 server Docker image from your workstation where you run the CLI to the Hyper Protect Virtual Servers LPAR, every single time. This Docker image only needs to be sent up once. The hpvs vs create command is smart enough to have this figured out and not do the unnecessary upload of the Docker image the second and subsequent times you run it. Important Starting now, as you navigate to the next section of the hosted trial, you should enter all the commands shown in the lab. Only the commands in this section were for reference. The GREP11 server is a feature provided by Hyper Protect Virtual Servers. You are not required to use it. If you do not use this feature, you do not have to define Crypto Express domains to the LPAR. You may wish to for other purposes, and you can use the other modes offered by Crypto Express cards for those purposes, but you must use EP11 mode for usage by the GREP11 server. \u21a9","title":"How to set up a GREP11 server"},{"location":"grep11/grep11-setup/#how-to-set-up-a-grep11-server","text":"","title":"How to set up a GREP11 server"},{"location":"grep11/grep11-setup/#hyper-protect-virtual-servers-lpar-setup","text":"Hyper Protect Virtual Servers runs in an LPAR that is defined in Secure Service Container (SSC) mode. Defining an LPAR is a normal task for an IBM Z or LinuxONE systems administrator, typically performed from the Hardware Management Console (HMC). The systems administrator must 1 dedicate one or more domains of one or more Crypto Express cards to the Hyper Protect Virtual Servers LPAR in order to use the GREP11 server. These Crypto Express cards must be defined in EP11 mode to your IBM Z or LinuxONE server in order to be used by a GREP11 server. These tasks are documented in the Hyper Protect Virtual Servers documentation, or in IBM publications referenced in the Hyper Protect Virtual Servers documentation. A GREP11 server communicates with one and only one Crypto Express domain, and vice versa. You can run multiple GREP11 servers if you have multiple domains configured to your Hyper Protect Virtual Servers LPAR. The GREP11 server is stateless, so desired levels of throughput and resilience can be achieved by loading the same master key in one or more domains of one or more Crypto Express 7S cards across one or more CECs across one or more geographies.","title":"Hyper Protect Virtual Servers LPAR setup"},{"location":"grep11/grep11-setup/#overview-of-grep11-server-setup","text":"This section provides an overview of what the remaining sections of this page will discuss in detail. The following steps are required: Create a Certification Authority (CA) certificate and key Create a GREP11 server X.509 certificate for Transport Layer Security (TLS) authentication Create an X.509 certificate for your client application for TLS authentication List Crypto Domains on your Hyper Protect Virtual Servers LPAR Create YAML and/or JSON configuration files for GREP11 server initialization Start the GREP11 server Important The commands shown on this page are for reference only - they have already been performed in order to set up the environment for you.","title":"Overview of GREP11 server setup"},{"location":"grep11/grep11-setup/#create-a-certification-authority-ca-certificate-and-key","text":"The openssl utility is used to generate a private key and a certificate that will act as a certification authority (CA). This will be used in later steps to issue certificates for the GREP11 server and for the client application which will connect to the GREP11 server. Whenever you browse the web to a site with https , the server presents its certificate to your browser. This is known as server-side or one-way TLS authentication. Most websites do not ask you to present a certificate. The website makes itself available to anybody who browses to it. With mutual TLS authentication, the client does need to present a certificate. The server will only establish a session with a client who presents a certificate that is trusted by the server. This prevents our GREP11 server from being used by unauthorized clients. The following command was used to create the RSA private key which will be used by our soon to be created CA openssl genrsa -out atgz-hpvs-ca.key 2048 This created a file named atgz-hpvs-ca.key which is an RSA private key. In most cases (and mandatory from PKCS #11 version 2.4 onwards) the RSA private key contains enough information to reconstitute the public key. It is for this reason that the private key is used as input to the following command, which will create a Certification Authority X.509 certificate. X.509 certificates contain information identifying the certificate holder, the attributes of the certificate, including what the certificate can be used for, and, importantly, the public key. We used this command to create this certificate. openssl req -new -x509 -key atgz-hpvs-ca.key -out atgz-hpvs-ca.pem The atgz-hpvs-ca.key file was input to this command, and the atgz-hpvs-ca.pem file is the output of this command. This atgz-hpvs-ca.pem file is our \"homegrown\" certification authority root certificate. I will use the Linux cat command to get a raw listing of the root certificate we just created: cat atgz-hpvs-ca.pem Example output -----BEGIN CERTIFICATE----- MIIDcDCCAlgCCQDrH6CQd+lq9DANBgkqhkiG9w0BAQsFADB6MQswCQYDVQQGEwJV UzERMA8GA1UECAwIVmlyZ2luaWExEDAOBgNVBAcMB0hlcm5kb24xDDAKBgNVBAoM A0lCTTEmMCQGA1UECwwdSUJNIFdhc2hpbmd0b24gU3lzdGVtcyBDZW50ZXIxEDAO BgNVBAMMB3dzY2hwdnMwHhcNMjAwNzEyMTQ0MDUzWhcNMjEwODExMTQ0MDUzWjB6 MQswCQYDVQQGEwJVUzERMA8GA1UECAwIVmlyZ2luaWExEDAOBgNVBAcMB0hlcm5k b24xDDAKBgNVBAoMA0lCTTEmMCQGA1UECwwdSUJNIFdhc2hpbmd0b24gU3lzdGVt cyBDZW50ZXIxEDAOBgNVBAMMB3dzY2hwdnMwggEiMA0GCSqGSIb3DQEBAQUAA4IB DwAwggEKAoIBAQDRxnTkDFqdSmgDGlsrKHljg9+Lbf8HLLwuopXzdLukCoGvlIAf SzZPBsHd4JbMnYLqsxQzLDC1CGb7mz0wzk75wzy4yyhKXFqsEsSoZNMtA0HzWghZ MVrebaBh27oiKHNBMwZWTHeW4GkiVQFjDwXr63VKv6R03I9CdxARyErfF6qLp++e CoQz43BLVbaT9wCzRcqChg5BhnIwBuO9cghJLiWT9EalQ0mndr8YSwkWfhcOniqA iB6mHRKRLh0SoEL1Zoqbf585SpysjkRRM8yjB4Ju4EnyiLxmTDjjuaJ8CUOuNz+m PhJf4bax9sOO4IVI63jHpmSJUVR2yiUB0HYVAgMBAAEwDQYJKoZIhvcNAQELBQAD ggEBAH2amw0xySsZj4NNo5QYVN209wUqRGSjsNCyIqO6j0k2Sastm1nxX8Yv7hNJ WUqgKpHSLQVCOpgld6V7YZnBd+53Iq87iymbQ1oA5D5bjoQLzAtRHHku6Kf0p08D NCXQOS197Z41hNmMYT1sqbgSv+z2aahCoQKD3Wdh0lXHL621UEMk3Qo5SqfZ+RCm m69v5KpG7YT3irABSAkYi8z2dN/lzHVfgEUa7+Im4NEVVCQwBld/+hX/64pd2Op7 tyvWa0MXc0O//D5NLNVyzZJcnps2ru1P6IeBEEsdfwkVNEBqUXxK4i5eFBkar5Qx OCqkCywplgKoAyh8SGTPIkS4xhw= -----END CERTIFICATE----- The first and last lines are meant to assure you that this is a certificate, but the lines in between are less insightful, as it is base64-encoded binary data. Fortunately the openssl utility comes to our rescue and allows us to print the certificate in a form that a human can hope to understand: openssl x509 -in atgz-hpvs-ca.pem -text Example output Certificate: Data: Version: 3 ( 0x2 ) Serial Number: 42 :85:e5:33:4e:1a:e2:d4:9e:ed:8f:1d:27:2f:f1:10:29:ed:31:67 Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, ST = Virginia, L = Herndon, O = IBM, OU = IBM Washington Systems Center, CN = wschpvs Validity Not Before: Jul 23 21 :36:44 2020 GMT Not After : Aug 22 21 :36:44 2021 GMT Subject: C = US, ST = Virginia, L = Herndon, O = IBM, OU = IBM Washington Systems Center, CN = wschpvs Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: ( 2048 bit ) Modulus: 00 :dd:b6:fa:09:ab:21:6a:6c:fa:0b:e0:49:f9:f5: b6:fa:f8:4f:26:10:cf:ef:11:2a:16:c3:3a:cb:3f: 9f:da:d1:62:2b:2e:e4:5f:c3:b6:ab:29:29:54:b7: 9e:97:4e:59:e3:d1:b2:51:27:f9:02:2f:dd:33:95: a9:9d:14:63:c1:ea:6e:04:f4:5a:d2:51:d9:e7:ca: 31 :01:5a:86:09:94:9b:0d:1e:03:3b:cb:ae:51:df: 18 :ec:ec:86:a2:8f:34:6f:bd:80:c5:a6:af:be:c7: 0b:d1:1b:dd:e0:9c:7d:a3:4b:00:65:a3:a5:fe:1c: bc:8b:fa:02:9d:7a:0d:7e:52:d9:6d:44:1d:5f:d7: 2f:93:6b:f6:b8:e6:66:05:43:55:8d:9c:d6:ec:96: 18 :0b:71:c8:c4:ad:fe:08:18:4e:e6:33:e9:5d:c9: c7:83:0b:83:2f:c4:85:7d:40:1f:6f:76:41:9f:c9: 50 :15:7a:cc:57:94:df:ec:b5:5e:08:1f:95:09:ab: d6:b3:68:bb:df:39:6f:f1:ba:f3:e2:90:97:27:55: 15 :5a:03:82:48:f6:ca:02:f9:90:55:f4:11:cd:31: 34 :68:87:22:8b:6e:39:fc:53:ad:2e:26:9d:24:27: 31 :37:25:bd:b2:4b:fb:a7:57:9c:86:d6:d8:bf:4a: ad:eb Exponent: 65537 ( 0x10001 ) X509v3 extensions: X509v3 Subject Key Identifier: 9B:D8:7D:1B:C2:7F:44:21:CB:18:54:0D:0A:E2:B6:E4:78:F4:F3:E5 X509v3 Authority Key Identifier: keyid:9B:D8:7D:1B:C2:7F:44:21:CB:18:54:0D:0A:E2:B6:E4:78:F4:F3:E5 X509v3 Basic Constraints: critical CA:TRUE Signature Algorithm: sha256WithRSAEncryption 6e:ca:cf:a8:f8:0c:bf:59:d8:c9:85:48:bc:d8:3c:7a:a0:da: 18 :b7:23:b2:40:ce:df:44:a9:f1:e2:8d:0e:c1:e3:b7:00:48: 71 :81:01:b9:42:b8:61:87:9b:85:4e:ca:27:71:b5:d1:c4:46: cd:57:91:2a:04:54:b9:ab:f5:df:82:16:aa:80:11:27:7b:ba: ef:11:d3:88:b1:46:d3:43:32:fb:ac:04:3c:9d:f1:c6:53:74: 36 :bd:e2:cb:ff:d2:a6:56:fa:3c:97:f6:e9:7c:63:93:2a:46: d4:1c:bf:c1:86:4e:52:9d:f6:0a:b4:73:21:7b:52:93:0f:3b: d5:83:f1:f8:22:ec:6a:02:26:22:6f:d7:e0:0d:5f:83:94:40: 46 :f6:5e:af:bc:c1:9b:86:2c:aa:e8:95:59:f6:11:31:0a:5a: 1a:36:69:b8:b0:11:32:61:cb:16:3b:3d:7f:56:08:1a:5f:5b: 15 :e2:4e:2f:c8:46:4a:ce:02:12:90:af:74:b9:81:34:0c:dd: b7:0f:fc:88:49:d6:37:d0:25:72:4d:e1:b5:69:a0:79:b4:38: 02 :47:c1:30:cf:6b:14:12:e8:d8:b9:e2:c6:68:60:00:6a:e8: 14 :08:bd:7f:5c:df:d9:73:1a:51:f8:b9:4a:a6:0a:b8:6c:04: bf:34:94:49 -----BEGIN CERTIFICATE----- MIID1TCCAr2gAwIBAgIUQoXlM04a4tSe7Y8dJy/xECntMWcwDQYJKoZIhvcNAQEL BQAwejELMAkGA1UEBhMCVVMxETAPBgNVBAgMCFZpcmdpbmlhMRAwDgYDVQQHDAdI ZXJuZG9uMQwwCgYDVQQKDANJQk0xJjAkBgNVBAsMHUlCTSBXYXNoaW5ndG9uIFN5 c3RlbXMgQ2VudGVyMRAwDgYDVQQDDAd3c2NocHZzMB4XDTIwMDcyMzIxMzY0NFoX DTIxMDgyMjIxMzY0NFowejELMAkGA1UEBhMCVVMxETAPBgNVBAgMCFZpcmdpbmlh MRAwDgYDVQQHDAdIZXJuZG9uMQwwCgYDVQQKDANJQk0xJjAkBgNVBAsMHUlCTSBX YXNoaW5ndG9uIFN5c3RlbXMgQ2VudGVyMRAwDgYDVQQDDAd3c2NocHZzMIIBIjAN BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3bb6Cashamz6C+BJ+fW2+vhPJhDP 7xEqFsM6yz+f2tFiKy7kX8O2qykpVLeel05Z49GyUSf5Ai/dM5WpnRRjwepuBPRa 0lHZ58oxAVqGCZSbDR4DO8uuUd8Y7OyGoo80b72AxaavvscL0Rvd4Jx9o0sAZaOl /hy8i/oCnXoNflLZbUQdX9cvk2v2uOZmBUNVjZzW7JYYC3HIxK3+CBhO5jPpXcnH gwuDL8SFfUAfb3ZBn8lQFXrMV5Tf7LVeCB+VCavWs2i73zlv8brz4pCXJ1UVWgOC SPbKAvmQVfQRzTE0aIcii245/FOtLiadJCcxNyW9skv7p1echtbYv0qt6wIDAQAB o1MwUTAdBgNVHQ4EFgQUm9h9G8J/RCHLGFQNCuK25Hj08+UwHwYDVR0jBBgwFoAU m9h9G8J/RCHLGFQNCuK25Hj08+UwDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG9w0B AQsFAAOCAQEAbsrPqPgMv1nYyYVIvNg8eqDaGLcjskDO30Sp8eKNDsHjtwBIcYEB uUK4YYebhU7KJ3G10cRGzVeRKgRUuav134IWqoARJ3u67xHTiLFG00My+6wEPJ3x xlN0Nr3iy//Splb6PJf26XxjkypG1By/wYZOUp32CrRzIXtSkw871YPx+CLsagIm Im/X4A1fg5RARvZer7zBm4YsquiVWfYRMQpaGjZpuLARMmHLFjs9f1YIGl9bFeJO L8hGSs4CEpCvdLmBNAzdtw/8iEnWN9Alck3htWmgebQ4AkfBMM9rFBLo2Lnixmhg AGroFAi9f1zf2XMaUfi5SqYKuGwEvzSUSQ == -----END CERTIFICATE----- A few lines of the output above have been highlighted. Notice the highlighted line that says CA: TRUE . This attribute indicates that this certificate is acting as a certification authority and can issue other certificates. Notice the lines above it which have values for Subject Key Identifier and Authority Key Identifier . Subject Key Identifier is the identity of the holder of the certificate. Authority Key Identifier is the identity of the issuer of the certificate. You can see that the values for these are the same. This is known as a self-signed certificate . Certification authorities (CA) exist in a hierarchy- one CA can issue a certificate to another CA with the CA: TRUE attribute, and so forth. In our hosted trial we have this single, homegrown certification authority that we created, with its self-signed certificate that we created per the instructions in the Hyper Protect Virtual Servers documentation.","title":"Create a Certification Authority (CA) certificate and key"},{"location":"grep11/grep11-setup/#create-a-grep11-server-x509-certificate-for-tls-authentication","text":"Once we created a \"homegrown\" certification authority, we next created an X.509 certificate for our GREP11 server. This certificate was issued by our certification authority. The first step was to create another RSA private key that our GREP11 server will use: openssl genrsa -out server80-9876-19876-key.pem 2048 Note The value of the -out argument, server80-9876-19876-key.pem can be whatever you want it to be. I named it what I did for a reason. the 80 in server80 is for the last octet of my Hyper Protect Virtual Servers LPAR's IP adresss, 192.168.22.80, and I intend to use this certificate for two GREP11 servers, one listening on port 9876 on one of the LPAR's Crypto Express 7S domains, and the second server will listen on port 19876 on the LPAR's second Crypto Express 7S domain. Then, this private key was used as input to openssl in order to create a certificate signing request : openssl req -new -key server80-9876-19876-key.pem -out server80-9876-19876.csr The certificate signing request will be passed to our certification authority which will use the information to create an X.509 certificate. We used openssl for this, too: openssl x509 -sha256 -req -in server80-9876-19876.csr -CA ca.pem -CAkey ca.key -set_serial 8086 -extfile openssl.cnf -extensions server -days 365 -outform PEM -out server80-9876-19876.pem For more information about creating the openssl.cnf file, see OpenSSL configuration examples . The file name of the certificate that was created by the preceding command is the value of the -out argument, server80-9876-19876.pem . openssl allows us to list this certificate in human-friendly form: openssl x509 -in server80-9876-19876.pem -noout -text Example output Certificate: Data: Version: 3 (0x2) Serial Number: 8086 (0x1f96) Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, ST = Virginia, L = Herndon, O = IBM, OU = IBM Washington Systems Center, CN = wschpvs Validity Not Before: Jul 23 21:47:22 2020 GMT Not After : Jul 23 21:47:22 2021 GMT Subject: C = US, ST = Virginia, L = Herndon, O = IBM, OU = IBM Washington Systems Center, CN = 192.168.22.80 Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (2048 bit) Modulus: 00:b8:1a:5d:37:d6:c5:5b:2a:40:90:e5:e9:7f:c7: 19:e4:83:fd:ce:f7:1b:f7:37:09:c1:f6:1f:03:10: 78:70:52:27:66:1c:49:20:75:03:12:2f:7c:1b:ea: 7b:37:0e:95:46:08:41:c9:7a:b8:89:f6:74:7f:84: 14:aa:3f:91:94:78:df:8d:b0:47:9b:1f:2e:88:67: eb:13:71:a7:57:a8:c3:cd:fe:22:ea:05:35:42:6f: 33:f5:46:05:27:c1:16:06:8c:66:14:fc:44:d3:56: ae:8f:60:1b:df:72:02:a0:cb:89:bc:50:56:5f:aa: 97:57:03:7e:71:bc:71:7d:f3:9c:53:ae:12:0e:56: f0:46:45:e6:61:de:37:fa:40:b0:3b:fa:7e:a5:26: b0:06:67:49:b0:c1:c0:a1:35:5c:3d:c1:1b:d7:79: bf:c3:93:d3:e4:fa:72:06:ec:84:1f:0c:6a:d0:92: 33:f4:8a:22:bf:af:53:78:48:bd:3d:63:f5:78:d0: 08:bf:52:a1:ea:40:4e:74:9a:89:dc:7a:b0:dd:c7: e3:fe:35:58:91:65:c9:d2:00:d3:e9:fb:34:1e:39: 77:ac:2a:49:79:53:37:aa:59:16:ce:8c:18:d6:99: af:e7:8f:9b:dc:b7:33:7e:00:41:3a:73:c0:5e:d7: 92:63 Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Basic Constraints: CA:FALSE X509v3 Key Usage: Digital Signature, Key Encipherment, Data Encipherment X509v3 Extended Key Usage: TLS Web Server Authentication Netscape Cert Type: SSL Server X509v3 CRL Distribution Points: Full Name: URI:http://localhost/ca.crl X509v3 Subject Alternative Name: DNS:192.168.22.80:9876, DNS:192.168.22.80:19876, IP Address:192.168.22.80 Signature Algorithm: sha256WithRSAEncryption 8f:f2:7e:60:69:de:80:85:7b:9a:3e:c8:8a:c7:ee:ee:66:29: d7:bc:5b:54:0d:ae:50:7a:1a:9e:86:2e:ba:77:51:53:d3:c5: 64:e6:ca:1c:69:45:3c:db:1a:a8:cb:b4:7b:f7:1d:16:59:cb: 3c:89:80:1b:89:a3:cf:f3:6d:08:40:83:6f:f5:f5:f3:87:1f: 3c:0a:42:e3:c6:7c:56:be:5c:50:15:f5:2b:e7:cb:33:03:43: 30:e9:30:81:91:66:d7:34:70:ac:7b:09:bf:b0:32:41:09:7d: 0d:7d:ee:6a:19:4b:0e:18:a8:8d:0c:d7:3b:c7:c2:28:7a:c3: c8:4a:34:cb:2a:90:2a:70:af:03:04:3c:93:6b:ee:3f:c0:47: 45:10:59:67:3d:36:50:29:30:38:b2:f7:ff:a7:06:b3:b5:3b: 66:64:21:87:ef:ab:0e:e7:e7:4c:4d:06:5a:3b:4c:1e:0f:d4: de:08:6c:cc:24:6f:c1:1b:03:3d:27:4c:62:ea:a6:79:ab:f3: a7:13:8a:26:e3:2a:e7:c2:bf:28:f4:de:58:6d:e2:d7:ed:e6: bf:a7:b4:eb:61:c6:89:0c:df:fc:41:6d:b0:9a:ae:64:59:a8: 4e:86:5d:11:7e:1d:f6:b1:df:98:02:97:d8:12:63:dc:bf:3a: 10:5e:46:6c","title":"Create a GREP11 server X.509 certificate for TLS authentication"},{"location":"grep11/grep11-setup/#create-an-x509-certificate-for-your-client-application-for-tls-authentication","text":"The client applications need a certificate that is issued by the same certification authority that the GREP11 server uses. The process is similar- create a private key, pass that as input for the creation of a certificte signing request, and then pass that to the certification authority in order to receive a certificate. We used these commands: openssl genrsa -out client-key.pem 2048 openssl req -new -key client-key.pem -out client.csr openssl x509 -req -days 1000 -in client.csr -CA atgz-hpvs-ca.pem -CAcreateserial -CAkey atgz-hpvs-ca.key -out client.pem Here is a listing of the client certificate that you will be using in the hosted trial. It will be configured properly for you so that your client program can present it to the GREP11 server: openssl x509 -in client.pem -noout -text Example Output Certificate: Data: Version: 1 (0x0) Serial Number: 4f:07:1f:6e:5e:09:33:8d:6f:39:52:01:36:06:3e:bb:28:50:c9:41 Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, ST = Virginia, L = Herndon, O = IBM, OU = IBM Washington Systems Center, CN = wschpvs Validity Not Before: Jul 23 21:52:13 2020 GMT Not After : Apr 19 21:52:13 2023 GMT Subject: C = US, ST = Virginia, L = Herndon, O = IBM, OU = IBM Washington Systems Center, CN = GREP11 Lab Students Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (2048 bit) Modulus: 00:c4:ab:d2:80:e2:38:b8:9d:6b:7f:f0:ae:09:72: c4:64:57:1a:32:f9:eb:b5:31:e9:bf:81:0b:c1:d7: 01:b6:6d:c7:7c:26:d3:49:6b:3b:fd:54:11:cc:5e: 7e:2f:be:59:54:4d:a4:c4:5c:08:87:1f:2b:0f:bc: cf:91:cd:21:a9:8e:bd:34:87:bb:3c:dd:e7:64:e4: e2:5e:30:d1:27:74:d4:7e:9f:3b:2f:40:68:3d:d9: 7d:d7:ff:e8:b6:ad:3a:ab:ca:d9:74:51:fa:12:59: a3:e1:2a:13:e2:20:34:01:6a:a3:6a:7c:36:be:81: 37:2a:cb:3b:85:a0:59:f1:60:ca:be:de:ce:d0:0d: ab:31:e4:09:09:31:39:06:cb:8d:48:73:56:ec:4f: 93:cd:85:d9:59:89:9a:f3:d2:e5:d6:de:8e:e5:a5: 4d:20:89:07:e0:1b:bd:a0:09:6f:94:92:e7:77:f6: 76:f3:da:16:01:7c:80:76:cf:29:11:39:bc:6d:71: 4a:bd:08:ca:29:da:d0:16:22:f5:f0:4d:c2:83:e4: 8c:72:9b:b4:17:bf:48:09:29:6b:bd:4d:35:3b:44: 9f:2f:75:7f:e2:a6:08:e7:ae:bb:4d:77:10:83:e6: cd:09:21:18:68:b2:ad:0a:f0:74:e5:47:ad:41:e5: 41:6d Exponent: 65537 (0x10001) Signature Algorithm: sha256WithRSAEncryption 3f:ce:22:e4:ba:6b:1d:68:aa:b4:07:35:22:0c:d7:55:e7:dc: 4f:21:ca:17:ca:14:cd:b9:7e:ad:f1:93:84:9f:e4:96:84:10: 39:d7:36:1f:66:2d:15:1b:40:96:a6:79:5e:e4:a2:00:c8:fa: fe:1a:42:9f:37:45:c4:c7:d9:21:c7:04:82:37:21:a0:41:ca: 92:b7:b8:15:db:62:55:c8:55:02:d6:d7:3a:fb:1d:96:33:54: c8:f2:fd:d7:65:39:7c:12:13:e6:b5:91:fd:0e:68:21:30:41: 82:f0:c0:74:a5:12:18:5e:e4:4b:83:1a:7f:a3:cc:f7:0a:aa: 8f:f0:4e:0a:01:45:64:98:10:9a:f1:41:48:46:ec:df:3b:db: c5:2f:bb:ec:f7:dc:77:f0:98:e2:99:f4:20:fc:ff:45:24:af: 8a:56:e7:60:2f:aa:cc:af:8a:ae:a8:1f:33:a0:8e:5e:3e:46: 69:10:f0:b9:6c:02:6d:b3:4e:ef:cd:ac:06:86:67:9b:c9:44: 73:00:37:61:06:df:32:ce:e5:c3:28:04:8f:c8:e4:81:ec:16: 2c:dd:63:37:bd:07:ab:fc:f9:ac:55:e2:4a:b0:9b:5e:5d:f5: f1:89:90:0b:59:50:da:21:cb:db:96:c7:6d:fa:54:e4:f2:74: 86:e2:71:6e Note For the hosted trial, you will use a copy of the same client certificate. In most production use cases each client would use their own certificate which uniquely identifies them.","title":"Create an X.509 certificate for your client application for TLS authentication"},{"location":"grep11/grep11-setup/#list-crypto-domains-on-your-hyper-protect-virtual-servers-lpar","text":"You can list your available domains with the Hyper Protect Virtual Server CLI: hpvs crypto list Example output hpvs crypto list +---------------+--------+ | CRYPTO.DOMAIN | STATUS | +---------------+--------+ | 08.0016 | online | | 0a.0016 | online | +---------------+--------+ The values shown in the CRYPTO.DOMAIN column are in hexadecimal. So, translating to decimal, our LPAR is using Crypto Express 7S cards 8 and 10, with domain 22 in both cards assigned to our LPAR. (A Crypto Express 7S card can have up to 85 domains- think of each domain as a \"virtual\" Crypto Express 7S card).","title":"List Crypto Domains on your Hyper Protect Virtual Servers LPAR"},{"location":"grep11/grep11-setup/#create-yaml-or-json-configuration-files-for-grep11-server","text":"There are two alternative ways to start your GREP11 server: Using hpvs deploy with a YAML file as input Using hpvs vs create with a JSON file as input I will show both the YAML and JSON files first, then I will show both methods of starting the GREP11 server, and then I'll explain the difference between the two start methods.","title":"Create YAML or JSON configuration files for GREP11 server"},{"location":"grep11/grep11-setup/#yaml-file-for-grep11-server-configuration","text":"This is the YAML file for a GREP11 server that will listen for client connections on port 9876, and will use domain 22 (hex 16) of Crypto Express 7S card 08: GREP11 server YAML configuration file version: v1 # # use this file with the 'hpvs deploy' command, e.g., # # hpvs deploy --config $HOME/hpvs/config/grep11/vs_grep11.yml # type: virtualserver virtualservers: - name: grep11-08-0016-9876 host: wsclpar80 repoid: hpcsKpGrep11_runq imagetag: 1 .2.3 imagefile: hpcsKpGrep11_runq.tar.gz crypto: crypto_matrix: - 08 .0016 environment: - key: EP11SERVER_EP11CRYPTO_DOMAIN value: \"08.0016\" # - key: EP11SERVER_EP11CRYPTO_CONNECTION_TLS_CERTFILEBYTES value: \"@/home/hyper-protect-lab/hpvs/config/grep11/keys/server80-9876-19876.pem\" - key: EP11SERVER_EP11CRYPTO_CONNECTION_TLS_KEYFILEBYTES value: \"@/home/hyper-protect-lab/hpvs/config/grep11/keys/server80-9876-19876-key.pem\" - key: EP11SERVER_EP11CRYPTO_CONNECTION_TLS_CACERTBYTES value: \"@/home/hyper-protect-lab/hpvs/config/grep11/keys/ca.pem\" - key: EP11SERVER_EP11CRYPTO_CONNECTION_TLS_ENABLED value: \"true\" - key: EP11SERVER_EP11CRYPTO_CONNECTION_TLS_MUTUAL value: \"true\" - key: TLS_GRPC_CERTS_DOMAIN_CRT value: \"\\\\n\" - key: TLS_GRPC_CERTS_DOMAIN_KEY value: \"\\\\n\" - key: TLS_GRPC_CERTS_ROOTCA_CRT value: \"\\\\n\" ports: - hostport: 9876 protocol: tcp containerport: 9876","title":"YAML file for GREP11 server configuration"},{"location":"grep11/grep11-setup/#json-file-for-grep11-server-configuration","text":"This is a JSON file for a GREP11 server that will listen for client connections on port 9876, and will use domain 22 (hex 16) of Crypto Express 7S card 08: GREP11 server JSON configuration file { \"EP11SERVER_EP11CRYPTO_DOMAIN\":\"08.0016\", \"EP11SERVER_EP11CRYPTO_CONNECTION_TLS_CERTFILEBYTES\":\"@/home/hyper-protect-lab/hpvs/config/grep11/keys/server80-9876-19876.pem\", \"EP11SERVER_EP11CRYPTO_CONNECTION_TLS_KEYFILEBYTES\":\"@/home/hyper-protect-lab/hpvs/config/grep11/keys/server80-9876-19876-key.pem\", \"EP11SERVER_EP11CRYPTO_CONNECTION_TLS_CACERTBYTES\":\"@/home/hyper-protect-lab/hpvs/config/grep11/keys/ca.pem\", \"EP11SERVER_EP11CRYPTO_CONNECTION_TLS_ENABLED\":true, \"EP11SERVER_EP11CRYPTO_CONNECTION_TLS_MUTUAL\":true, \"TLS_GRPC_CERTS_DOMAIN_CRT\":\"\\\\n\", \"TLS_GRPC_CERTS_DOMAIN_KEY\":\"\\\\n\", \"TLS_GRPC_CERTS_ROOTCA_CRT\":\"\\\\n\" }","title":"JSON file for GREP11 server configuration"},{"location":"grep11/grep11-setup/#start-the-grep11-server","text":"If you looked carefully at the JSON file and the YAML file in the previous section, you may have noticed that the YAML file contains more information than the JSON file contains. As a result, the syntax is simpler for the command that uses the YAML file. The command that uses the JSON file uses command line arguments to provide some of the information that the YAML file contained. Compare the two methods: Command to start the GREP11 server with the YAML file hpvs deploy --config $HOME/hpvs/config/grep11/vs_grep11.yml Command to start the GREP11 server with the JSON file hpvs vs create --name grep11 --repo hpcsKpGrep11_runq --tag 1.2.3 --crypto_matrix=08.0016 --cpu 2 --ram 2048 --envjsonpath ${HOME}/hpvs/config/grep11/grep11_env_08.0016.json --ports \"{containerport = 9876, protocol = tcp, hostport = 9876}\" Difference between the two commands The hpvs deploy method simpler than the long syntax of the hpvs vs create command. But the hpvs vs create command has a benefit- the hpvs deploy command uploads the GREP11 server Docker image from your workstation where you run the CLI to the Hyper Protect Virtual Servers LPAR, every single time. This Docker image only needs to be sent up once. The hpvs vs create command is smart enough to have this figured out and not do the unnecessary upload of the Docker image the second and subsequent times you run it. Important Starting now, as you navigate to the next section of the hosted trial, you should enter all the commands shown in the lab. Only the commands in this section were for reference. The GREP11 server is a feature provided by Hyper Protect Virtual Servers. You are not required to use it. If you do not use this feature, you do not have to define Crypto Express domains to the LPAR. You may wish to for other purposes, and you can use the other modes offered by Crypto Express cards for those purposes, but you must use EP11 mode for usage by the GREP11 server. \u21a9","title":"Start the GREP11 server"},{"location":"grep11/lab-exercise1/","text":"Exercise 1 - List Mechanisms \u00b6 Explanation of Mechanisms \u00b6 Mechanisms is the PKCS #11 standard's fancy word for algorithms . In the introduction of the PKCS#11 Cryptographic Token Interface Base Specification 2.40 document, there is this statement: Details of cryptographic mechanisms (algorithms) may be found in the associated PKCS#11 Mechanisms documents. And then in the PKCS#11 Cryptographic Token Interface Current Mechanisms Specification Version 2.40 it says A mechanism specifies precisely how a certain cryptographic process is to be performed. This exercise will list the mechanisms supported by the Crypto Express card in EP11 mode. The program that you will invoke in this exercise issues a GetMechanismList() function call to the GREP11 server, and then it will iterate through the list returned, calling GetMechanismInfo() against each mechanism to obtain more info about it. Run the program and then a brief discussion of the results will follow: You may wish to view the source code used by the lab exercises while running them. It is handy to expand the Outline view in the left pane of Visual Studio Code which will show the various function and type definitions of the source code you have highlighted in the main portion of the Visual Studio Code window. The Outline view may not be necessary for smaller source code files but it comes in handy for some of the larger source code files. The screen snippet below shows where the Outline view is: Change to the lab directory in your terminal: cd ../lab In the prior section, the go test command built the executable file it needed transparently to us. For our lab exercises, we need to build the executable binary. We will use a single executable for all of the exercises, and invoke the various exercises through command line arguments. Build the executable now with this command: go build Note The absence of any messages is your indication of success! The go build command should have created an excutable file that shares the name of the directory in which you are working- lab . List that file and you should see it has a recent date and timestamp. ls -l lab Example output -rwxr-xr-x 1 hyper-protect-lab hyper-protect-lab 17545825 Jul 8 06 :26 lab Tip You may be doing this lab in a virtual machine whose clock is set for a time zone different from where you are. You can always issue the date command to see what time your virtual machine thinks it is at the moment. Run the first exercise by passing the appropriate argument, shown below, to the lab program: ./lab --ex1 Example output Got mechanism list of length 92: Mechanism 0 : CKM_RSA_PKCS MinKeySize:512 MaxKeySize:4096 Flags:404224 Mechanism 1 : CKM_RSA_PKCS_OAEP MinKeySize:512 MaxKeySize:4096 Flags:393984 Mechanism 2 : CKM_RSA_PKCS_KEY_PAIR_GEN MinKeySize:512 MaxKeySize:4096 Flags:65536 Mechanism 3 : CKM_RSA_X9_31_KEY_PAIR_GEN MinKeySize:512 MaxKeySize:4096 Flags:65536 Mechanism 4 : CKM_RSA_PKCS_PSS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 5 : CKM_SHA1_RSA_X9_31 MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 6 : CKM_SHA1_RSA_PKCS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 7 : CKM_SHA1_RSA_PKCS_PSS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 8 : CKM_SHA256_RSA_PKCS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 9 : CKM_SHA256_RSA_PKCS_PSS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 10 : CKM_SHA224_RSA_PKCS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 11 : CKM_SHA224_RSA_PKCS_PSS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 12 : CKM_SHA384_RSA_PKCS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 13 : CKM_SHA384_RSA_PKCS_PSS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 14 : CKM_SHA512_RSA_PKCS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 15 : CKM_SHA512_RSA_PKCS_PSS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 16 : CKM_AES_KEY_GEN MinKeySize:16 MaxKeySize:32 Flags:32768 Mechanism 17 : CKM_AES_ECB MinKeySize:16 MaxKeySize:32 Flags:768 Mechanism 18 : CKM_AES_CBC MinKeySize:16 MaxKeySize:32 Flags:393984 Mechanism 19 : CKM_AES_CBC_PAD MinKeySize:16 MaxKeySize:32 Flags:393984 Mechanism 20 : CKM_DES2_KEY_GEN MinKeySize:16 MaxKeySize:16 Flags:32768 Mechanism 21 : CKM_DES3_KEY_GEN MinKeySize:24 MaxKeySize:24 Flags:32768 Mechanism 22 : CKM_DES3_ECB MinKeySize:16 MaxKeySize:24 Flags:768 Mechanism 23 : CKM_DES3_CBC MinKeySize:16 MaxKeySize:24 Flags:393984 Mechanism 24 : CKM_DES3_CBC_PAD MinKeySize:16 MaxKeySize:24 Flags:393984 Mechanism 25 : CKM_GENERIC_SECRET_KEY_GEN MinKeySize:8 MaxKeySize:256 Flags:557056 Mechanism 26 : CKM_SHA256 Flags:1024 Mechanism 27 : CKM_SHA256_KEY_DERIVATION Flags:524288 Mechanism 28 : CKM_SHA256_HMAC MinKeySize:16 MaxKeySize:32 Flags:10240 Mechanism 29 : CKM_SHA224 Flags:1024 Mechanism 30 : CKM_SHA224_KEY_DERIVATION Flags:524288 Mechanism 31 : CKM_SHA224_HMAC MinKeySize:14 MaxKeySize:32 Flags:10240 Mechanism 32 : CKM_SHA_1 Flags:1024 Mechanism 33 : CKM_SHA1_KEY_DERIVATION Flags:524288 Mechanism 34 : CKM_SHA_1_HMAC MinKeySize:10 MaxKeySize:32 Flags:10240 Mechanism 35 : CKM_SHA384 Flags:1024 Mechanism 36 : CKM_SHA384_KEY_DERIVATION Flags:524288 Mechanism 37 : CKM_SHA384_HMAC MinKeySize:24 MaxKeySize:32 Flags:10240 Mechanism 38 : CKM_SHA512 Flags:1024 Mechanism 39 : CKM_SHA512_KEY_DERIVATION Flags:524288 Mechanism 40 : CKM_SHA512_HMAC MinKeySize:32 MaxKeySize:32 Flags:10240 Mechanism 41 : CKM_SHA512_256 Flags:1024 Mechanism 42 : CKM_IBM_SHA512_256 Flags:1024 Mechanism 43 : CKM_SHA512_256_HMAC MinKeySize:16 MaxKeySize:32 Flags:10240 Mechanism 44 : CKM_IBM_SHA512_256_HMAC MinKeySize:16 MaxKeySize:32 Flags:10240 Mechanism 45 : CKM_SHA512_224 Flags:1024 Mechanism 46 : CKM_IBM_SHA512_224 Flags:1024 Mechanism 47 : CKM_SHA512_224_HMAC MinKeySize:14 MaxKeySize:32 Flags:10240 Mechanism 48 : CKM_IBM_SHA512_224_HMAC MinKeySize:14 MaxKeySize:32 Flags:10240 Mechanism 49 : CKM_EC_KEY_PAIR_GEN MinKeySize:192 MaxKeySize:521 Flags:26279936 Mechanism 50 : CKM_ECDSA MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 51 : CKM_ECDSA_SHA1 MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 52 : CKM_ECDH1_DERIVE MinKeySize:192 MaxKeySize:521 Flags:18350080 Mechanism 53 : CKM_IBM_ECDH1_DERIVE_RAW MinKeySize:192 MaxKeySize:521 Flags:18350080 Mechanism 54 : CKM_IBM_EC_MULTIPLY MinKeySize:192 MaxKeySize:521 Flags:256 Mechanism 55 : CKM_DSA_PARAMETER_GEN MinKeySize:1024 MaxKeySize:3072 Flags:32768 Mechanism 56 : CKM_DSA_KEY_PAIR_GEN MinKeySize:1024 MaxKeySize:3072 Flags:65536 Mechanism 57 : CKM_DSA MinKeySize:1024 MaxKeySize:3072 Flags:10240 Mechanism 58 : CKM_DSA_SHA1 MinKeySize:1024 MaxKeySize:3072 Flags:10240 Mechanism 59 : CKM_DH_PKCS_PARAMETER_GEN MinKeySize:1024 MaxKeySize:3072 Flags:32768 Mechanism 60 : CKM_DH_PKCS_KEY_PAIR_GEN MinKeySize:1024 MaxKeySize:3072 Flags:65536 Mechanism 61 : CKM_DH_PKCS_DERIVE MinKeySize:1024 MaxKeySize:3072 Flags:524288 Mechanism 62 : CKM_IBM_DH_PKCS_DERIVE_RAW MinKeySize:1024 MaxKeySize:3072 Flags:524288 Mechanism 63 : Mechanism(0x80010023) MinKeySize:256 MaxKeySize:256 Flags:75776 Mechanism 64 : CKM_RSA_X9_31 MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 65 : CKM_PBE_SHA1_DES3_EDE_CBC MinKeySize:24 MaxKeySize:24 Flags:32768 Mechanism 66 : CKM_IBM_SHA3_224 Flags:1024 Mechanism 67 : CKM_IBM_SHA3_256 Flags:1024 Mechanism 68 : CKM_IBM_SHA3_384 Flags:1024 Mechanism 69 : CKM_IBM_SHA3_512 Flags:1024 Mechanism 70 : Mechanism(0x80010025) MinKeySize:14 MaxKeySize:32 Flags:10240 Mechanism 71 : Mechanism(0x80010026) MinKeySize:16 MaxKeySize:32 Flags:10240 Mechanism 72 : Mechanism(0x80010027) MinKeySize:24 MaxKeySize:32 Flags:10240 Mechanism 73 : Mechanism(0x80010028) MinKeySize:32 MaxKeySize:32 Flags:10240 Mechanism 74 : CKM_IBM_ATTRIBUTEBOUND_WRAP MaxKeySize:4096 Flags:393216 Mechanism 75 : Mechanism(0x1043) MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 76 : CKM_IBM_ECDSA_SHA224 MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 77 : Mechanism(0x1044) MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 78 : CKM_IBM_ECDSA_SHA256 MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 79 : Mechanism(0x1045) MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 80 : CKM_IBM_ECDSA_SHA384 MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 81 : Mechanism(0x1046) MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 82 : CKM_IBM_ECDSA_SHA512 MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 83 : CKM_IBM_EC_C25519 MinKeySize:256 MaxKeySize:256 Flags:18350080 Mechanism 84 : CKM_IBM_EC_C448 MinKeySize:448 MaxKeySize:448 Flags:18350080 Mechanism 85 : CKM_IBM_EDDSA_SHA512 MinKeySize:256 MaxKeySize:256 Flags:17836032 Mechanism 86 : CKM_IBM_ED448_SHA3 MinKeySize:448 MaxKeySize:448 Flags:17836032 Mechanism 87 : CKM_IBM_EAC Flags:524288 Mechanism 88 : CKM_IBM_RETAINKEY MaxKeySize:256 Flags:131072 Mechanism 89 : CKM_IBM_CMAC MinKeySize:16 MaxKeySize:32 Flags:10240 Mechanism 90 : CKM_AES_CMAC MinKeySize:16 MaxKeySize:32 Flags:10240 Mechanism 91 : CKM_DES3_CMAC MinKeySize:16 MaxKeySize:24 Flags:10240 Explanation of exercise output \u00b6 Near the top of the output, you see the line: Got mechanism list of length 92: This indicates there were 92 mechanisms returned by the call to GetMechanismList() . Then, for each mechanism, two lines of output are created, one with the mechanism name, which usually start with CKM_ . The mechanism number has no significance, this is just an index number assigned by our lab program, starting at 0 and incremented by the program as it iterates over the list. The information returned by GetMechanismInfo() includes the minimum key size and maximum key size for the mechanism, if applicable, and flags that are associated with the mechanism. The numbers shown are in decimal, and the key sizes shown are in bytes. Tip If you are doing this lab at your leisure on your own system, you could look in golang/ep11/header_consts.go and find the flags within lines 596 through 649 of that file. You'd have to convert the decimal value shown to hexadecimal. If you are taking this lab as part of a virtual event, do not take the time now to deconstruct these flags- you can always do that later since this lab is publicly available. Observe that the large majority of mechanisms in the list have a name starting with CKM_ , while a handful, such as item 77, 79, 81, and others, do not. It appears that if the mechanism is not listed in the golang/ep11/header_consts.go file, within lines 205 to 594, then it will not have a name starting with CKM_ . Note that the PKCS #11 specification does not mandate that an implementation support all defined mechanisms. Even within the subset of the 92 mechanisms that are supported by IBM's EP11 library, some are for algorithms that are considered rather outdated, and, in some cases, downright insecure. For example, the SHA-1 cryptographic hash algorithm is considered insecure these days, so any mechanims in the list that have SHA1 or SHA_1 in their name (and there are some) should be avoided. Let's move on to Exercise 2.","title":"Exercise 1 (List PKCS Mechanisms)"},{"location":"grep11/lab-exercise1/#exercise-1-list-mechanisms","text":"","title":"Exercise 1 - List Mechanisms"},{"location":"grep11/lab-exercise1/#explanation-of-mechanisms","text":"Mechanisms is the PKCS #11 standard's fancy word for algorithms . In the introduction of the PKCS#11 Cryptographic Token Interface Base Specification 2.40 document, there is this statement: Details of cryptographic mechanisms (algorithms) may be found in the associated PKCS#11 Mechanisms documents. And then in the PKCS#11 Cryptographic Token Interface Current Mechanisms Specification Version 2.40 it says A mechanism specifies precisely how a certain cryptographic process is to be performed. This exercise will list the mechanisms supported by the Crypto Express card in EP11 mode. The program that you will invoke in this exercise issues a GetMechanismList() function call to the GREP11 server, and then it will iterate through the list returned, calling GetMechanismInfo() against each mechanism to obtain more info about it. Run the program and then a brief discussion of the results will follow: You may wish to view the source code used by the lab exercises while running them. It is handy to expand the Outline view in the left pane of Visual Studio Code which will show the various function and type definitions of the source code you have highlighted in the main portion of the Visual Studio Code window. The Outline view may not be necessary for smaller source code files but it comes in handy for some of the larger source code files. The screen snippet below shows where the Outline view is: Change to the lab directory in your terminal: cd ../lab In the prior section, the go test command built the executable file it needed transparently to us. For our lab exercises, we need to build the executable binary. We will use a single executable for all of the exercises, and invoke the various exercises through command line arguments. Build the executable now with this command: go build Note The absence of any messages is your indication of success! The go build command should have created an excutable file that shares the name of the directory in which you are working- lab . List that file and you should see it has a recent date and timestamp. ls -l lab Example output -rwxr-xr-x 1 hyper-protect-lab hyper-protect-lab 17545825 Jul 8 06 :26 lab Tip You may be doing this lab in a virtual machine whose clock is set for a time zone different from where you are. You can always issue the date command to see what time your virtual machine thinks it is at the moment. Run the first exercise by passing the appropriate argument, shown below, to the lab program: ./lab --ex1 Example output Got mechanism list of length 92: Mechanism 0 : CKM_RSA_PKCS MinKeySize:512 MaxKeySize:4096 Flags:404224 Mechanism 1 : CKM_RSA_PKCS_OAEP MinKeySize:512 MaxKeySize:4096 Flags:393984 Mechanism 2 : CKM_RSA_PKCS_KEY_PAIR_GEN MinKeySize:512 MaxKeySize:4096 Flags:65536 Mechanism 3 : CKM_RSA_X9_31_KEY_PAIR_GEN MinKeySize:512 MaxKeySize:4096 Flags:65536 Mechanism 4 : CKM_RSA_PKCS_PSS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 5 : CKM_SHA1_RSA_X9_31 MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 6 : CKM_SHA1_RSA_PKCS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 7 : CKM_SHA1_RSA_PKCS_PSS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 8 : CKM_SHA256_RSA_PKCS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 9 : CKM_SHA256_RSA_PKCS_PSS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 10 : CKM_SHA224_RSA_PKCS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 11 : CKM_SHA224_RSA_PKCS_PSS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 12 : CKM_SHA384_RSA_PKCS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 13 : CKM_SHA384_RSA_PKCS_PSS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 14 : CKM_SHA512_RSA_PKCS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 15 : CKM_SHA512_RSA_PKCS_PSS MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 16 : CKM_AES_KEY_GEN MinKeySize:16 MaxKeySize:32 Flags:32768 Mechanism 17 : CKM_AES_ECB MinKeySize:16 MaxKeySize:32 Flags:768 Mechanism 18 : CKM_AES_CBC MinKeySize:16 MaxKeySize:32 Flags:393984 Mechanism 19 : CKM_AES_CBC_PAD MinKeySize:16 MaxKeySize:32 Flags:393984 Mechanism 20 : CKM_DES2_KEY_GEN MinKeySize:16 MaxKeySize:16 Flags:32768 Mechanism 21 : CKM_DES3_KEY_GEN MinKeySize:24 MaxKeySize:24 Flags:32768 Mechanism 22 : CKM_DES3_ECB MinKeySize:16 MaxKeySize:24 Flags:768 Mechanism 23 : CKM_DES3_CBC MinKeySize:16 MaxKeySize:24 Flags:393984 Mechanism 24 : CKM_DES3_CBC_PAD MinKeySize:16 MaxKeySize:24 Flags:393984 Mechanism 25 : CKM_GENERIC_SECRET_KEY_GEN MinKeySize:8 MaxKeySize:256 Flags:557056 Mechanism 26 : CKM_SHA256 Flags:1024 Mechanism 27 : CKM_SHA256_KEY_DERIVATION Flags:524288 Mechanism 28 : CKM_SHA256_HMAC MinKeySize:16 MaxKeySize:32 Flags:10240 Mechanism 29 : CKM_SHA224 Flags:1024 Mechanism 30 : CKM_SHA224_KEY_DERIVATION Flags:524288 Mechanism 31 : CKM_SHA224_HMAC MinKeySize:14 MaxKeySize:32 Flags:10240 Mechanism 32 : CKM_SHA_1 Flags:1024 Mechanism 33 : CKM_SHA1_KEY_DERIVATION Flags:524288 Mechanism 34 : CKM_SHA_1_HMAC MinKeySize:10 MaxKeySize:32 Flags:10240 Mechanism 35 : CKM_SHA384 Flags:1024 Mechanism 36 : CKM_SHA384_KEY_DERIVATION Flags:524288 Mechanism 37 : CKM_SHA384_HMAC MinKeySize:24 MaxKeySize:32 Flags:10240 Mechanism 38 : CKM_SHA512 Flags:1024 Mechanism 39 : CKM_SHA512_KEY_DERIVATION Flags:524288 Mechanism 40 : CKM_SHA512_HMAC MinKeySize:32 MaxKeySize:32 Flags:10240 Mechanism 41 : CKM_SHA512_256 Flags:1024 Mechanism 42 : CKM_IBM_SHA512_256 Flags:1024 Mechanism 43 : CKM_SHA512_256_HMAC MinKeySize:16 MaxKeySize:32 Flags:10240 Mechanism 44 : CKM_IBM_SHA512_256_HMAC MinKeySize:16 MaxKeySize:32 Flags:10240 Mechanism 45 : CKM_SHA512_224 Flags:1024 Mechanism 46 : CKM_IBM_SHA512_224 Flags:1024 Mechanism 47 : CKM_SHA512_224_HMAC MinKeySize:14 MaxKeySize:32 Flags:10240 Mechanism 48 : CKM_IBM_SHA512_224_HMAC MinKeySize:14 MaxKeySize:32 Flags:10240 Mechanism 49 : CKM_EC_KEY_PAIR_GEN MinKeySize:192 MaxKeySize:521 Flags:26279936 Mechanism 50 : CKM_ECDSA MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 51 : CKM_ECDSA_SHA1 MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 52 : CKM_ECDH1_DERIVE MinKeySize:192 MaxKeySize:521 Flags:18350080 Mechanism 53 : CKM_IBM_ECDH1_DERIVE_RAW MinKeySize:192 MaxKeySize:521 Flags:18350080 Mechanism 54 : CKM_IBM_EC_MULTIPLY MinKeySize:192 MaxKeySize:521 Flags:256 Mechanism 55 : CKM_DSA_PARAMETER_GEN MinKeySize:1024 MaxKeySize:3072 Flags:32768 Mechanism 56 : CKM_DSA_KEY_PAIR_GEN MinKeySize:1024 MaxKeySize:3072 Flags:65536 Mechanism 57 : CKM_DSA MinKeySize:1024 MaxKeySize:3072 Flags:10240 Mechanism 58 : CKM_DSA_SHA1 MinKeySize:1024 MaxKeySize:3072 Flags:10240 Mechanism 59 : CKM_DH_PKCS_PARAMETER_GEN MinKeySize:1024 MaxKeySize:3072 Flags:32768 Mechanism 60 : CKM_DH_PKCS_KEY_PAIR_GEN MinKeySize:1024 MaxKeySize:3072 Flags:65536 Mechanism 61 : CKM_DH_PKCS_DERIVE MinKeySize:1024 MaxKeySize:3072 Flags:524288 Mechanism 62 : CKM_IBM_DH_PKCS_DERIVE_RAW MinKeySize:1024 MaxKeySize:3072 Flags:524288 Mechanism 63 : Mechanism(0x80010023) MinKeySize:256 MaxKeySize:256 Flags:75776 Mechanism 64 : CKM_RSA_X9_31 MinKeySize:512 MaxKeySize:4096 Flags:10240 Mechanism 65 : CKM_PBE_SHA1_DES3_EDE_CBC MinKeySize:24 MaxKeySize:24 Flags:32768 Mechanism 66 : CKM_IBM_SHA3_224 Flags:1024 Mechanism 67 : CKM_IBM_SHA3_256 Flags:1024 Mechanism 68 : CKM_IBM_SHA3_384 Flags:1024 Mechanism 69 : CKM_IBM_SHA3_512 Flags:1024 Mechanism 70 : Mechanism(0x80010025) MinKeySize:14 MaxKeySize:32 Flags:10240 Mechanism 71 : Mechanism(0x80010026) MinKeySize:16 MaxKeySize:32 Flags:10240 Mechanism 72 : Mechanism(0x80010027) MinKeySize:24 MaxKeySize:32 Flags:10240 Mechanism 73 : Mechanism(0x80010028) MinKeySize:32 MaxKeySize:32 Flags:10240 Mechanism 74 : CKM_IBM_ATTRIBUTEBOUND_WRAP MaxKeySize:4096 Flags:393216 Mechanism 75 : Mechanism(0x1043) MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 76 : CKM_IBM_ECDSA_SHA224 MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 77 : Mechanism(0x1044) MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 78 : CKM_IBM_ECDSA_SHA256 MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 79 : Mechanism(0x1045) MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 80 : CKM_IBM_ECDSA_SHA384 MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 81 : Mechanism(0x1046) MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 82 : CKM_IBM_ECDSA_SHA512 MinKeySize:192 MaxKeySize:521 Flags:26224640 Mechanism 83 : CKM_IBM_EC_C25519 MinKeySize:256 MaxKeySize:256 Flags:18350080 Mechanism 84 : CKM_IBM_EC_C448 MinKeySize:448 MaxKeySize:448 Flags:18350080 Mechanism 85 : CKM_IBM_EDDSA_SHA512 MinKeySize:256 MaxKeySize:256 Flags:17836032 Mechanism 86 : CKM_IBM_ED448_SHA3 MinKeySize:448 MaxKeySize:448 Flags:17836032 Mechanism 87 : CKM_IBM_EAC Flags:524288 Mechanism 88 : CKM_IBM_RETAINKEY MaxKeySize:256 Flags:131072 Mechanism 89 : CKM_IBM_CMAC MinKeySize:16 MaxKeySize:32 Flags:10240 Mechanism 90 : CKM_AES_CMAC MinKeySize:16 MaxKeySize:32 Flags:10240 Mechanism 91 : CKM_DES3_CMAC MinKeySize:16 MaxKeySize:24 Flags:10240","title":"Explanation of Mechanisms"},{"location":"grep11/lab-exercise1/#explanation-of-exercise-output","text":"Near the top of the output, you see the line: Got mechanism list of length 92: This indicates there were 92 mechanisms returned by the call to GetMechanismList() . Then, for each mechanism, two lines of output are created, one with the mechanism name, which usually start with CKM_ . The mechanism number has no significance, this is just an index number assigned by our lab program, starting at 0 and incremented by the program as it iterates over the list. The information returned by GetMechanismInfo() includes the minimum key size and maximum key size for the mechanism, if applicable, and flags that are associated with the mechanism. The numbers shown are in decimal, and the key sizes shown are in bytes. Tip If you are doing this lab at your leisure on your own system, you could look in golang/ep11/header_consts.go and find the flags within lines 596 through 649 of that file. You'd have to convert the decimal value shown to hexadecimal. If you are taking this lab as part of a virtual event, do not take the time now to deconstruct these flags- you can always do that later since this lab is publicly available. Observe that the large majority of mechanisms in the list have a name starting with CKM_ , while a handful, such as item 77, 79, 81, and others, do not. It appears that if the mechanism is not listed in the golang/ep11/header_consts.go file, within lines 205 to 594, then it will not have a name starting with CKM_ . Note that the PKCS #11 specification does not mandate that an implementation support all defined mechanisms. Even within the subset of the 92 mechanisms that are supported by IBM's EP11 library, some are for algorithms that are considered rather outdated, and, in some cases, downright insecure. For example, the SHA-1 cryptographic hash algorithm is considered insecure these days, so any mechanims in the list that have SHA1 or SHA_1 in their name (and there are some) should be avoided. Let's move on to Exercise 2.","title":"Explanation of exercise output"},{"location":"grep11/lab-exercise2/","text":"Exercise 2 - Encrypt and Decrypt Data \u00b6 Overview of Exercise 2 \u00b6 Exercise 2 creates an AES secret key and uses it to encrypt some plaintext data. Plaintext which has been encrypted is referred to as ciphertext . This ciphertext is then decrypted back into plaintext using the same AES secret key that was used for encryption. The original plaintext is compared to- and is expected to be identical to- the plaintext that resulted from the encryption and decryption. Note Plaintext data is often, but not necessarily, human-readable. It is any data that could be of value to an adversary, if the adversary could obtain the data in its original, or plaintext, form. Hence the need for encryption. If an adversary were to obtain ciphertext, it is unreadable and thus of little or no value to the adversary. Note The PKCS #11 standard uses the phrase secret key often. Secret key is synonoymous with the term symmetric key , which is also a term commonly used in cryptography. That is, a single key is used for both encryption and decryption. Run the second exercise: ./lab --ex2 Example Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 Generated AES Key with mechanism CKM_AES_KEY_GEN length of key blob is 256 bytes Key blob is ( values in decimal ) : [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 141 38 0 0 0 0 0 0 0 1 18 52 217 158 52 159 29 220 10 126 250 240 129 168 243 15 158 220 32 30 158 254 73 111 45 102 230 162 209 246 93 216 200 108 223 116 32 109 1 82 87 166 108 227 20 9 54 59 24 126 154 14 159 250 161 203 128 27 237 27 218 243 169 235 28 112 101 109 177 94 191 251 198 126 102 93 236 51 190 157 4 188 128 1 114 120 135 191 22 7 42 191 209 135 168 241 228 137 121 180 140 113 211 159 26 192 70 74 130 25 180 75 86 230 207 240 101 164 65 179 122 59 202 213 142 244 54 151 158 46 72 52 249 87 219 11 202 69 150 45 195 200 84 134 30 148 21 70 144 235 236 141 234 135 4 120 1 180 69 84 35 73 16 71 208 212 143 135 222 115 85 26 25 172 2 202 15 2 249 109 71 41 255 177 105 20 134 33 10 54 254 210 ] The above structure is what you would save in order to persist this key blob. Below is how the above structure would typically be saved, in PEM Format: -----BEGIN HSM ENCRYPTED AES SECRET KEY----- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADsIIxQY2Y9lWElrfi1CQo AAAAAAAAjSYAAAAAAAAAARI02Z40nx3cCn768IGo8w+e3CAenv5Jby1m5qLR9l3Y yGzfdCBtAVJXpmzjFAk2Oxh+mg6f+qHLgBvtG9rzqesccGVtsV6/+8Z+Zl3sM76d BLyAAXJ4h78WByq/0Yeo8eSJebSMcdOfGsBGSoIZtEtW5s/wZaRBs3o7ytWO9DaX ni5INPlX2wvKRZYtw8hUhh6UFUaQ6+yN6ocEeAG0RVQjSRBH0NSPh95zVRoZrALK DwL5bUcp/7FpFIYhCjb+0g == -----END HSM ENCRYPTED AES SECRET KEY----- WK virtualization mask is [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ] See 6 .2.2 of page 179 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf WK ID is [ 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 ] See 6 .7.1 on page 182 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Blob version is [ 18 52 ] See 3 .1.1 on page 141 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Initialization Vector is [ 217 158 52 159 29 220 10 126 250 240 129 168 243 15 ] Encrypted part is [ 158 220 32 30 158 254 73 111 45 102 230 162 209 246 93 216 200 108 223 116 32 109 1 82 87 166 108 227 20 9 54 59 24 126 154 14 159 250 161 203 128 27 237 27 218 243 169 235 28 112 101 109 177 94 191 251 198 126 102 93 236 51 190 157 4 188 128 1 114 120 135 191 22 7 42 191 209 135 168 241 228 137 121 180 140 113 211 159 26 192 70 74 130 25 180 75 86 230 207 240 101 164 65 179 122 59 202 213 142 244 54 151 158 46 72 52 249 87 219 11 202 69 150 45 195 200 84 134 30 148 21 70 144 235 236 141 234 135 4 120 1 180 69 84 ] MAC is [ 35 73 16 71 208 212 143 135 222 115 85 26 25 172 2 202 15 2 249 109 71 41 255 177 105 20 134 33 10 54 254 210 ] MAC is 32 bytes, see field 15 in 3 .1 on page 140 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Checksum is [ 144 147 65 ] , length of checksum is 3 Original message, prior to any encryption or decryption operations: Hello, this is a very long and creative message without any imagination in progress ciphertext is: \ufffd\ufffd!E\ufffdS\ufffd\ufffd\ufffd } \ufffdp\ufffd!\ufffd\ufffd in progress ciphertext is: \ufffd\ufffd!E\ufffdS\ufffd\ufffd\ufffd } \ufffdp\ufffd!\ufffd\ufffd7I\ufffdH\u0019d\ufffdi\ufffd7p\ufffd/N\u02fd\u0018.\ufffdg\ufffd\ufffdK\ufffd ; \ufffd\ufffd\ufffd\u0015\ufffd_\ufffd\ufffd\ufffd\ufffdN\u00d8tk\ufffd\ufffd\ufffdYH\ufffd^\ufffd Final ciphertext is: \ufffd\ufffd!E\ufffdS\ufffd\ufffd\ufffd } \ufffdp\ufffd!\ufffd\ufffd7I\ufffdH\u0019d\ufffdi\ufffd7p\ufffd/N\u02fd\u0018.\ufffdg\ufffd\ufffdK\ufffd ; \ufffd\ufffd\ufffd\u0015\ufffd_\ufffd\ufffd\ufffd\ufffdN\u00d8tk\ufffd\ufffd\ufffdYH\ufffd^\ufffd\ufffd\ufffdH\ufffd5f\ufffd!\ufffd\u0019\u0018\ufffd>-\u001cc In progress decryption is: In progress decryption is: Hello, this is a very long and creative message without any imag Final decryption is: Hello, this is a very long and creative message without any imagination Original message equals decrypted message! Original message: Hello, this is a very long and creative message without any imagination Length of original message: 71 Encrypted message \ufffd\ufffd!E\ufffdS\ufffd\ufffd\ufffd } \ufffdp\ufffd!\ufffd\ufffd7I\ufffdH\u0019d\ufffdi\ufffd7p\ufffd/N\u02fd\u0018.\ufffdg\ufffd\ufffdK\ufffd ; \ufffd\ufffd\ufffd\u0015\ufffd_\ufffd\ufffd\ufffd\ufffdN\u00d8tk\ufffd\ufffd\ufffdYH\ufffd^\ufffd\ufffd\ufffdH\ufffd5f\ufffd!\ufffd\u0019\u0018\ufffd>-\u001cc Length of encrypted message: 80 Decrypted message: Hello, this is a very long and creative message without any imagination Length of decrypted message: 71 The mechanism used to generate the key is CKM_AES_KEY_GEN which informs us that we wish to generate an AES secret key. The length of the key blob is 256 bytes. Notice that this key blob contains metadata used by the EP11 library, so it contains much more than the actual key, which is 256 bits, not bytes. In fact we can't even see the key in cleartext form. It is encrypted within the key blob by the Crypto Express 7S card domain's root wrapping key . The only place the key we created is ever available in the clear is while it is being used inside the Crypto Express 7S card, because the root wrapping key never leaves the card. The ID of the root wrapping key of the Crypto Express 7S card domain is listed in the output in the line that starts with WK ID is . This ID is the first sixteen bytes of the hash of the key. It is not the full hash, and even if it was, you cannot retrieve the original data from the hash, so the root wrapping key remains secret. The ID of the root wrapping key for our Crypto Express 7S card domain is [ 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 ] As you perform the exercises in this lab, you may notice that any time I print out the WK ID , it will always be this value. The encryption in this exercise takes place in multiple calls. One may either encrypt all of the data in a single call to a function named Encrypt() , or may make multiple calls by performing one or more calls to EncryptUpdate() followed by a call to EncryptFinal() . This sample program uses the latter approach, so in the output you see two lines that say In progress ciphertext is that show the results so far after each EncryptUpdate() call and then a line that says Final ciphertext is after the call to EncryptFinal() . Decryption follows the same pattern- two calls to DecryptUpdate() followed by a call to DecryptFinal() , and the output in the program indicates this. The program for this exercise defaults to a key length of 256 bits. Try running with a key length of 128 bits: ./lab --ex2 --keyLength 128 Example Output Generated AES Key with mechanism CKM_AES_KEY_GEN length of key blob is 256 bytes Key blob is (values in decimal): [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 141 38 0 0 0 0 0 0 0 1 18 52 3 221 177 141 112 242 216 176 144 18 6 175 10 206 202 162 226 99 67 216 88 101 201 3 114 172 228 151 134 15 141 183 46 209 125 119 136 246 196 223 189 56 243 204 100 151 226 149 160 128 229 255 216 226 133 171 65 244 16 197 245 172 136 232 118 184 206 173 34 79 215 214 202 250 8 237 80 168 235 252 137 221 202 76 92 21 176 127 119 178 212 220 235 169 231 144 203 67 92 32 243 99 83 171 234 198 118 71 201 176 223 202 214 117 107 152 139 105 99 39 22 243 21 20 173 175 57 84 114 199 115 225 125 30 230 123 50 120 157 37 32 151 24 77 118 170 12 222 17 3 53 7 177 238 226 18 192 102 80 131 223 195 188 205 133 31 172 138 123 48 4 244 81 224 205 165 108 128 163 226 55 208 117 70 166 128 111 166 213 158] The above structure is what you would save in order to persist this key blob. Below is how the above structure would typically be saved, in PEM Format: -----BEGIN HSM ENCRYPTED AES SECRET KEY----- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADsIIxQY2Y9lWElrfi1CQo AAAAAAAAjSYAAAAAAAAAARI0A92xjXDy2LCQEgavCs7KouJjQ9hYZckDcqzkl4YP jbcu0X13iPbE370488xkl+KVoIDl/9jihatB9BDF9ayI6Ha4zq0iT9fWyvoI7VCo 6/yJ3cpMXBWwf3ey1NzrqeeQy0NcIPNjU6vqxnZHybDfytZ1a5iLaWMnFvMVFK2v OVRyx3PhfR7mezJ4nSUglxhNdqoM3hEDNQex7uISwGZQg9/DvM2FH6yKezAE9FHg zaVsgKPiN9B1RqaAb6bVng== -----END HSM ENCRYPTED AES SECRET KEY----- WK virtualization mask is [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] See 6.2.2 of page 179 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf WK ID is [3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40] See 6.7.1 on page 182 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Blob version is [18 52] See 3.1.1 on page 141 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Initialization Vector is [3 221 177 141 112 242 216 176 144 18 6 175 10 206] Encrypted part is [202 162 226 99 67 216 88 101 201 3 114 172 228 151 134 15 141 183 46 209 125 119 136 246 196 223 189 56 243 204 100 151 226 149 160 128 229 255 216 226 133 171 65 244 16 197 245 172 136 232 118 184 206 173 34 79 215 214 202 250 8 237 80 168 235 252 137 221 202 76 92 21 176 127 119 178 212 220 235 169 231 144 203 67 92 32 243 99 83 171 234 198 118 71 201 176 223 202 214 117 107 152 139 105 99 39 22 243 21 20 173 175 57 84 114 199 115 225 125 30 230 123 50 120 157 37 32 151 24 77 118 170 12 222 17 3 53 7 177 238 226 18 192 102] MAC is [80 131 223 195 188 205 133 31 172 138 123 48 4 244 81 224 205 165 108 128 163 226 55 208 117 70 166 128 111 166 213 158] MAC is 32 bytes, see field 15 in 3.1 on page 140 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Checksum is [132 58 194], length of checksum is 3 Original message, prior to any encryption or decryption operations: Hello, this is a very long and creative message without any imagination in progress ciphertext is: \ufffd\ufffd\ufffd\u001d[\ufffdF\ufffdVl in progress ciphertext is: \ufffd\ufffd\ufffd\u001d[\u0336:\ufffd\ufffd\ufffdl \ufffd.\ufffdW\ufffd+\ufffd]n,\ufffd\u0013#\ufffd-\ufffd\u0011\ufffd{\ufffd\ufffd\u001b\ufffd\ufffd\ufffd\ufffd\u00134\u0006\ufffd\ufffduj\ufffd\ufffd!\ufffd v Final ciphertext is: \ufffd\ufffd\ufffd\u001d[\u0336:\ufffd\ufffd\ufffdl \ufffd.\ufffdW\ufffd+\ufffd]n,\ufffd\u0013#\ufffd-\ufffd\u0011\ufffd{\ufffd\ufffd\u001b\ufffd\ufffd\ufffd\ufffd\u00134\u0006\ufffd\ufffduj\ufffd\ufffd!\ufffd v\ufffd\ufffd7\u0474\ufffd\ufffd,\ufffd\ufffd5\u001c-\ufffd\ufffd In progress decryption is: In progress decryption is: Hello, this is a very long and creative message without any imag Final decryption is: Hello, this is a very long and creative message without any imagination Original message equals decrypted message! Original message: Hello, this is a very long and creative message without any imagination Length of original message: 71 Encrypted message \ufffd\ufffd\ufffd\u001d[\u0336:\ufffd\ufffd\ufffdl \ufffd.\ufffdW\ufffd+\ufffd]n,\ufffd\u0013#\ufffd-\ufffd\u0011\ufffd{\ufffd\ufffd\u001b\ufffd\ufffd\ufffd\ufffd\u00134\u0006\ufffd\ufffduj\ufffd\ufffd!\ufffd v\ufffd\ufffd7\u0474\ufffd\ufffd,\ufffd\ufffd5\u001c-\ufffd\ufffd Length of encrypted message: 80 Decrypted message: Hello, this is a very long and creative message without any imagination Length of decrypted message: 71 Our first run of this program used a key length of 256 bits, and this run used a key length of 128 bits. Notice that the key blob itself is still 256 bytes in length. By the way, the gibberish printed out in the encrypted message portion of the output is because a byte of ciphertext is likely to contain any value from 0 to 255 and only a portion of those will turn out to be printable characters if you try to treat it as if it was a character string and try to print it out like this program does- you may see one or more lines, if one of the ciphertext bytes produced happens to be the value of a linefeed character, and if it is a carriage return without a line feed it may have \"overwritten\" some of the preceding gibberish. Real life use cases aren't typically going to require you to print ciphertext as this program did for education purposes. Try with a key length of 192 bits: ./lab --ex2 --keyLength 192 Note Output not shown here, it should be similar to the prior two commands. Try with a key length of 384 bits: ./lab --ex2 --keyLength 384 Example Output panic: GenerateKey Error: rpc error: code = Unknown desc = CKR_KEY_SIZE_RANGE goroutine 1 [running]: main.encryptAndDecrypt(0x180, 0xa28e3b, 0x47) /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/lab/exercise2.go:55 +0x2c89 main.main() /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/lab/main.go:73 +0x3a3 Don't panic! (Even if Go did). I meant for this to happen. This exercise uses the CKM_AES_KEY_GEN mechanism. (This is in the first line of the program output). If we run exercise one again and pipe its output to grep, with a fancy argument to print one extra line, we can see that the minimum key size is 128 bits and the maximum key size is 256 bits. Try it: ./lab --ex1 | grep CKM_AES_KEY_GEN --after-context 1 Note The minimum and maximum key sizes are shown in bytes, so you must multiply the values shown by eight to get the sizes in bits. So our key size must be in a range from 128 to 256 bits. Let's try a key length of 224 bits: ./lab --ex2 --keyLength 224 Example Output panic: GenerateKey Error: rpc error: code = Unknown desc = CKR_KEY_SIZE_RANGE goroutine 1 [running]: main.encryptAndDecrypt(0xe0, 0xa28e3b, 0x47) /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/lab/exercise2.go:55 +0x2c89 main.main() /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/lab/main.go:73 +0x3a3 Is this the new math where 224 is not between 128 and 256? No. What's going on here is that the AES standard supports keys of a certain length- 128, 192, and 256 bits. So while the mechanism information told us the minimum and maximum key size, the expectation is that the programmer knows a little bit about the AES standard when using it! Would you like to encrypt and decrypt your own text? Try it like this- feel free to copy and paste what is provided here, or substitute your own witty banter for the value of the --plaintext argument. ./lab --ex2 --plaintext \"The quick brown fox jumped over the lazy dog\" Note Output not shown, but you should see the message being encrypted and decrypted. Unless... Troubleshooting If you received this message in your output, panic: Failed Encrypt [rpc error: code = Unknown desc = CKR_ARGUMENTS_BAD] , then there is a pretty good chance that you supplied a plaintext value less than twenty-one characters in length. This exercise was based on the sample code, which performs the encryption in two steps. The first step passed the first twenty bytes of input to the crypto card, and the second step passed the remainder of the input. The input was hard-coded and of length greater than twenty bytes, so the sample does not have logic to handle input of twenty bytes or less. The sample has not been modified to handle the case where that second pass isn't needed. Don't worry, in the real world, you can probably solve this problem if you throw enough money at it. :-)","title":"Exercise 2 (Encryption and Decryption)"},{"location":"grep11/lab-exercise2/#exercise-2-encrypt-and-decrypt-data","text":"","title":"Exercise 2 - Encrypt and Decrypt Data"},{"location":"grep11/lab-exercise2/#overview-of-exercise-2","text":"Exercise 2 creates an AES secret key and uses it to encrypt some plaintext data. Plaintext which has been encrypted is referred to as ciphertext . This ciphertext is then decrypted back into plaintext using the same AES secret key that was used for encryption. The original plaintext is compared to- and is expected to be identical to- the plaintext that resulted from the encryption and decryption. Note Plaintext data is often, but not necessarily, human-readable. It is any data that could be of value to an adversary, if the adversary could obtain the data in its original, or plaintext, form. Hence the need for encryption. If an adversary were to obtain ciphertext, it is unreadable and thus of little or no value to the adversary. Note The PKCS #11 standard uses the phrase secret key often. Secret key is synonoymous with the term symmetric key , which is also a term commonly used in cryptography. That is, a single key is used for both encryption and decryption. Run the second exercise: ./lab --ex2 Example Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 Generated AES Key with mechanism CKM_AES_KEY_GEN length of key blob is 256 bytes Key blob is ( values in decimal ) : [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 141 38 0 0 0 0 0 0 0 1 18 52 217 158 52 159 29 220 10 126 250 240 129 168 243 15 158 220 32 30 158 254 73 111 45 102 230 162 209 246 93 216 200 108 223 116 32 109 1 82 87 166 108 227 20 9 54 59 24 126 154 14 159 250 161 203 128 27 237 27 218 243 169 235 28 112 101 109 177 94 191 251 198 126 102 93 236 51 190 157 4 188 128 1 114 120 135 191 22 7 42 191 209 135 168 241 228 137 121 180 140 113 211 159 26 192 70 74 130 25 180 75 86 230 207 240 101 164 65 179 122 59 202 213 142 244 54 151 158 46 72 52 249 87 219 11 202 69 150 45 195 200 84 134 30 148 21 70 144 235 236 141 234 135 4 120 1 180 69 84 35 73 16 71 208 212 143 135 222 115 85 26 25 172 2 202 15 2 249 109 71 41 255 177 105 20 134 33 10 54 254 210 ] The above structure is what you would save in order to persist this key blob. Below is how the above structure would typically be saved, in PEM Format: -----BEGIN HSM ENCRYPTED AES SECRET KEY----- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADsIIxQY2Y9lWElrfi1CQo AAAAAAAAjSYAAAAAAAAAARI02Z40nx3cCn768IGo8w+e3CAenv5Jby1m5qLR9l3Y yGzfdCBtAVJXpmzjFAk2Oxh+mg6f+qHLgBvtG9rzqesccGVtsV6/+8Z+Zl3sM76d BLyAAXJ4h78WByq/0Yeo8eSJebSMcdOfGsBGSoIZtEtW5s/wZaRBs3o7ytWO9DaX ni5INPlX2wvKRZYtw8hUhh6UFUaQ6+yN6ocEeAG0RVQjSRBH0NSPh95zVRoZrALK DwL5bUcp/7FpFIYhCjb+0g == -----END HSM ENCRYPTED AES SECRET KEY----- WK virtualization mask is [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ] See 6 .2.2 of page 179 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf WK ID is [ 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 ] See 6 .7.1 on page 182 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Blob version is [ 18 52 ] See 3 .1.1 on page 141 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Initialization Vector is [ 217 158 52 159 29 220 10 126 250 240 129 168 243 15 ] Encrypted part is [ 158 220 32 30 158 254 73 111 45 102 230 162 209 246 93 216 200 108 223 116 32 109 1 82 87 166 108 227 20 9 54 59 24 126 154 14 159 250 161 203 128 27 237 27 218 243 169 235 28 112 101 109 177 94 191 251 198 126 102 93 236 51 190 157 4 188 128 1 114 120 135 191 22 7 42 191 209 135 168 241 228 137 121 180 140 113 211 159 26 192 70 74 130 25 180 75 86 230 207 240 101 164 65 179 122 59 202 213 142 244 54 151 158 46 72 52 249 87 219 11 202 69 150 45 195 200 84 134 30 148 21 70 144 235 236 141 234 135 4 120 1 180 69 84 ] MAC is [ 35 73 16 71 208 212 143 135 222 115 85 26 25 172 2 202 15 2 249 109 71 41 255 177 105 20 134 33 10 54 254 210 ] MAC is 32 bytes, see field 15 in 3 .1 on page 140 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Checksum is [ 144 147 65 ] , length of checksum is 3 Original message, prior to any encryption or decryption operations: Hello, this is a very long and creative message without any imagination in progress ciphertext is: \ufffd\ufffd!E\ufffdS\ufffd\ufffd\ufffd } \ufffdp\ufffd!\ufffd\ufffd in progress ciphertext is: \ufffd\ufffd!E\ufffdS\ufffd\ufffd\ufffd } \ufffdp\ufffd!\ufffd\ufffd7I\ufffdH\u0019d\ufffdi\ufffd7p\ufffd/N\u02fd\u0018.\ufffdg\ufffd\ufffdK\ufffd ; \ufffd\ufffd\ufffd\u0015\ufffd_\ufffd\ufffd\ufffd\ufffdN\u00d8tk\ufffd\ufffd\ufffdYH\ufffd^\ufffd Final ciphertext is: \ufffd\ufffd!E\ufffdS\ufffd\ufffd\ufffd } \ufffdp\ufffd!\ufffd\ufffd7I\ufffdH\u0019d\ufffdi\ufffd7p\ufffd/N\u02fd\u0018.\ufffdg\ufffd\ufffdK\ufffd ; \ufffd\ufffd\ufffd\u0015\ufffd_\ufffd\ufffd\ufffd\ufffdN\u00d8tk\ufffd\ufffd\ufffdYH\ufffd^\ufffd\ufffd\ufffdH\ufffd5f\ufffd!\ufffd\u0019\u0018\ufffd>-\u001cc In progress decryption is: In progress decryption is: Hello, this is a very long and creative message without any imag Final decryption is: Hello, this is a very long and creative message without any imagination Original message equals decrypted message! Original message: Hello, this is a very long and creative message without any imagination Length of original message: 71 Encrypted message \ufffd\ufffd!E\ufffdS\ufffd\ufffd\ufffd } \ufffdp\ufffd!\ufffd\ufffd7I\ufffdH\u0019d\ufffdi\ufffd7p\ufffd/N\u02fd\u0018.\ufffdg\ufffd\ufffdK\ufffd ; \ufffd\ufffd\ufffd\u0015\ufffd_\ufffd\ufffd\ufffd\ufffdN\u00d8tk\ufffd\ufffd\ufffdYH\ufffd^\ufffd\ufffd\ufffdH\ufffd5f\ufffd!\ufffd\u0019\u0018\ufffd>-\u001cc Length of encrypted message: 80 Decrypted message: Hello, this is a very long and creative message without any imagination Length of decrypted message: 71 The mechanism used to generate the key is CKM_AES_KEY_GEN which informs us that we wish to generate an AES secret key. The length of the key blob is 256 bytes. Notice that this key blob contains metadata used by the EP11 library, so it contains much more than the actual key, which is 256 bits, not bytes. In fact we can't even see the key in cleartext form. It is encrypted within the key blob by the Crypto Express 7S card domain's root wrapping key . The only place the key we created is ever available in the clear is while it is being used inside the Crypto Express 7S card, because the root wrapping key never leaves the card. The ID of the root wrapping key of the Crypto Express 7S card domain is listed in the output in the line that starts with WK ID is . This ID is the first sixteen bytes of the hash of the key. It is not the full hash, and even if it was, you cannot retrieve the original data from the hash, so the root wrapping key remains secret. The ID of the root wrapping key for our Crypto Express 7S card domain is [ 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 ] As you perform the exercises in this lab, you may notice that any time I print out the WK ID , it will always be this value. The encryption in this exercise takes place in multiple calls. One may either encrypt all of the data in a single call to a function named Encrypt() , or may make multiple calls by performing one or more calls to EncryptUpdate() followed by a call to EncryptFinal() . This sample program uses the latter approach, so in the output you see two lines that say In progress ciphertext is that show the results so far after each EncryptUpdate() call and then a line that says Final ciphertext is after the call to EncryptFinal() . Decryption follows the same pattern- two calls to DecryptUpdate() followed by a call to DecryptFinal() , and the output in the program indicates this. The program for this exercise defaults to a key length of 256 bits. Try running with a key length of 128 bits: ./lab --ex2 --keyLength 128 Example Output Generated AES Key with mechanism CKM_AES_KEY_GEN length of key blob is 256 bytes Key blob is (values in decimal): [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 141 38 0 0 0 0 0 0 0 1 18 52 3 221 177 141 112 242 216 176 144 18 6 175 10 206 202 162 226 99 67 216 88 101 201 3 114 172 228 151 134 15 141 183 46 209 125 119 136 246 196 223 189 56 243 204 100 151 226 149 160 128 229 255 216 226 133 171 65 244 16 197 245 172 136 232 118 184 206 173 34 79 215 214 202 250 8 237 80 168 235 252 137 221 202 76 92 21 176 127 119 178 212 220 235 169 231 144 203 67 92 32 243 99 83 171 234 198 118 71 201 176 223 202 214 117 107 152 139 105 99 39 22 243 21 20 173 175 57 84 114 199 115 225 125 30 230 123 50 120 157 37 32 151 24 77 118 170 12 222 17 3 53 7 177 238 226 18 192 102 80 131 223 195 188 205 133 31 172 138 123 48 4 244 81 224 205 165 108 128 163 226 55 208 117 70 166 128 111 166 213 158] The above structure is what you would save in order to persist this key blob. Below is how the above structure would typically be saved, in PEM Format: -----BEGIN HSM ENCRYPTED AES SECRET KEY----- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADsIIxQY2Y9lWElrfi1CQo AAAAAAAAjSYAAAAAAAAAARI0A92xjXDy2LCQEgavCs7KouJjQ9hYZckDcqzkl4YP jbcu0X13iPbE370488xkl+KVoIDl/9jihatB9BDF9ayI6Ha4zq0iT9fWyvoI7VCo 6/yJ3cpMXBWwf3ey1NzrqeeQy0NcIPNjU6vqxnZHybDfytZ1a5iLaWMnFvMVFK2v OVRyx3PhfR7mezJ4nSUglxhNdqoM3hEDNQex7uISwGZQg9/DvM2FH6yKezAE9FHg zaVsgKPiN9B1RqaAb6bVng== -----END HSM ENCRYPTED AES SECRET KEY----- WK virtualization mask is [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] See 6.2.2 of page 179 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf WK ID is [3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40] See 6.7.1 on page 182 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Blob version is [18 52] See 3.1.1 on page 141 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Initialization Vector is [3 221 177 141 112 242 216 176 144 18 6 175 10 206] Encrypted part is [202 162 226 99 67 216 88 101 201 3 114 172 228 151 134 15 141 183 46 209 125 119 136 246 196 223 189 56 243 204 100 151 226 149 160 128 229 255 216 226 133 171 65 244 16 197 245 172 136 232 118 184 206 173 34 79 215 214 202 250 8 237 80 168 235 252 137 221 202 76 92 21 176 127 119 178 212 220 235 169 231 144 203 67 92 32 243 99 83 171 234 198 118 71 201 176 223 202 214 117 107 152 139 105 99 39 22 243 21 20 173 175 57 84 114 199 115 225 125 30 230 123 50 120 157 37 32 151 24 77 118 170 12 222 17 3 53 7 177 238 226 18 192 102] MAC is [80 131 223 195 188 205 133 31 172 138 123 48 4 244 81 224 205 165 108 128 163 226 55 208 117 70 166 128 111 166 213 158] MAC is 32 bytes, see field 15 in 3.1 on page 140 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Checksum is [132 58 194], length of checksum is 3 Original message, prior to any encryption or decryption operations: Hello, this is a very long and creative message without any imagination in progress ciphertext is: \ufffd\ufffd\ufffd\u001d[\ufffdF\ufffdVl in progress ciphertext is: \ufffd\ufffd\ufffd\u001d[\u0336:\ufffd\ufffd\ufffdl \ufffd.\ufffdW\ufffd+\ufffd]n,\ufffd\u0013#\ufffd-\ufffd\u0011\ufffd{\ufffd\ufffd\u001b\ufffd\ufffd\ufffd\ufffd\u00134\u0006\ufffd\ufffduj\ufffd\ufffd!\ufffd v Final ciphertext is: \ufffd\ufffd\ufffd\u001d[\u0336:\ufffd\ufffd\ufffdl \ufffd.\ufffdW\ufffd+\ufffd]n,\ufffd\u0013#\ufffd-\ufffd\u0011\ufffd{\ufffd\ufffd\u001b\ufffd\ufffd\ufffd\ufffd\u00134\u0006\ufffd\ufffduj\ufffd\ufffd!\ufffd v\ufffd\ufffd7\u0474\ufffd\ufffd,\ufffd\ufffd5\u001c-\ufffd\ufffd In progress decryption is: In progress decryption is: Hello, this is a very long and creative message without any imag Final decryption is: Hello, this is a very long and creative message without any imagination Original message equals decrypted message! Original message: Hello, this is a very long and creative message without any imagination Length of original message: 71 Encrypted message \ufffd\ufffd\ufffd\u001d[\u0336:\ufffd\ufffd\ufffdl \ufffd.\ufffdW\ufffd+\ufffd]n,\ufffd\u0013#\ufffd-\ufffd\u0011\ufffd{\ufffd\ufffd\u001b\ufffd\ufffd\ufffd\ufffd\u00134\u0006\ufffd\ufffduj\ufffd\ufffd!\ufffd v\ufffd\ufffd7\u0474\ufffd\ufffd,\ufffd\ufffd5\u001c-\ufffd\ufffd Length of encrypted message: 80 Decrypted message: Hello, this is a very long and creative message without any imagination Length of decrypted message: 71 Our first run of this program used a key length of 256 bits, and this run used a key length of 128 bits. Notice that the key blob itself is still 256 bytes in length. By the way, the gibberish printed out in the encrypted message portion of the output is because a byte of ciphertext is likely to contain any value from 0 to 255 and only a portion of those will turn out to be printable characters if you try to treat it as if it was a character string and try to print it out like this program does- you may see one or more lines, if one of the ciphertext bytes produced happens to be the value of a linefeed character, and if it is a carriage return without a line feed it may have \"overwritten\" some of the preceding gibberish. Real life use cases aren't typically going to require you to print ciphertext as this program did for education purposes. Try with a key length of 192 bits: ./lab --ex2 --keyLength 192 Note Output not shown here, it should be similar to the prior two commands. Try with a key length of 384 bits: ./lab --ex2 --keyLength 384 Example Output panic: GenerateKey Error: rpc error: code = Unknown desc = CKR_KEY_SIZE_RANGE goroutine 1 [running]: main.encryptAndDecrypt(0x180, 0xa28e3b, 0x47) /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/lab/exercise2.go:55 +0x2c89 main.main() /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/lab/main.go:73 +0x3a3 Don't panic! (Even if Go did). I meant for this to happen. This exercise uses the CKM_AES_KEY_GEN mechanism. (This is in the first line of the program output). If we run exercise one again and pipe its output to grep, with a fancy argument to print one extra line, we can see that the minimum key size is 128 bits and the maximum key size is 256 bits. Try it: ./lab --ex1 | grep CKM_AES_KEY_GEN --after-context 1 Note The minimum and maximum key sizes are shown in bytes, so you must multiply the values shown by eight to get the sizes in bits. So our key size must be in a range from 128 to 256 bits. Let's try a key length of 224 bits: ./lab --ex2 --keyLength 224 Example Output panic: GenerateKey Error: rpc error: code = Unknown desc = CKR_KEY_SIZE_RANGE goroutine 1 [running]: main.encryptAndDecrypt(0xe0, 0xa28e3b, 0x47) /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/lab/exercise2.go:55 +0x2c89 main.main() /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/lab/main.go:73 +0x3a3 Is this the new math where 224 is not between 128 and 256? No. What's going on here is that the AES standard supports keys of a certain length- 128, 192, and 256 bits. So while the mechanism information told us the minimum and maximum key size, the expectation is that the programmer knows a little bit about the AES standard when using it! Would you like to encrypt and decrypt your own text? Try it like this- feel free to copy and paste what is provided here, or substitute your own witty banter for the value of the --plaintext argument. ./lab --ex2 --plaintext \"The quick brown fox jumped over the lazy dog\" Note Output not shown, but you should see the message being encrypted and decrypted. Unless... Troubleshooting If you received this message in your output, panic: Failed Encrypt [rpc error: code = Unknown desc = CKR_ARGUMENTS_BAD] , then there is a pretty good chance that you supplied a plaintext value less than twenty-one characters in length. This exercise was based on the sample code, which performs the encryption in two steps. The first step passed the first twenty bytes of input to the crypto card, and the second step passed the remainder of the input. The input was hard-coded and of length greater than twenty bytes, so the sample does not have logic to handle input of twenty bytes or less. The sample has not been modified to handle the case where that second pass isn't needed. Don't worry, in the real world, you can probably solve this problem if you throw enough money at it. :-)","title":"Overview of Exercise 2"},{"location":"grep11/lab-exercise3/","text":"Exercise 3 - Sign and Verify Data \u00b6 Overview of Exercise 3 \u00b6 Exercise three uses public key cryptography to demonstrate signing of data and then verifying the signature. Other terms often used that are associated with public key cryptography are asymmetric keys or public and private key pairs . The major characteristic is that an asymmetric key is actually a pair of keys that are related. One key is called the public key and can be shared with anyone. The other key is called the private key and is kept secret. These key pairs can be used for encryption and decryption, as well as for creating and verifying digital signatures. Public key cryptography in simple terms \u00b6 Public key cryptography and encryption When using public key cryptography, the assumption is that anybody in the world could have your public key, but you have kept your private key to yourself. For encryption, anybody who has your public key could encrypt data with it and send you that encrypted data, or ciphertext. If an adversary possessed the ciphertext, they could not decrypt it. Only you, with your private key, can decrypt it. Technically, you could encrypt data with your private key that holders of your public key could decrypt, but this use case doesn't make sense- since anybody could have your public key, you have not managed to achieve privacy with your encryption. Public key cryptography and digital signatures Your private key can be used to allow you to digitally \"sign\" data, which is an attestation that you have seen the data that you have signed, analagous to your signing by pen a letter or contract on a piece of paper. There are different digital signature algorithms, but in general, they follow the following pattern. Assume you want to digitally sign some data you send to somebody: You create a digest, or hash, over some data, using some algorithm. This hash uniquely identifies the data. You encrypt this hash with your private key. This is your digital signature. You send the data, and your digital signature, to the intended recipient. The recipient calculates the digest, or hash, of the data, using the same algorithm that you used in step 1. If the data has remained intact in transit, they will calculate the same hash that you did in step 1. They then decrypt your signature (from step 2) with your public key. This retrieves in plaintext the hash you signed in step 2. If the hash they calculated in step 4 matches the hash that you encrypted with your private key in step 2 (and retrieved by them in step 5), then it is proof that you have seen the data they have received. The fundamental assumption is that you have kept your private key in your sole possession. If an adversary stole your private key they could impersonate you. Also, observe that the validity of this digital signature is independent of whether or not the data that you send is plaintext or ciphertext. The two most commonly used forms of public key cryptography are RSA cryptography and elliptic curve cryptography. RSA cryptography was developed first and is built upon the difficulty of factoring the product of two very large prime numbers. It is easy for a computer to find two very large prime numbers and multiply them together to obtain a product. On the other hand, given this product, it is extremely difficult, if not impossible, for even today's powerful computers to figure out what two prime numbers were used to produce that product! It seems like a preposterous statement, but it's true! Elliptic curve cryptography is based on algebraic equations called elliptic curves. The idea is that a mathematical addition function can be defined on this curve, such that it is very easy for a computer to do a large number of additions on the curve which results in a point on the curve. But if you give someone the equation for the curve, and the point on the curve that you have calculated, but you don't tell them how many additions you did to calculate this point, even today's powerful computers cannot figure out how many additions were performed! It seems like a preposterous statement, but it's true! In simple terms, an RSA public key contains the product of the two primes, and the RSA private key contains the hidden information- the two primes. An elliptic curve public key contains all of the information about the curve, including the point that was calculated, except for the number of additions used to calculate the point, while the elliptic curve private key includes the hidden information- the number of additions that were used to create the point. If I multiplied two small prime numbers like 7 x 13 and gave you the product 91, it probably wouldn't take you too long to factor it back to 7 and 13. Computers need to use incredibliy large prime numbers in order to calculate a product that another computer can't quickly factor. That is why RSA keys are usually 2048 or 4096 bits in length. You can create smaller RSA keys but today's computers can factor the product contained in the public key quicker, the smaller the key. On the other hand, the size of elliptic curve public keys can be much smaller than RSA public keys, and provide the equivalent strength. That is, a relatively small-sized elliptic curve key is just as difficult for a computer to crack by brute force than it is for a much larger-sized RSA key. For this reason, elliptic curve cryptography is becoming increasingly popular- the smaller key size means less computational power is needed to work with these keys, so they are more efficient and use less power, which is more appealing for devices that are typically drawing on battery power, like smartphones and tablets. EP11 supports both RSA and elliptic curve cryptography, as you saw in the GREP11 sample. This exercise will dig a little deeper into elliptic curves. Run Exercise 3 \u00b6 Run the third exercise: ./lab --ex3 Example Output selected curve P521 with ObjectID of 1.3.132.0.35 Curve ObjectID in ASN.1 BER encoding is [6 5 43 129 4 0 35] Generated ECDSA PKCS key pair with mechanism CKM_EC_KEY_PAIR_GEN key pair public key blob length is 286 bytes key pair public key blob is [48 129 155 48 16 6 7 42 134 72 206 61 2 1 6 5 43 129 4 0 35 3 129 134 0 4 1 251 93 197 238 11 2 165 14 39 212 27 175 77 65 78 70 252 221 242 195 236 163 3 63 184 70 158 146 51 22 230 181 30 78 101 47 150 133 100 197 101 31 144 59 192 199 237 14 94 86 237 73 52 79 1 45 220 65 57 113 117 113 173 220 70 0 48 137 50 146 141 22 219 122 151 69 232 10 132 29 121 198 108 226 233 9 117 185 16 125 236 113 235 136 54 127 109 229 150 26 117 63 231 242 158 101 248 86 80 17 69 31 217 156 122 140 30 75 132 155 187 35 148 239 49 81 172 10 210 181 169 4 16 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 4 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 8 255 72 74 131 146 172 234 187 4 8 0 0 0 0 0 0 0 1 4 20 16 1 0 0 0 1 128 128 0 1 128 128 128 1 0 10 0 0 0 1 4 32 217 93 11 148 136 24 62 138 168 213 244 131 187 81 107 102 114 120 167 70 193 179 233 4 32 228 144 160 232 167 125 167] key pair private key blob length is 896 bytes key pair private key blob is [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 1 38 0 0 0 0 0 0 0 1 18 52 145 242 100 209 252 135 97 118 108 26 68 196 204 214 35 186 208 121 174 78 194 146 179 179 92 26 100 178 30 39 144 58 232 153 47 120 177 131 143 109 255 143 188 55 83 243 168 100 93 113 176 50 33 176 209 178 137 124 13 64 217 65 230 242 127 41 206 53 149 52 238 111 241 174 206 137 141 251 17 145 233 76 219 82 103 108 35 168 57 114 44 179 164 157 12 81 167 193 171 27 42 69 50 108 161 45 227 151 199 15 59 120 177 122 62 66 95 9 115 57 85 29 132 224 146 162 177 224 143 36 125 126 210 113 18 73 145 60 48 109 176 162 41 145 33 242 93 154 122 118 216 252 111 7 253 207 195 227 151 15 112 99 44 177 14 14 193 35 199 207 79 29 219 88 146 132 3 80 128 196 150 37 18 7 192 185 68 38 158 232 84 145 198 24 210 154 34 157 76 53 244 18 31 194 99 80 36 31 225 41 141 69 135 116 43 239 186 193 84 112 103 110 56 148 66 115 76 202 125 45 15 86 124 24 19 247 208 131 51 37 186 172 94 58 155 214 238 131 253 48 86 125 62 240 123 236 237 88 76 218 21 215 202 210 90 29 119 239 2 237 11 242 202 214 116 98 88 90 15 0 12 170 20 96 132 49 224 57 22 113 123 27 19 173 121 50 99 116 175 20 153 192 223 84 121 17 154 88 74 118 245 131 21 179 162 154 44 182 15 66 240 9 154 118 1 122 101 101 103 14 207 47 167 133 152 187 147 221 241 84 223 72 136 243 239 77 65 121 219 208 223 95 175 139 39 100 52 227 185 126 22 143 41 183 28 57 63 238 117 196 172 63 131 116 248 74 165 132 160 77 148 174 44 102 91 29 49 74 230 85 215 83 154 130 46 164 163 212 85 82 103 5 205 233 181 126 160 118 154 65 120 155 89 224 218 132 99 158 134 210 225 219 252 254 167 208 170 164 148 97 226 25 236 152 47 113 74 5 73 177 157 60 120 4 62 87 17 116 190 73 132 124 17 61 46 63 12 184 8 74 177 100 119 151 58 163 126 181 199 95 202 99 112 64 55 97 66 138 83 168 62 160 62 8 160 148 126 215 124 65 228 200 122 192 129 121 18 135 244 95 4 94 0 231 246 49 195 181 35 72 161 110 97 180 135 111 33 28 173 49 235 8 58 56 217 31 159 195 61 195 34 10 160 111 224 53 22 175 9 79 39 142 46 43 91 210 69 183 229 68 114 86 142 221 196 206 234 143 244 49 236 231 253 226 95 36 14 131 74 48 31 144 4 254 235 158 189 98 28 1 100 181 19 139 69 29 166 136 227 85 21 131 130 138 197 249 29 222 65 128 252 16 217 121 157 232 150 126 54 245 116 145 127 175 167 125 46 94 214 38 224 85 172 87 97 163 231 181 218 248 103 211 224 79 122 157 160 76 54 242 13 46 182 10 105 119 6 51 91 11 116 120 2 188 148 108 191 158 100 28 40 158 212 35 94 53 6 59 84 216 207 101 112 40 178 164 252 110 116 39 59 78 78 7 204 241 147 2 234 244 153 214 32 151 187 250 112 162 173 136 214 67 114 195 102 170 240 228 160 123 41 178 7 2 147 66 5 236 100 170 198 233 8 218 163 244 224 211 8 127 36 60 220 185 158 17 171 78 156 168 141 73 86 146 47 252 55 247 12 105 21 170 199 27 69 149 217 78 89 37 125 246 220 29 177 15 18 78 153 170 123 109 248 47 4 130 121 174 88 44 96 61 71 208 112 34 236 111 189 240 195 15 45 176 84 140 35 171 110 124 164 98 0 122 173 69 82 27 118 51 226 30 193 106 51 21 83 194 189 110 18 92 156 198 221 189 211 84 220 207] Some of the fields in the private key blob follow: WK ID is [3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40] See 6.7.1 of page 182 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Blob version is [18 52] See 3.1.1 on page 141 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf IV is [145 242 100 209 252 135 97 118 108 26 68 196 204 214] Encrypted part is [35 186 208 121 174 78 194 146 179 179 92 26 100 178 30 39 144 58 232 153 47 120 177 131 143 109 255 143 188 55 83 243 168 100 93 113 176 50 33 176 209 178 137 124 13 64 217 65 230 242 127 41 206 53 149 52 238 111 241 174 206 137 141 251 17 145 233 76 219 82 103 108 35 168 57 114 44 179 164 157 12 81 167 193 171 27 42 69 50 108 161 45 227 151 199 15 59 120 177 122 62 66 95 9 115 57 85 29 132 224 146 162 177 224 143 36 125 126 210 113 18 73 145 60 48 109 176 162 41 145 33 242 93 154 122 118 216 252 111 7 253 207 195 227 151 15 112 99 44 177 14 14 193 35 199 207 79 29 219 88 146 132 3 80 128 196 150 37 18 7 192 185 68 38 158 232 84 145 198 24 210 154 34 157 76 53 244 18 31 194 99 80 36 31 225 41 141 69 135 116 43 239 186 193 84 112 103 110 56 148 66 115 76 202 125 45 15 86 124 24 19 247 208 131 51 37 186 172 94 58 155 214 238 131 253 48 86 125 62 240 123 236 237 88 76 218 21 215 202 210 90 29 119 239 2 237 11 242 202 214 116 98 88 90 15 0 12 170 20 96 132 49 224 57 22 113 123 27 19 173 121 50 99 116 175 20 153 192 223 84 121 17 154 88 74 118 245 131 21 179 162 154 44 182 15 66 240 9 154 118 1 122 101 101 103 14 207 47 167 133 152 187 147 221 241 84 223 72 136 243 239 77 65 121 219 208 223 95 175 139 39 100 52 227 185 126 22 143 41 183 28 57 63 238 117 196 172 63 131 116 248 74 165 132 160 77 148 174 44 102 91 29 49 74 230 85 215 83 154 130 46 164 163 212 85 82 103 5 205 233 181 126 160 118 154 65 120 155 89 224 218 132 99 158 134 210 225 219 252 254 167 208 170 164 148 97 226 25 236 152 47 113 74 5 73 177 157 60 120 4 62 87 17 116 190 73 132 124 17 61 46 63 12 184 8 74 177 100 119 151 58 163 126 181 199 95 202 99 112 64 55 97 66 138 83 168 62 160 62 8 160 148 126 215 124 65 228 200 122 192 129 121 18 135 244 95 4 94 0 231 246 49 195 181 35 72 161 110 97 180 135 111 33 28 173 49 235 8 58 56 217 31 159 195 61 195 34 10 160 111 224 53 22 175 9 79 39 142 46 43 91 210 69 183 229 68 114 86 142 221 196 206 234 143 244 49 236 231 253 226 95 36 14 131 74 48 31 144 4 254 235 158 189 98 28 1 100 181 19 139 69 29 166 136 227 85 21 131 130 138 197 249 29 222 65 128 252 16 217 121 157 232 150 126 54 245 116 145 127 175 167 125 46 94 214 38 224 85 172 87 97 163 231 181 218 248 103 211 224 79 122 157 160 76 54 242 13 46 182 10 105 119 6 51 91 11 116 120 2 188 148 108 191 158 100 28 40 158 212 35 94 53 6 59 84 216 207 101 112 40 178 164 252 110 116 39 59 78 78 7 204 241 147 2 234 244 153 214 32 151 187 250 112 162 173 136 214 67 114 195 102 170 240 228 160 123 41 178 7 2 147 66 5 236 100 170 198 233 8 218 163 244 224 211 8 127 36 60 220 185 158 17 171 78 156 168 141 73 86 146 47 252 55 247 12 105 21 170 199 27 69 149 217 78 89 37 125 246 220 29 177 15 18 78 153 170 123 109 248 47 4 130 121 174 88 44 96 61 71 208 112 34 236 111 189 240 195 15 45 176 84 140 35 171] MAC is [110 124 164 98 0 122 173 69 82 27 118 51 226 30 193 106 51 21 83 194 189 110 18 92 156 198 221 189 211 84 220 207] MAC is 32 bytes, see field 15 in 3.1 on page 140 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf -----BEGIN HSM ENCRYPTED PRIVATE KEY----- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADsIIxQY2Y9lWElrfi1CQo AAAAAAAAASYAAAAAAAAAARI0kfJk0fyHYXZsGkTEzNYjutB5rk7CkrOzXBpksh4n kDromS94sYOPbf+PvDdT86hkXXGwMiGw0bKJfA1A2UHm8n8pzjWVNO5v8a7OiY37 EZHpTNtSZ2wjqDlyLLOknQxRp8GrGypFMmyhLeOXxw87eLF6PkJfCXM5VR2E4JKi seCPJH1+0nESSZE8MG2woimRIfJdmnp22PxvB/3Pw+OXD3BjLLEODsEjx89PHdtY koQDUIDEliUSB8C5RCae6FSRxhjSmiKdTDX0Eh/CY1AkH+EpjUWHdCvvusFUcGdu OJRCc0zKfS0PVnwYE/fQgzMluqxeOpvW7oP9MFZ9PvB77O1YTNoV18rSWh137wLt C/LK1nRiWFoPAAyqFGCEMeA5FnF7GxOteTJjdK8UmcDfVHkRmlhKdvWDFbOimiy2 D0LwCZp2AXplZWcOzy+nhZi7k93xVN9IiPPvTUF529DfX6+LJ2Q047l+Fo8ptxw5 P+51xKw/g3T4SqWEoE2UrixmWx0xSuZV11Oagi6ko9RVUmcFzem1fqB2mkF4m1ng 2oRjnobS4dv8/qfQqqSUYeIZ7JgvcUoFSbGdPHgEPlcRdL5JhHwRPS4/DLgISrFk d5c6o361x1/KY3BAN2FCilOoPqA+CKCUftd8QeTIesCBeRKH9F8EXgDn9jHDtSNI oW5htIdvIRytMesIOjjZH5/DPcMiCqBv4DUWrwlPJ44uK1vSRbflRHJWjt3EzuqP 9DHs5/3iXyQOg0owH5AE/uuevWIcAWS1E4tFHaaI41UVg4KKxfkd3kGA/BDZeZ3o ln429XSRf6+nfS5e1ibgVaxXYaPntdr4Z9PgT3qdoEw28g0utgppdwYzWwt0eAK8 lGy/nmQcKJ7UI141BjtU2M9lcCiypPxudCc7Tk4HzPGTAur0mdYgl7v6cKKtiNZD csNmqvDkoHspsgcCk0IF7GSqxukI2qP04NMIfyQ83LmeEatOnKiNSVaSL/w39wxp FarHG0WV2U5ZJX323B2xDxJOmap7bfgvBIJ5rlgsYD1H0HAi7G+98MMPLbBUjCOr bnykYgB6rUVSG3Yz4h7BajMVU8K9bhJcnMbdvdNU3M8= -----END HSM ENCRYPTED PRIVATE KEY----- -----BEGIN PUBLIC KEY----- MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQB+13F7gsCpQ4n1BuvTUFORvzd8sPs owM/uEaekjMW5rUeTmUvloVkxWUfkDvAx+0OXlbtSTRPAS3cQTlxdXGt3EYAMIky ko0W23qXRegKhB15xmzi6Ql1uRB97HHriDZ/beWWGnU/5/KeZfhWUBFFH9mceowe S4SbuyOU7zFRrArStakEEAOwgjFBjZj2VYSWt+LUJCgEIAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAABAj/SEqDkqzquwQIAAAAAAAAAAEEFBABAAAAAYCA AAGAgIABAAoAAAABBCDZXQuUiBg+iqjV9IO7UWtmcninRsGz6QQg5JCg6Kd9pw== -----END PUBLIC KEY----- Data signed Signature verified The first line of the output shows the Object ID of the curve that was used. These Object IDs are assigned by standards bodies. The Object ID used here is 1.3.132.0.35 . Stick 1.3.132.0.35 in your favorite Google machine and see what you find. Or take my word for it that this identifies the secp521r1 curve. The second line of the output shows ASN.1 BER encoding of 1.3.132.0.35, which is 6 5 43 129 4 0 35 . If you were to look up how ASN.1 BER encoding works, your first question would be, \"Why?\". Don't go there now. But I bring it up because you will notice that a few lines down in the output, in the key pair public key blob section, you'll see that encoded string, 6 5 43 129 4 0 35 , about 14 bytes from the beginning. In fact, while the whole point of using the GREP11 server and the Crypto Express 7S cards is to keep secrets from an adversary, the information shown in the key pair public key blob section is \"in the clear\"- you could give this to your adversary without fear of having your secrets compromised. The list of decimal bytes of these keys is mostly gibberish to us humans, I'm not sure why I even bothered to print them out, but take a look at the output at the end, where there are several lines between a header and footer for HSM ENCRYPTED PRIVATE KEY (BEGIN and END), and several lines between a header and footer for a PUBLIC KEY. To use these keys in the future, you would need to persist both of these to separate files. You wouldn't have a reason to give your adversary the HSM ENCRYPTED PRIVATE KEY, but, if he did obtain it, it would be of no value to him unless he was able to access your Crypto Express 7S card that had the same root wrapping key. The contents of this file are encrypted and are usuable only within the Crypto Express card that created it, or in another Crypto Express card that had the same root wrapping key. Since the PUBLIC KEY is, by definition, shareable with the world, we can use the common openssl utility to look at it. Try it like this: Copy the lines from near the bottom of your output that have your public key , including the BEGIN PUBLIC KEY and END PUBLIC KEY header and footer lines, and the dashes, into your clipboard In a terminal window, type echo \" (that is a single pair of double-quotes) and then paste your clipboard contents onto the command line Type \" | openssl ec -in - -pubin -noout -text and then press Enter You should see output similar to this: read EC key Public-Key: (521 bit) pub: 04:00:59:fe:0c:b3:d0:6e:b2:d7:b0:c0:05:86:66: dd:62:bc:fe:96:5c:fa:08:6d:f3:be:5f:6d:a1:3d: 8f:40:13:83:23:ec:34:e4:e5:20:6c:f9:75:34:bd: 30:cd:be:1f:5b:aa:ee:44:99:d9:ae:69:50:24:c7: 82:7c:f4:f2:18:d1:b0:00:be:5c:64:f5:dd:16:79: eb:d4:9c:28:ae:43:9b:f4:13:a4:f3:db:3c:a2:e5: 52:bb:0f:9f:e1:c4:a4:c1:29:63:4e:bc:2f:73:4c: da:fd:4f:42:63:0d:3d:9d:bb:29:76:57:85:13:57: 3a:ae:8f:20:64:0a:cf:c2:f1:41:d3:fc:8a ASN1 OID: secp521r1 NIST CURVE: P-521 Tip If you are a Linux guru you could create a file with vi and copy the key into the file, and then provide that as input to the openssl command, e.g., openssl ec -in baz -pubin -noout -text if baz was the file you created. In the exercise output I first printed the public key as an array of decimal numbers (worthless!), then I printed it in PEM-encoded format (boring!) but now you see the key in hexadecimal format (that's incredible!!). You also get the added bonus of knowing it's a legit public key since the openssl utility made sense of it. Try using a different curve: ./lab --ex3 --curve P224 Example Output selected curve P224 with ObjectID of 1.3.132.0.33 Curve ObjectID in ASN.1 BER encoding is [6 5 43 129 4 0 33] Generated ECDSA PKCS key pair with mechanism CKM_EC_KEY_PAIR_GEN key pair public key blob length is 208 bytes key pair public key blob is [48 78 48 16 6 7 42 134 72 206 61 2 1 6 5 43 129 4 0 33 3 58 0 4 177 164 170 83 241 4 140 49 236 115 12 22 130 206 48 90 174 181 135 16 59 31 11 122 14 254 13 172 129 64 249 1 40 44 231 155 52 110 38 67 175 244 45 81 157 5 213 125 224 199 126 65 251 200 159 53 4 16 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 4 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 8 6 63 231 63 240 230 179 88 4 8 0 0 0 0 0 0 0 1 4 20 16 1 0 0 0 1 128 128 0 1 128 128 128 1 0 10 0 0 0 1 4 32 90 61 58 127 30 244 119 154 65 27 170 14 182 232 45 237 92 61 188 238 138 237 84 7 5 209 228 172 195 235 219 189] key pair private key blob length is 544 bytes key pair private key blob is [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 1 38 0 0 0 0 0 0 0 1 18 52 1 7 210 186 20 15 180 182 68 217 17 251 23 142 218 85 206 228 75 16 37 108 9 47 216 5 160 29 100 235 78 164 63 25 232 181 251 214 113 69 26 198 9 222 119 149 66 64 233 183 172 93 96 41 223 99 201 110 138 227 51 26 197 166 9 8 190 40 129 254 49 89 54 38 209 21 60 137 118 113 174 145 254 145 152 119 73 114 11 144 41 25 106 152 140 167 192 88 82 199 100 234 18 255 129 213 111 25 126 2 200 3 44 90 252 84 48 191 106 98 2 77 78 7 165 189 227 52 167 78 188 5 185 254 178 206 180 171 47 110 54 38 87 16 191 167 134 237 48 49 153 168 54 225 251 75 223 3 55 239 48 119 76 89 103 20 30 222 104 167 219 210 46 17 75 224 196 191 55 238 236 156 205 119 182 199 12 58 144 248 124 216 181 38 11 17 139 144 123 31 108 76 171 91 154 112 6 160 188 2 181 110 212 46 66 153 211 21 184 1 51 194 12 245 73 155 192 206 80 213 51 187 166 3 207 127 151 127 59 158 192 7 92 113 247 118 108 55 217 84 183 34 24 144 57 215 193 96 179 93 2 190 84 85 119 199 179 96 119 2 9 160 231 251 214 187 5 206 224 207 111 52 58 181 131 237 11 245 106 181 223 217 240 98 162 190 11 116 18 46 225 218 17 130 79 19 4 171 94 129 197 59 201 54 63 31 60 90 84 225 223 121 94 173 42 103 3 204 128 187 143 209 78 80 151 157 90 44 76 20 254 18 96 197 70 36 135 24 13 156 77 112 196 22 35 123 199 169 17 195 156 0 212 50 140 50 126 70 132 126 149 172 94 173 49 156 173 207 208 109 166 88 148 204 25 122 119 58 130 215 130 101 13 235 96 29 210 130 229 51 232 250 206 124 162 68 112 3 191 129 184 195 34 186 72 103 159 228 155 244 43 108 205 37 82 176 243 200 233 88 91 31 243 33 232 44 178 19 57 182 239 63 238 130 33 1 127 250 215 109 121 187 134 218 173 74 112 88 230 152 90 147 20 43 28 254 173 28 25 255 0 147 78 51 231 175 190 29] Some of the fields in the private key blob follow: WK ID is [3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40] See 6.7.1 of page 182 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Blob version is [18 52] See 3.1.1 on page 141 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf IV is [1 7 210 186 20 15 180 182 68 217 17 251 23 142] Encrypted part is [218 85 206 228 75 16 37 108 9 47 216 5 160 29 100 235 78 164 63 25 232 181 251 214 113 69 26 198 9 222 119 149 66 64 233 183 172 93 96 41 223 99 201 110 138 227 51 26 197 166 9 8 190 40 129 254 49 89 54 38 209 21 60 137 118 113 174 145 254 145 152 119 73 114 11 144 41 25 106 152 140 167 192 88 82 199 100 234 18 255 129 213 111 25 126 2 200 3 44 90 252 84 48 191 106 98 2 77 78 7 165 189 227 52 167 78 188 5 185 254 178 206 180 171 47 110 54 38 87 16 191 167 134 237 48 49 153 168 54 225 251 75 223 3 55 239 48 119 76 89 103 20 30 222 104 167 219 210 46 17 75 224 196 191 55 238 236 156 205 119 182 199 12 58 144 248 124 216 181 38 11 17 139 144 123 31 108 76 171 91 154 112 6 160 188 2 181 110 212 46 66 153 211 21 184 1 51 194 12 245 73 155 192 206 80 213 51 187 166 3 207 127 151 127 59 158 192 7 92 113 247 118 108 55 217 84 183 34 24 144 57 215 193 96 179 93 2 190 84 85 119 199 179 96 119 2 9 160 231 251 214 187 5 206 224 207 111 52 58 181 131 237 11 245 106 181 223 217 240 98 162 190 11 116 18 46 225 218 17 130 79 19 4 171 94 129 197 59 201 54 63 31 60 90 84 225 223 121 94 173 42 103 3 204 128 187 143 209 78 80 151 157 90 44 76 20 254 18 96 197 70 36 135 24 13 156 77 112 196 22 35 123 199 169 17 195 156 0 212 50 140 50 126 70 132 126 149 172 94 173 49 156 173 207 208 109 166 88 148 204 25 122 119 58 130 215 130 101 13 235 96 29 210 130 229 51 232 250 206 124 162 68 112 3 191 129 184 195 34 186 72 103 159 228 155 244 43 108 205 37 82 176 243 200 233 88 91 31 243 33 232 44 178 19 57 182 239 63 238 130 33 1] MAC is [127 250 215 109 121 187 134 218 173 74 112 88 230 152 90 147 20 43 28 254 173 28 25 255 0 147 78 51 231 175 190 29] MAC is 32 bytes, see field 15 in 3.1 on page 140 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf -----BEGIN HSM ENCRYPTED PRIVATE KEY----- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADsIIxQY2Y9lWElrfi1CQo AAAAAAAAASYAAAAAAAAAARI0AQfSuhQPtLZE2RH7F47aVc7kSxAlbAkv2AWgHWTr TqQ/Gei1+9ZxRRrGCd53lUJA6besXWAp32PJborjMxrFpgkIviiB/jFZNibRFTyJ dnGukf6RmHdJcguQKRlqmIynwFhSx2TqEv+B1W8ZfgLIAyxa/FQwv2piAk1OB6W9 4zSnTrwFuf6yzrSrL242JlcQv6eG7TAxmag24ftL3wM37zB3TFlnFB7eaKfb0i4R S+DEvzfu7JzNd7bHDDqQ+HzYtSYLEYuQex9sTKtbmnAGoLwCtW7ULkKZ0xW4ATPC DPVJm8DOUNUzu6YDz3+XfzuewAdccfd2bDfZVLciGJA518Fgs10CvlRVd8ezYHcC CaDn+9a7Bc7gz280OrWD7Qv1arXf2fBior4LdBIu4doRgk8TBKtegcU7yTY/Hzxa VOHfeV6tKmcDzIC7j9FOUJedWixMFP4SYMVGJIcYDZxNcMQWI3vHqRHDnADUMowy fkaEfpWsXq0xnK3P0G2mWJTMGXp3OoLXgmUN62Ad0oLlM+j6znyiRHADv4G4wyK6 SGef5Jv0K2zNJVKw88jpWFsf8yHoLLITObbvP+6CIQF/+tdtebuG2q1KcFjmmFqT FCsc/q0cGf8Ak04z56++HQ== -----END HSM ENCRYPTED PRIVATE KEY----- -----BEGIN PUBLIC KEY----- ME4wEAYHKoZIzj0CAQYFK4EEACEDOgAEsaSqU/EEjDHscwwWgs4wWq61hxA7Hwt6 Dv4NrIFA+QEoLOebNG4mQ6/0LVGdBdV94Md+QfvInzUEEAOwgjFBjZj2VYSWt+LU JCgEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAgGP+c/8OazWAQI AAAAAAAAAAEEFBABAAAAAYCAAAGAgIABAAoAAAABBCBaPTp/HvR3mkEbqg626C3t XD287ortVAcF0eSsw+vbvQ== -----END PUBLIC KEY----- Data signed Signature verified Try the P256 curve: ./lab --ex3 --curve P256 Example output selected curve P256 with ObjectID of 1.2.840.10045.3.1.7 Curve ObjectID in ASN.1 BER encoding is [6 8 42 134 72 206 61 3 1 7] Generated ECDSA PKCS key pair with mechanism CKM_EC_KEY_PAIR_GEN key pair public key blob length is 219 bytes key pair public key blob is [48 89 48 19 6 7 42 134 72 206 61 2 1 6 8 42 134 72 206 61 3 1 7 3 66 0 4 110 106 106 221 176 75 119 181 154 179 115 108 192 148 127 80 203 20 154 165 194 20 40 117 94 117 223 125 118 133 226 230 18 128 20 46 239 61 241 136 41 9 78 202 124 188 192 93 181 229 245 210 78 187 156 152 192 132 255 162 17 51 187 117 4 16 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 4 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 8 203 203 135 115 66 126 231 150 4 8 0 0 0 0 0 0 0 1 4 20 16 1 0 0 0 1 128 128 0 1 128 128 128 1 0 10 0 0 0 1 4 32 117 106 180 43 131 151 71 204 222 211 38 32 214 138 208 98 235 7 172 87 236 205 51 122 54 65 64 58 70 89 127 218] key pair private key blob length is 576 bytes key pair private key blob is [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 1 38 0 0 0 0 0 0 0 1 18 52 234 153 96 242 234 92 129 26 151 136 72 248 23 66 196 52 4 170 78 111 124 89 151 169 22 232 12 154 65 246 71 238 229 101 98 135 230 50 24 66 130 82 190 65 48 151 138 8 183 43 229 56 95 235 90 163 68 81 9 77 56 28 104 192 150 105 31 193 133 24 224 125 104 86 165 104 162 87 247 209 66 173 168 45 232 4 229 134 211 133 24 229 196 10 32 90 129 146 138 115 39 163 206 102 141 49 142 143 55 114 160 210 56 132 237 137 157 136 203 0 20 217 144 233 140 198 26 179 60 218 95 201 29 214 100 144 55 226 195 23 83 105 50 175 174 214 216 130 2 71 17 191 197 26 180 89 147 168 61 236 49 230 64 190 217 199 13 244 173 182 255 91 144 51 231 177 252 232 210 156 130 70 14 30 129 255 82 247 162 116 213 100 248 100 190 125 48 3 168 85 249 192 75 26 221 95 113 27 1 123 130 248 176 164 140 61 141 190 157 241 193 100 2 180 163 73 141 252 213 35 213 158 95 46 85 0 94 159 101 16 31 97 109 63 64 35 238 255 208 175 121 180 84 162 66 210 119 10 131 119 187 27 116 152 2 41 62 175 176 244 123 70 42 51 244 113 238 102 113 195 54 242 80 148 90 145 226 10 180 122 94 143 119 125 187 118 7 28 184 214 205 205 97 18 71 235 186 245 199 246 57 3 208 121 40 73 6 28 64 217 154 216 108 59 46 158 80 133 8 196 11 223 201 199 234 77 99 219 238 244 6 254 96 55 5 88 109 181 57 85 82 64 67 46 13 114 56 74 117 215 61 161 26 37 221 210 18 229 131 11 232 38 101 190 54 241 253 217 100 80 205 45 113 51 237 105 252 159 11 126 74 152 22 138 45 30 188 157 151 101 139 134 16 221 153 56 216 167 210 214 79 150 96 170 83 161 118 219 162 45 113 179 106 87 147 99 222 42 122 194 24 249 53 210 222 206 2 74 232 110 135 6 12 110 53 2 15 144 180 185 58 249 41 54 36 128 61 116 221 158 154 95 142 32 213 89 48 209 47 155 239 2 142 171 218 207 130 140 18 125 86 224 20 5 4 83 108 163 82 243 62 254 77 103 87 90 32 112 50 169 54 139 200 219 92 84 191 177 139 94] Some of the fields in the private key blob follow: WK ID is [3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40] See 6.7.1 of page 182 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Blob version is [18 52] See 3.1.1 on page 141 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf IV is [234 153 96 242 234 92 129 26 151 136 72 248 23 66] Encrypted part is [196 52 4 170 78 111 124 89 151 169 22 232 12 154 65 246 71 238 229 101 98 135 230 50 24 66 130 82 190 65 48 151 138 8 183 43 229 56 95 235 90 163 68 81 9 77 56 28 104 192 150 105 31 193 133 24 224 125 104 86 165 104 162 87 247 209 66 173 168 45 232 4 229 134 211 133 24 229 196 10 32 90 129 146 138 115 39 163 206 102 141 49 142 143 55 114 160 210 56 132 237 137 157 136 203 0 20 217 144 233 140 198 26 179 60 218 95 201 29 214 100 144 55 226 195 23 83 105 50 175 174 214 216 130 2 71 17 191 197 26 180 89 147 168 61 236 49 230 64 190 217 199 13 244 173 182 255 91 144 51 231 177 252 232 210 156 130 70 14 30 129 255 82 247 162 116 213 100 248 100 190 125 48 3 168 85 249 192 75 26 221 95 113 27 1 123 130 248 176 164 140 61 141 190 157 241 193 100 2 180 163 73 141 252 213 35 213 158 95 46 85 0 94 159 101 16 31 97 109 63 64 35 238 255 208 175 121 180 84 162 66 210 119 10 131 119 187 27 116 152 2 41 62 175 176 244 123 70 42 51 244 113 238 102 113 195 54 242 80 148 90 145 226 10 180 122 94 143 119 125 187 118 7 28 184 214 205 205 97 18 71 235 186 245 199 246 57 3 208 121 40 73 6 28 64 217 154 216 108 59 46 158 80 133 8 196 11 223 201 199 234 77 99 219 238 244 6 254 96 55 5 88 109 181 57 85 82 64 67 46 13 114 56 74 117 215 61 161 26 37 221 210 18 229 131 11 232 38 101 190 54 241 253 217 100 80 205 45 113 51 237 105 252 159 11 126 74 152 22 138 45 30 188 157 151 101 139 134 16 221 153 56 216 167 210 214 79 150 96 170 83 161 118 219 162 45 113 179 106 87 147 99 222 42 122 194 24 249 53 210 222 206 2 74 232 110 135 6 12 110 53 2 15 144 180 185 58 249 41 54 36 128 61 116 221 158 154 95 142 32 213 89 48 209 47 155 239 2 142 171 218 207 130 140] MAC is [18 125 86 224 20 5 4 83 108 163 82 243 62 254 77 103 87 90 32 112 50 169 54 139 200 219 92 84 191 177 139 94] MAC is 32 bytes, see field 15 in 3.1 on page 140 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf -----BEGIN HSM ENCRYPTED PRIVATE KEY----- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADsIIxQY2Y9lWElrfi1CQo AAAAAAAAASYAAAAAAAAAARI06plg8upcgRqXiEj4F0LENASqTm98WZepFugMmkH2 R+7lZWKH5jIYQoJSvkEwl4oItyvlOF/rWqNEUQlNOBxowJZpH8GFGOB9aFalaKJX 99FCragt6ATlhtOFGOXECiBagZKKcyejzmaNMY6PN3Kg0jiE7YmdiMsAFNmQ6YzG GrM82l/JHdZkkDfiwxdTaTKvrtbYggJHEb/FGrRZk6g97DHmQL7Zxw30rbb/W5Az 57H86NKcgkYOHoH/UveidNVk+GS+fTADqFX5wEsa3V9xGwF7gviwpIw9jb6d8cFk ArSjSY381SPVnl8uVQBen2UQH2FtP0Aj7v/Qr3m0VKJC0ncKg3e7G3SYAik+r7D0 e0YqM/Rx7mZxwzbyUJRakeIKtHpej3d9u3YHHLjWzc1hEkfruvXH9jkD0HkoSQYc QNma2Gw7Lp5QhQjEC9/Jx+pNY9vu9Ab+YDcFWG21OVVSQEMuDXI4SnXXPaEaJd3S EuWDC+gmZb428f3ZZFDNLXEz7Wn8nwt+SpgWii0evJ2XZYuGEN2ZONin0tZPlmCq U6F226ItcbNqV5Nj3ip6whj5NdLezgJK6G6HBgxuNQIPkLS5OvkpNiSAPXTdnppf jiDVWTDRL5vvAo6r2s+CjBJ9VuAUBQRTbKNS8z7+TWdXWiBwMqk2i8jbXFS/sYte -----END HSM ENCRYPTED PRIVATE KEY----- -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEbmpq3bBLd7Was3NswJR/UMsUmqXC FCh1XnXffXaF4uYSgBQu7z3xiCkJTsp8vMBdteX10k67nJjAhP+iETO7dQQQA7CC MUGNmPZVhJa34tQkKAQgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE CMvLh3NCfueWBAgAAAAAAAAAAQQUEAEAAAABgIAAAYCAgAEACgAAAAEEIHVqtCuD l0fM3tMmINaK0GLrB6xX7M0zejZBQDpGWX/a -----END PUBLIC KEY----- Data signed Signature verified Finally, try the fourth suupported curve, P384: ./lab --ex3 --curve P384 Example output selected curve P384 with ObjectID of 1.3.132.0.34 Curve ObjectID in ASN.1 BER encoding is [6 5 43 129 4 0 34] Generated ECDSA PKCS key pair with mechanism CKM_EC_KEY_PAIR_GEN key pair public key blob length is 248 bytes key pair public key blob is [48 118 48 16 6 7 42 134 72 206 61 2 1 6 5 43 129 4 0 34 3 98 0 4 20 236 106 175 76 209 142 54 136 119 12 96 68 207 237 15 207 93 133 101 224 190 191 207 252 8 13 111 41 146 195 110 245 102 246 21 126 198 152 204 142 142 123 85 205 73 71 95 199 156 111 125 60 137 24 103 37 211 215 222 89 119 181 242 0 63 164 49 14 7 40 199 86 111 168 136 8 249 164 117 253 72 33 144 66 15 126 131 230 42 32 37 210 78 27 99 4 16 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 4 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 8 31 146 195 59 47 0 221 196 4 8 0 0 0 0 0 0 0 1 4 20 16 1 0 0 0 1 128 128 0 1 128 128 128 1 0 10 0 0 0 1 4 32 166 134 66 17 102 8 140 118 31 64 4 242 234 134 34 72 132 116 245 10 224 174 74 101 243 172 223 184 156 51 28 103] key pair private key blob length is 720 bytes key pair private key blob is [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 1 38 0 0 0 0 0 0 0 1 18 52 153 221 86 12 9 88 111 233 79 50 0 98 38 116 119 42 179 162 115 61 69 173 2 50 40 5 241 34 125 95 215 44 94 60 200 193 50 47 70 234 63 92 12 149 107 163 199 247 244 21 145 94 176 100 72 240 241 146 134 62 70 238 188 1 31 91 136 108 73 110 218 192 207 194 239 183 109 245 140 135 33 148 169 75 112 120 9 173 218 117 181 74 141 98 52 108 110 115 135 113 187 153 210 17 27 101 149 108 233 171 190 217 178 69 154 188 13 79 167 107 197 222 34 246 90 23 80 87 71 32 39 100 100 38 41 239 210 168 65 58 118 220 16 7 32 148 54 163 80 1 199 139 165 132 161 234 172 7 87 11 31 106 203 50 250 123 9 145 5 40 155 103 123 16 113 60 61 210 215 238 164 150 191 97 200 231 170 17 180 184 90 104 114 10 114 61 129 222 6 139 56 248 177 110 10 53 234 143 90 10 149 134 174 170 32 237 224 29 124 102 218 206 171 105 10 18 16 233 191 119 26 12 167 215 135 23 95 83 89 171 154 14 249 247 35 202 88 83 220 5 191 52 71 15 64 20 21 62 55 241 158 98 38 95 137 193 201 253 122 71 25 10 128 22 53 60 199 175 192 194 104 68 187 83 136 228 246 102 194 153 119 139 178 33 170 80 237 242 75 179 107 184 194 221 45 216 161 217 150 100 224 22 7 94 142 242 114 3 52 237 105 123 39 61 185 226 37 38 159 64 208 219 25 170 246 223 126 122 120 135 86 193 101 6 105 148 156 12 77 162 221 200 34 202 29 228 198 5 193 112 96 95 16 225 1 6 41 252 234 218 227 64 95 16 221 124 2 4 42 209 138 212 11 35 149 12 240 152 187 36 87 60 156 4 138 76 214 193 233 17 174 49 119 133 96 215 49 137 139 45 36 162 230 79 83 100 87 83 13 159 146 143 170 144 34 248 76 97 244 226 63 124 122 121 35 177 81 219 119 21 42 42 40 92 37 220 93 118 245 215 76 129 128 251 187 202 225 112 82 171 55 8 158 70 93 209 70 31 31 251 22 170 11 215 35 190 122 0 48 146 182 84 180 106 192 119 0 227 114 134 98 247 100 13 30 56 20 232 87 56 120 132 197 194 244 138 6 31 224 220 50 114 202 129 226 170 8 168 37 184 206 16 11 55 229 59 26 38 6 74 4 191 232 77 70 242 232 80 3 144 192 248 102 68 155 22 34 97 12 221 63 106 55 248 185 169 207 239 178 95 71 220 127 87 74 14 241 233 45 248 208 51 92 103 59 39 218 52 53 177 164 7 135 195 99 49 135 89 18 132 8 185 51 41 0 0 210 46 166 22 59 21 223 44 65 60 83 41 211 102 10 123 89 57 98 87 183 212 197 96 149 236 104 175 109 207 180 77 52 123 170 159 77 29 255 146 246 94 95 71 63 156 183 227 45 82 160 148 152 87 53 42 161 58] Some of the fields in the private key blob follow: WK ID is [3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40] See 6.7.1 of page 182 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Blob version is [18 52] See 3.1.1 on page 141 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf IV is [153 221 86 12 9 88 111 233 79 50 0 98 38 116] Encrypted part is [119 42 179 162 115 61 69 173 2 50 40 5 241 34 125 95 215 44 94 60 200 193 50 47 70 234 63 92 12 149 107 163 199 247 244 21 145 94 176 100 72 240 241 146 134 62 70 238 188 1 31 91 136 108 73 110 218 192 207 194 239 183 109 245 140 135 33 148 169 75 112 120 9 173 218 117 181 74 141 98 52 108 110 115 135 113 187 153 210 17 27 101 149 108 233 171 190 217 178 69 154 188 13 79 167 107 197 222 34 246 90 23 80 87 71 32 39 100 100 38 41 239 210 168 65 58 118 220 16 7 32 148 54 163 80 1 199 139 165 132 161 234 172 7 87 11 31 106 203 50 250 123 9 145 5 40 155 103 123 16 113 60 61 210 215 238 164 150 191 97 200 231 170 17 180 184 90 104 114 10 114 61 129 222 6 139 56 248 177 110 10 53 234 143 90 10 149 134 174 170 32 237 224 29 124 102 218 206 171 105 10 18 16 233 191 119 26 12 167 215 135 23 95 83 89 171 154 14 249 247 35 202 88 83 220 5 191 52 71 15 64 20 21 62 55 241 158 98 38 95 137 193 201 253 122 71 25 10 128 22 53 60 199 175 192 194 104 68 187 83 136 228 246 102 194 153 119 139 178 33 170 80 237 242 75 179 107 184 194 221 45 216 161 217 150 100 224 22 7 94 142 242 114 3 52 237 105 123 39 61 185 226 37 38 159 64 208 219 25 170 246 223 126 122 120 135 86 193 101 6 105 148 156 12 77 162 221 200 34 202 29 228 198 5 193 112 96 95 16 225 1 6 41 252 234 218 227 64 95 16 221 124 2 4 42 209 138 212 11 35 149 12 240 152 187 36 87 60 156 4 138 76 214 193 233 17 174 49 119 133 96 215 49 137 139 45 36 162 230 79 83 100 87 83 13 159 146 143 170 144 34 248 76 97 244 226 63 124 122 121 35 177 81 219 119 21 42 42 40 92 37 220 93 118 245 215 76 129 128 251 187 202 225 112 82 171 55 8 158 70 93 209 70 31 31 251 22 170 11 215 35 190 122 0 48 146 182 84 180 106 192 119 0 227 114 134 98 247 100 13 30 56 20 232 87 56 120 132 197 194 244 138 6 31 224 220 50 114 202 129 226 170 8 168 37 184 206 16 11 55 229 59 26 38 6 74 4 191 232 77 70 242 232 80 3 144 192 248 102 68 155 22 34 97 12 221 63 106 55 248 185 169 207 239 178 95 71 220 127 87 74 14 241 233 45 248 208 51 92 103 59 39 218 52 53 177 164 7 135 195 99 49 135 89 18 132 8 185 51 41 0 0 210 46 166 22 59 21 223 44 65 60 83 41 211 102 10 123 89 57 98 87 183 212 197 96 149 236] MAC is [104 175 109 207 180 77 52 123 170 159 77 29 255 146 246 94 95 71 63 156 183 227 45 82 160 148 152 87 53 42 161 58] MAC is 32 bytes, see field 15 in 3.1 on page 140 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf -----BEGIN HSM ENCRYPTED PRIVATE KEY----- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADsIIxQY2Y9lWElrfi1CQo AAAAAAAAASYAAAAAAAAAARI0md1WDAlYb+lPMgBiJnR3KrOicz1FrQIyKAXxIn1f 1yxePMjBMi9G6j9cDJVro8f39BWRXrBkSPDxkoY+Ru68AR9biGxJbtrAz8Lvt231 jIchlKlLcHgJrdp1tUqNYjRsbnOHcbuZ0hEbZZVs6au+2bJFmrwNT6drxd4i9loX UFdHICdkZCYp79KoQTp23BAHIJQ2o1ABx4ulhKHqrAdXCx9qyzL6ewmRBSibZ3sQ cTw90tfupJa/YcjnqhG0uFpocgpyPYHeBos4+LFuCjXqj1oKlYauqiDt4B18ZtrO q2kKEhDpv3caDKfXhxdfU1mrmg759yPKWFPcBb80Rw9AFBU+N/GeYiZficHJ/XpH GQqAFjU8x6/AwmhEu1OI5PZmwpl3i7IhqlDt8kuza7jC3S3YodmWZOAWB16O8nID NO1peyc9ueIlJp9A0NsZqvbffnp4h1bBZQZplJwMTaLdyCLKHeTGBcFwYF8Q4QEG Kfzq2uNAXxDdfAIEKtGK1AsjlQzwmLskVzycBIpM1sHpEa4xd4Vg1zGJiy0kouZP U2RXUw2fko+qkCL4TGH04j98enkjsVHbdxUqKihcJdxddvXXTIGA+7vK4XBSqzcI nkZd0UYfH/sWqgvXI756ADCStlS0asB3AONyhmL3ZA0eOBToVzh4hMXC9IoGH+Dc MnLKgeKqCKgluM4QCzflOxomBkoEv+hNRvLoUAOQwPhmRJsWImEM3T9qN/i5qc/v sl9H3H9XSg7x6S340DNcZzsn2jQ1saQHh8NjMYdZEoQIuTMpAADSLqYWOxXfLEE8 UynTZgp7WTliV7fUxWCV7Givbc+0TTR7qp9NHf+S9l5fRz+ct+MtUqCUmFc1KqE6 -----END HSM ENCRYPTED PRIVATE KEY----- -----BEGIN PUBLIC KEY----- MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEFOxqr0zRjjaIdwxgRM/tD89dhWXgvr/P /AgNbymSw271ZvYVfsaYzI6Oe1XNSUdfx5xvfTyJGGcl09feWXe18gA/pDEOByjH Vm+oiAj5pHX9SCGQQg9+g+YqICXSThtjBBADsIIxQY2Y9lWElrfi1CQoBCAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQIH5LDOy8A3cQECAAAAAAAAAAB BBQQAQAAAAGAgAABgICAAQAKAAAAAQQgpoZCEWYIjHYfQATy6oYiSIR09Qrgrkpl 86zfuJwzHGc= -----END PUBLIC KEY----- Data signed Signature verified Each of the curves had a number in its name that indicates how large the key is, in bits. We worked with 224-, 256-, 384-, and 521-bit keys (yes that is 521 bits and not 512 bits but don't ask me why- I first have to get smart enough to understand it myself before I get smart enough to explain it to you coherently- besides, I'm sure Google has the answer). I am smart enough to know that there are 8 bits in a byte and while the key lengths in cryptographic algorithms are usually expressed in bits, the lengths in our exercise output for the various blobs are expressed in bytes. And there's nothing wrong with that, because our key blobs have lots of other metadata and attributes and fields besides just the key itself. That's why I purposely referred to them as key blobs and not keys. Try this handy \"one-line script\" that runs this exercise four times, once for each curve, and then pipes the output to egrep so that we can pick out some lines of interest. You can see how the curve strength impacts the size of the public and private key blobs: for curve in P224 P256 P384 P521 ; do ./lab --ex3 --curve ${ curve } ; done | egrep -ie 'curve|key blob length' Expected Output selected curve P224 with ObjectID of 1.3.132.0.33 Curve ObjectID in ASN.1 BER encoding is [6 5 43 129 4 0 33] key pair public key blob length is 208 bytes key pair private key blob length is 544 bytes selected curve P256 with ObjectID of 1.2.840.10045.3.1.7 Curve ObjectID in ASN.1 BER encoding is [6 8 42 134 72 206 61 3 1 7] key pair public key blob length is 219 bytes key pair private key blob length is 576 bytes selected curve P384 with ObjectID of 1.3.132.0.34 Curve ObjectID in ASN.1 BER encoding is [6 5 43 129 4 0 34] key pair public key blob length is 248 bytes key pair private key blob length is 720 bytes selected curve P521 with ObjectID of 1.3.132.0.35 Curve ObjectID in ASN.1 BER encoding is [6 5 43 129 4 0 35] key pair public key blob length is 286 bytes key pair private key blob length is 896 bytes It makes sense that the larger key sizes produce bigger key blobs. If I ever figure out enough to give a full accounting of the difference in blob sizes, I'll update the lab. If you ever figure it out, please create a GitHub pull request with the answer. Let's move on to our fourth and final exercise.","title":"Exercise 3 (Sign and Verify)"},{"location":"grep11/lab-exercise3/#exercise-3-sign-and-verify-data","text":"","title":"Exercise 3 - Sign and Verify Data"},{"location":"grep11/lab-exercise3/#overview-of-exercise-3","text":"Exercise three uses public key cryptography to demonstrate signing of data and then verifying the signature. Other terms often used that are associated with public key cryptography are asymmetric keys or public and private key pairs . The major characteristic is that an asymmetric key is actually a pair of keys that are related. One key is called the public key and can be shared with anyone. The other key is called the private key and is kept secret. These key pairs can be used for encryption and decryption, as well as for creating and verifying digital signatures.","title":"Overview of Exercise 3"},{"location":"grep11/lab-exercise3/#public-key-cryptography-in-simple-terms","text":"Public key cryptography and encryption When using public key cryptography, the assumption is that anybody in the world could have your public key, but you have kept your private key to yourself. For encryption, anybody who has your public key could encrypt data with it and send you that encrypted data, or ciphertext. If an adversary possessed the ciphertext, they could not decrypt it. Only you, with your private key, can decrypt it. Technically, you could encrypt data with your private key that holders of your public key could decrypt, but this use case doesn't make sense- since anybody could have your public key, you have not managed to achieve privacy with your encryption. Public key cryptography and digital signatures Your private key can be used to allow you to digitally \"sign\" data, which is an attestation that you have seen the data that you have signed, analagous to your signing by pen a letter or contract on a piece of paper. There are different digital signature algorithms, but in general, they follow the following pattern. Assume you want to digitally sign some data you send to somebody: You create a digest, or hash, over some data, using some algorithm. This hash uniquely identifies the data. You encrypt this hash with your private key. This is your digital signature. You send the data, and your digital signature, to the intended recipient. The recipient calculates the digest, or hash, of the data, using the same algorithm that you used in step 1. If the data has remained intact in transit, they will calculate the same hash that you did in step 1. They then decrypt your signature (from step 2) with your public key. This retrieves in plaintext the hash you signed in step 2. If the hash they calculated in step 4 matches the hash that you encrypted with your private key in step 2 (and retrieved by them in step 5), then it is proof that you have seen the data they have received. The fundamental assumption is that you have kept your private key in your sole possession. If an adversary stole your private key they could impersonate you. Also, observe that the validity of this digital signature is independent of whether or not the data that you send is plaintext or ciphertext. The two most commonly used forms of public key cryptography are RSA cryptography and elliptic curve cryptography. RSA cryptography was developed first and is built upon the difficulty of factoring the product of two very large prime numbers. It is easy for a computer to find two very large prime numbers and multiply them together to obtain a product. On the other hand, given this product, it is extremely difficult, if not impossible, for even today's powerful computers to figure out what two prime numbers were used to produce that product! It seems like a preposterous statement, but it's true! Elliptic curve cryptography is based on algebraic equations called elliptic curves. The idea is that a mathematical addition function can be defined on this curve, such that it is very easy for a computer to do a large number of additions on the curve which results in a point on the curve. But if you give someone the equation for the curve, and the point on the curve that you have calculated, but you don't tell them how many additions you did to calculate this point, even today's powerful computers cannot figure out how many additions were performed! It seems like a preposterous statement, but it's true! In simple terms, an RSA public key contains the product of the two primes, and the RSA private key contains the hidden information- the two primes. An elliptic curve public key contains all of the information about the curve, including the point that was calculated, except for the number of additions used to calculate the point, while the elliptic curve private key includes the hidden information- the number of additions that were used to create the point. If I multiplied two small prime numbers like 7 x 13 and gave you the product 91, it probably wouldn't take you too long to factor it back to 7 and 13. Computers need to use incredibliy large prime numbers in order to calculate a product that another computer can't quickly factor. That is why RSA keys are usually 2048 or 4096 bits in length. You can create smaller RSA keys but today's computers can factor the product contained in the public key quicker, the smaller the key. On the other hand, the size of elliptic curve public keys can be much smaller than RSA public keys, and provide the equivalent strength. That is, a relatively small-sized elliptic curve key is just as difficult for a computer to crack by brute force than it is for a much larger-sized RSA key. For this reason, elliptic curve cryptography is becoming increasingly popular- the smaller key size means less computational power is needed to work with these keys, so they are more efficient and use less power, which is more appealing for devices that are typically drawing on battery power, like smartphones and tablets. EP11 supports both RSA and elliptic curve cryptography, as you saw in the GREP11 sample. This exercise will dig a little deeper into elliptic curves.","title":"Public key cryptography in simple terms"},{"location":"grep11/lab-exercise3/#run-exercise-3","text":"Run the third exercise: ./lab --ex3 Example Output selected curve P521 with ObjectID of 1.3.132.0.35 Curve ObjectID in ASN.1 BER encoding is [6 5 43 129 4 0 35] Generated ECDSA PKCS key pair with mechanism CKM_EC_KEY_PAIR_GEN key pair public key blob length is 286 bytes key pair public key blob is [48 129 155 48 16 6 7 42 134 72 206 61 2 1 6 5 43 129 4 0 35 3 129 134 0 4 1 251 93 197 238 11 2 165 14 39 212 27 175 77 65 78 70 252 221 242 195 236 163 3 63 184 70 158 146 51 22 230 181 30 78 101 47 150 133 100 197 101 31 144 59 192 199 237 14 94 86 237 73 52 79 1 45 220 65 57 113 117 113 173 220 70 0 48 137 50 146 141 22 219 122 151 69 232 10 132 29 121 198 108 226 233 9 117 185 16 125 236 113 235 136 54 127 109 229 150 26 117 63 231 242 158 101 248 86 80 17 69 31 217 156 122 140 30 75 132 155 187 35 148 239 49 81 172 10 210 181 169 4 16 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 4 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 8 255 72 74 131 146 172 234 187 4 8 0 0 0 0 0 0 0 1 4 20 16 1 0 0 0 1 128 128 0 1 128 128 128 1 0 10 0 0 0 1 4 32 217 93 11 148 136 24 62 138 168 213 244 131 187 81 107 102 114 120 167 70 193 179 233 4 32 228 144 160 232 167 125 167] key pair private key blob length is 896 bytes key pair private key blob is [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 1 38 0 0 0 0 0 0 0 1 18 52 145 242 100 209 252 135 97 118 108 26 68 196 204 214 35 186 208 121 174 78 194 146 179 179 92 26 100 178 30 39 144 58 232 153 47 120 177 131 143 109 255 143 188 55 83 243 168 100 93 113 176 50 33 176 209 178 137 124 13 64 217 65 230 242 127 41 206 53 149 52 238 111 241 174 206 137 141 251 17 145 233 76 219 82 103 108 35 168 57 114 44 179 164 157 12 81 167 193 171 27 42 69 50 108 161 45 227 151 199 15 59 120 177 122 62 66 95 9 115 57 85 29 132 224 146 162 177 224 143 36 125 126 210 113 18 73 145 60 48 109 176 162 41 145 33 242 93 154 122 118 216 252 111 7 253 207 195 227 151 15 112 99 44 177 14 14 193 35 199 207 79 29 219 88 146 132 3 80 128 196 150 37 18 7 192 185 68 38 158 232 84 145 198 24 210 154 34 157 76 53 244 18 31 194 99 80 36 31 225 41 141 69 135 116 43 239 186 193 84 112 103 110 56 148 66 115 76 202 125 45 15 86 124 24 19 247 208 131 51 37 186 172 94 58 155 214 238 131 253 48 86 125 62 240 123 236 237 88 76 218 21 215 202 210 90 29 119 239 2 237 11 242 202 214 116 98 88 90 15 0 12 170 20 96 132 49 224 57 22 113 123 27 19 173 121 50 99 116 175 20 153 192 223 84 121 17 154 88 74 118 245 131 21 179 162 154 44 182 15 66 240 9 154 118 1 122 101 101 103 14 207 47 167 133 152 187 147 221 241 84 223 72 136 243 239 77 65 121 219 208 223 95 175 139 39 100 52 227 185 126 22 143 41 183 28 57 63 238 117 196 172 63 131 116 248 74 165 132 160 77 148 174 44 102 91 29 49 74 230 85 215 83 154 130 46 164 163 212 85 82 103 5 205 233 181 126 160 118 154 65 120 155 89 224 218 132 99 158 134 210 225 219 252 254 167 208 170 164 148 97 226 25 236 152 47 113 74 5 73 177 157 60 120 4 62 87 17 116 190 73 132 124 17 61 46 63 12 184 8 74 177 100 119 151 58 163 126 181 199 95 202 99 112 64 55 97 66 138 83 168 62 160 62 8 160 148 126 215 124 65 228 200 122 192 129 121 18 135 244 95 4 94 0 231 246 49 195 181 35 72 161 110 97 180 135 111 33 28 173 49 235 8 58 56 217 31 159 195 61 195 34 10 160 111 224 53 22 175 9 79 39 142 46 43 91 210 69 183 229 68 114 86 142 221 196 206 234 143 244 49 236 231 253 226 95 36 14 131 74 48 31 144 4 254 235 158 189 98 28 1 100 181 19 139 69 29 166 136 227 85 21 131 130 138 197 249 29 222 65 128 252 16 217 121 157 232 150 126 54 245 116 145 127 175 167 125 46 94 214 38 224 85 172 87 97 163 231 181 218 248 103 211 224 79 122 157 160 76 54 242 13 46 182 10 105 119 6 51 91 11 116 120 2 188 148 108 191 158 100 28 40 158 212 35 94 53 6 59 84 216 207 101 112 40 178 164 252 110 116 39 59 78 78 7 204 241 147 2 234 244 153 214 32 151 187 250 112 162 173 136 214 67 114 195 102 170 240 228 160 123 41 178 7 2 147 66 5 236 100 170 198 233 8 218 163 244 224 211 8 127 36 60 220 185 158 17 171 78 156 168 141 73 86 146 47 252 55 247 12 105 21 170 199 27 69 149 217 78 89 37 125 246 220 29 177 15 18 78 153 170 123 109 248 47 4 130 121 174 88 44 96 61 71 208 112 34 236 111 189 240 195 15 45 176 84 140 35 171 110 124 164 98 0 122 173 69 82 27 118 51 226 30 193 106 51 21 83 194 189 110 18 92 156 198 221 189 211 84 220 207] Some of the fields in the private key blob follow: WK ID is [3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40] See 6.7.1 of page 182 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Blob version is [18 52] See 3.1.1 on page 141 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf IV is [145 242 100 209 252 135 97 118 108 26 68 196 204 214] Encrypted part is [35 186 208 121 174 78 194 146 179 179 92 26 100 178 30 39 144 58 232 153 47 120 177 131 143 109 255 143 188 55 83 243 168 100 93 113 176 50 33 176 209 178 137 124 13 64 217 65 230 242 127 41 206 53 149 52 238 111 241 174 206 137 141 251 17 145 233 76 219 82 103 108 35 168 57 114 44 179 164 157 12 81 167 193 171 27 42 69 50 108 161 45 227 151 199 15 59 120 177 122 62 66 95 9 115 57 85 29 132 224 146 162 177 224 143 36 125 126 210 113 18 73 145 60 48 109 176 162 41 145 33 242 93 154 122 118 216 252 111 7 253 207 195 227 151 15 112 99 44 177 14 14 193 35 199 207 79 29 219 88 146 132 3 80 128 196 150 37 18 7 192 185 68 38 158 232 84 145 198 24 210 154 34 157 76 53 244 18 31 194 99 80 36 31 225 41 141 69 135 116 43 239 186 193 84 112 103 110 56 148 66 115 76 202 125 45 15 86 124 24 19 247 208 131 51 37 186 172 94 58 155 214 238 131 253 48 86 125 62 240 123 236 237 88 76 218 21 215 202 210 90 29 119 239 2 237 11 242 202 214 116 98 88 90 15 0 12 170 20 96 132 49 224 57 22 113 123 27 19 173 121 50 99 116 175 20 153 192 223 84 121 17 154 88 74 118 245 131 21 179 162 154 44 182 15 66 240 9 154 118 1 122 101 101 103 14 207 47 167 133 152 187 147 221 241 84 223 72 136 243 239 77 65 121 219 208 223 95 175 139 39 100 52 227 185 126 22 143 41 183 28 57 63 238 117 196 172 63 131 116 248 74 165 132 160 77 148 174 44 102 91 29 49 74 230 85 215 83 154 130 46 164 163 212 85 82 103 5 205 233 181 126 160 118 154 65 120 155 89 224 218 132 99 158 134 210 225 219 252 254 167 208 170 164 148 97 226 25 236 152 47 113 74 5 73 177 157 60 120 4 62 87 17 116 190 73 132 124 17 61 46 63 12 184 8 74 177 100 119 151 58 163 126 181 199 95 202 99 112 64 55 97 66 138 83 168 62 160 62 8 160 148 126 215 124 65 228 200 122 192 129 121 18 135 244 95 4 94 0 231 246 49 195 181 35 72 161 110 97 180 135 111 33 28 173 49 235 8 58 56 217 31 159 195 61 195 34 10 160 111 224 53 22 175 9 79 39 142 46 43 91 210 69 183 229 68 114 86 142 221 196 206 234 143 244 49 236 231 253 226 95 36 14 131 74 48 31 144 4 254 235 158 189 98 28 1 100 181 19 139 69 29 166 136 227 85 21 131 130 138 197 249 29 222 65 128 252 16 217 121 157 232 150 126 54 245 116 145 127 175 167 125 46 94 214 38 224 85 172 87 97 163 231 181 218 248 103 211 224 79 122 157 160 76 54 242 13 46 182 10 105 119 6 51 91 11 116 120 2 188 148 108 191 158 100 28 40 158 212 35 94 53 6 59 84 216 207 101 112 40 178 164 252 110 116 39 59 78 78 7 204 241 147 2 234 244 153 214 32 151 187 250 112 162 173 136 214 67 114 195 102 170 240 228 160 123 41 178 7 2 147 66 5 236 100 170 198 233 8 218 163 244 224 211 8 127 36 60 220 185 158 17 171 78 156 168 141 73 86 146 47 252 55 247 12 105 21 170 199 27 69 149 217 78 89 37 125 246 220 29 177 15 18 78 153 170 123 109 248 47 4 130 121 174 88 44 96 61 71 208 112 34 236 111 189 240 195 15 45 176 84 140 35 171] MAC is [110 124 164 98 0 122 173 69 82 27 118 51 226 30 193 106 51 21 83 194 189 110 18 92 156 198 221 189 211 84 220 207] MAC is 32 bytes, see field 15 in 3.1 on page 140 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf -----BEGIN HSM ENCRYPTED PRIVATE KEY----- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADsIIxQY2Y9lWElrfi1CQo AAAAAAAAASYAAAAAAAAAARI0kfJk0fyHYXZsGkTEzNYjutB5rk7CkrOzXBpksh4n kDromS94sYOPbf+PvDdT86hkXXGwMiGw0bKJfA1A2UHm8n8pzjWVNO5v8a7OiY37 EZHpTNtSZ2wjqDlyLLOknQxRp8GrGypFMmyhLeOXxw87eLF6PkJfCXM5VR2E4JKi seCPJH1+0nESSZE8MG2woimRIfJdmnp22PxvB/3Pw+OXD3BjLLEODsEjx89PHdtY koQDUIDEliUSB8C5RCae6FSRxhjSmiKdTDX0Eh/CY1AkH+EpjUWHdCvvusFUcGdu OJRCc0zKfS0PVnwYE/fQgzMluqxeOpvW7oP9MFZ9PvB77O1YTNoV18rSWh137wLt C/LK1nRiWFoPAAyqFGCEMeA5FnF7GxOteTJjdK8UmcDfVHkRmlhKdvWDFbOimiy2 D0LwCZp2AXplZWcOzy+nhZi7k93xVN9IiPPvTUF529DfX6+LJ2Q047l+Fo8ptxw5 P+51xKw/g3T4SqWEoE2UrixmWx0xSuZV11Oagi6ko9RVUmcFzem1fqB2mkF4m1ng 2oRjnobS4dv8/qfQqqSUYeIZ7JgvcUoFSbGdPHgEPlcRdL5JhHwRPS4/DLgISrFk d5c6o361x1/KY3BAN2FCilOoPqA+CKCUftd8QeTIesCBeRKH9F8EXgDn9jHDtSNI oW5htIdvIRytMesIOjjZH5/DPcMiCqBv4DUWrwlPJ44uK1vSRbflRHJWjt3EzuqP 9DHs5/3iXyQOg0owH5AE/uuevWIcAWS1E4tFHaaI41UVg4KKxfkd3kGA/BDZeZ3o ln429XSRf6+nfS5e1ibgVaxXYaPntdr4Z9PgT3qdoEw28g0utgppdwYzWwt0eAK8 lGy/nmQcKJ7UI141BjtU2M9lcCiypPxudCc7Tk4HzPGTAur0mdYgl7v6cKKtiNZD csNmqvDkoHspsgcCk0IF7GSqxukI2qP04NMIfyQ83LmeEatOnKiNSVaSL/w39wxp FarHG0WV2U5ZJX323B2xDxJOmap7bfgvBIJ5rlgsYD1H0HAi7G+98MMPLbBUjCOr bnykYgB6rUVSG3Yz4h7BajMVU8K9bhJcnMbdvdNU3M8= -----END HSM ENCRYPTED PRIVATE KEY----- -----BEGIN PUBLIC KEY----- MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQB+13F7gsCpQ4n1BuvTUFORvzd8sPs owM/uEaekjMW5rUeTmUvloVkxWUfkDvAx+0OXlbtSTRPAS3cQTlxdXGt3EYAMIky ko0W23qXRegKhB15xmzi6Ql1uRB97HHriDZ/beWWGnU/5/KeZfhWUBFFH9mceowe S4SbuyOU7zFRrArStakEEAOwgjFBjZj2VYSWt+LUJCgEIAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAABAj/SEqDkqzquwQIAAAAAAAAAAEEFBABAAAAAYCA AAGAgIABAAoAAAABBCDZXQuUiBg+iqjV9IO7UWtmcninRsGz6QQg5JCg6Kd9pw== -----END PUBLIC KEY----- Data signed Signature verified The first line of the output shows the Object ID of the curve that was used. These Object IDs are assigned by standards bodies. The Object ID used here is 1.3.132.0.35 . Stick 1.3.132.0.35 in your favorite Google machine and see what you find. Or take my word for it that this identifies the secp521r1 curve. The second line of the output shows ASN.1 BER encoding of 1.3.132.0.35, which is 6 5 43 129 4 0 35 . If you were to look up how ASN.1 BER encoding works, your first question would be, \"Why?\". Don't go there now. But I bring it up because you will notice that a few lines down in the output, in the key pair public key blob section, you'll see that encoded string, 6 5 43 129 4 0 35 , about 14 bytes from the beginning. In fact, while the whole point of using the GREP11 server and the Crypto Express 7S cards is to keep secrets from an adversary, the information shown in the key pair public key blob section is \"in the clear\"- you could give this to your adversary without fear of having your secrets compromised. The list of decimal bytes of these keys is mostly gibberish to us humans, I'm not sure why I even bothered to print them out, but take a look at the output at the end, where there are several lines between a header and footer for HSM ENCRYPTED PRIVATE KEY (BEGIN and END), and several lines between a header and footer for a PUBLIC KEY. To use these keys in the future, you would need to persist both of these to separate files. You wouldn't have a reason to give your adversary the HSM ENCRYPTED PRIVATE KEY, but, if he did obtain it, it would be of no value to him unless he was able to access your Crypto Express 7S card that had the same root wrapping key. The contents of this file are encrypted and are usuable only within the Crypto Express card that created it, or in another Crypto Express card that had the same root wrapping key. Since the PUBLIC KEY is, by definition, shareable with the world, we can use the common openssl utility to look at it. Try it like this: Copy the lines from near the bottom of your output that have your public key , including the BEGIN PUBLIC KEY and END PUBLIC KEY header and footer lines, and the dashes, into your clipboard In a terminal window, type echo \" (that is a single pair of double-quotes) and then paste your clipboard contents onto the command line Type \" | openssl ec -in - -pubin -noout -text and then press Enter You should see output similar to this: read EC key Public-Key: (521 bit) pub: 04:00:59:fe:0c:b3:d0:6e:b2:d7:b0:c0:05:86:66: dd:62:bc:fe:96:5c:fa:08:6d:f3:be:5f:6d:a1:3d: 8f:40:13:83:23:ec:34:e4:e5:20:6c:f9:75:34:bd: 30:cd:be:1f:5b:aa:ee:44:99:d9:ae:69:50:24:c7: 82:7c:f4:f2:18:d1:b0:00:be:5c:64:f5:dd:16:79: eb:d4:9c:28:ae:43:9b:f4:13:a4:f3:db:3c:a2:e5: 52:bb:0f:9f:e1:c4:a4:c1:29:63:4e:bc:2f:73:4c: da:fd:4f:42:63:0d:3d:9d:bb:29:76:57:85:13:57: 3a:ae:8f:20:64:0a:cf:c2:f1:41:d3:fc:8a ASN1 OID: secp521r1 NIST CURVE: P-521 Tip If you are a Linux guru you could create a file with vi and copy the key into the file, and then provide that as input to the openssl command, e.g., openssl ec -in baz -pubin -noout -text if baz was the file you created. In the exercise output I first printed the public key as an array of decimal numbers (worthless!), then I printed it in PEM-encoded format (boring!) but now you see the key in hexadecimal format (that's incredible!!). You also get the added bonus of knowing it's a legit public key since the openssl utility made sense of it. Try using a different curve: ./lab --ex3 --curve P224 Example Output selected curve P224 with ObjectID of 1.3.132.0.33 Curve ObjectID in ASN.1 BER encoding is [6 5 43 129 4 0 33] Generated ECDSA PKCS key pair with mechanism CKM_EC_KEY_PAIR_GEN key pair public key blob length is 208 bytes key pair public key blob is [48 78 48 16 6 7 42 134 72 206 61 2 1 6 5 43 129 4 0 33 3 58 0 4 177 164 170 83 241 4 140 49 236 115 12 22 130 206 48 90 174 181 135 16 59 31 11 122 14 254 13 172 129 64 249 1 40 44 231 155 52 110 38 67 175 244 45 81 157 5 213 125 224 199 126 65 251 200 159 53 4 16 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 4 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 8 6 63 231 63 240 230 179 88 4 8 0 0 0 0 0 0 0 1 4 20 16 1 0 0 0 1 128 128 0 1 128 128 128 1 0 10 0 0 0 1 4 32 90 61 58 127 30 244 119 154 65 27 170 14 182 232 45 237 92 61 188 238 138 237 84 7 5 209 228 172 195 235 219 189] key pair private key blob length is 544 bytes key pair private key blob is [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 1 38 0 0 0 0 0 0 0 1 18 52 1 7 210 186 20 15 180 182 68 217 17 251 23 142 218 85 206 228 75 16 37 108 9 47 216 5 160 29 100 235 78 164 63 25 232 181 251 214 113 69 26 198 9 222 119 149 66 64 233 183 172 93 96 41 223 99 201 110 138 227 51 26 197 166 9 8 190 40 129 254 49 89 54 38 209 21 60 137 118 113 174 145 254 145 152 119 73 114 11 144 41 25 106 152 140 167 192 88 82 199 100 234 18 255 129 213 111 25 126 2 200 3 44 90 252 84 48 191 106 98 2 77 78 7 165 189 227 52 167 78 188 5 185 254 178 206 180 171 47 110 54 38 87 16 191 167 134 237 48 49 153 168 54 225 251 75 223 3 55 239 48 119 76 89 103 20 30 222 104 167 219 210 46 17 75 224 196 191 55 238 236 156 205 119 182 199 12 58 144 248 124 216 181 38 11 17 139 144 123 31 108 76 171 91 154 112 6 160 188 2 181 110 212 46 66 153 211 21 184 1 51 194 12 245 73 155 192 206 80 213 51 187 166 3 207 127 151 127 59 158 192 7 92 113 247 118 108 55 217 84 183 34 24 144 57 215 193 96 179 93 2 190 84 85 119 199 179 96 119 2 9 160 231 251 214 187 5 206 224 207 111 52 58 181 131 237 11 245 106 181 223 217 240 98 162 190 11 116 18 46 225 218 17 130 79 19 4 171 94 129 197 59 201 54 63 31 60 90 84 225 223 121 94 173 42 103 3 204 128 187 143 209 78 80 151 157 90 44 76 20 254 18 96 197 70 36 135 24 13 156 77 112 196 22 35 123 199 169 17 195 156 0 212 50 140 50 126 70 132 126 149 172 94 173 49 156 173 207 208 109 166 88 148 204 25 122 119 58 130 215 130 101 13 235 96 29 210 130 229 51 232 250 206 124 162 68 112 3 191 129 184 195 34 186 72 103 159 228 155 244 43 108 205 37 82 176 243 200 233 88 91 31 243 33 232 44 178 19 57 182 239 63 238 130 33 1 127 250 215 109 121 187 134 218 173 74 112 88 230 152 90 147 20 43 28 254 173 28 25 255 0 147 78 51 231 175 190 29] Some of the fields in the private key blob follow: WK ID is [3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40] See 6.7.1 of page 182 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Blob version is [18 52] See 3.1.1 on page 141 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf IV is [1 7 210 186 20 15 180 182 68 217 17 251 23 142] Encrypted part is [218 85 206 228 75 16 37 108 9 47 216 5 160 29 100 235 78 164 63 25 232 181 251 214 113 69 26 198 9 222 119 149 66 64 233 183 172 93 96 41 223 99 201 110 138 227 51 26 197 166 9 8 190 40 129 254 49 89 54 38 209 21 60 137 118 113 174 145 254 145 152 119 73 114 11 144 41 25 106 152 140 167 192 88 82 199 100 234 18 255 129 213 111 25 126 2 200 3 44 90 252 84 48 191 106 98 2 77 78 7 165 189 227 52 167 78 188 5 185 254 178 206 180 171 47 110 54 38 87 16 191 167 134 237 48 49 153 168 54 225 251 75 223 3 55 239 48 119 76 89 103 20 30 222 104 167 219 210 46 17 75 224 196 191 55 238 236 156 205 119 182 199 12 58 144 248 124 216 181 38 11 17 139 144 123 31 108 76 171 91 154 112 6 160 188 2 181 110 212 46 66 153 211 21 184 1 51 194 12 245 73 155 192 206 80 213 51 187 166 3 207 127 151 127 59 158 192 7 92 113 247 118 108 55 217 84 183 34 24 144 57 215 193 96 179 93 2 190 84 85 119 199 179 96 119 2 9 160 231 251 214 187 5 206 224 207 111 52 58 181 131 237 11 245 106 181 223 217 240 98 162 190 11 116 18 46 225 218 17 130 79 19 4 171 94 129 197 59 201 54 63 31 60 90 84 225 223 121 94 173 42 103 3 204 128 187 143 209 78 80 151 157 90 44 76 20 254 18 96 197 70 36 135 24 13 156 77 112 196 22 35 123 199 169 17 195 156 0 212 50 140 50 126 70 132 126 149 172 94 173 49 156 173 207 208 109 166 88 148 204 25 122 119 58 130 215 130 101 13 235 96 29 210 130 229 51 232 250 206 124 162 68 112 3 191 129 184 195 34 186 72 103 159 228 155 244 43 108 205 37 82 176 243 200 233 88 91 31 243 33 232 44 178 19 57 182 239 63 238 130 33 1] MAC is [127 250 215 109 121 187 134 218 173 74 112 88 230 152 90 147 20 43 28 254 173 28 25 255 0 147 78 51 231 175 190 29] MAC is 32 bytes, see field 15 in 3.1 on page 140 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf -----BEGIN HSM ENCRYPTED PRIVATE KEY----- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADsIIxQY2Y9lWElrfi1CQo AAAAAAAAASYAAAAAAAAAARI0AQfSuhQPtLZE2RH7F47aVc7kSxAlbAkv2AWgHWTr TqQ/Gei1+9ZxRRrGCd53lUJA6besXWAp32PJborjMxrFpgkIviiB/jFZNibRFTyJ dnGukf6RmHdJcguQKRlqmIynwFhSx2TqEv+B1W8ZfgLIAyxa/FQwv2piAk1OB6W9 4zSnTrwFuf6yzrSrL242JlcQv6eG7TAxmag24ftL3wM37zB3TFlnFB7eaKfb0i4R S+DEvzfu7JzNd7bHDDqQ+HzYtSYLEYuQex9sTKtbmnAGoLwCtW7ULkKZ0xW4ATPC DPVJm8DOUNUzu6YDz3+XfzuewAdccfd2bDfZVLciGJA518Fgs10CvlRVd8ezYHcC CaDn+9a7Bc7gz280OrWD7Qv1arXf2fBior4LdBIu4doRgk8TBKtegcU7yTY/Hzxa VOHfeV6tKmcDzIC7j9FOUJedWixMFP4SYMVGJIcYDZxNcMQWI3vHqRHDnADUMowy fkaEfpWsXq0xnK3P0G2mWJTMGXp3OoLXgmUN62Ad0oLlM+j6znyiRHADv4G4wyK6 SGef5Jv0K2zNJVKw88jpWFsf8yHoLLITObbvP+6CIQF/+tdtebuG2q1KcFjmmFqT FCsc/q0cGf8Ak04z56++HQ== -----END HSM ENCRYPTED PRIVATE KEY----- -----BEGIN PUBLIC KEY----- ME4wEAYHKoZIzj0CAQYFK4EEACEDOgAEsaSqU/EEjDHscwwWgs4wWq61hxA7Hwt6 Dv4NrIFA+QEoLOebNG4mQ6/0LVGdBdV94Md+QfvInzUEEAOwgjFBjZj2VYSWt+LU JCgEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAgGP+c/8OazWAQI AAAAAAAAAAEEFBABAAAAAYCAAAGAgIABAAoAAAABBCBaPTp/HvR3mkEbqg626C3t XD287ortVAcF0eSsw+vbvQ== -----END PUBLIC KEY----- Data signed Signature verified Try the P256 curve: ./lab --ex3 --curve P256 Example output selected curve P256 with ObjectID of 1.2.840.10045.3.1.7 Curve ObjectID in ASN.1 BER encoding is [6 8 42 134 72 206 61 3 1 7] Generated ECDSA PKCS key pair with mechanism CKM_EC_KEY_PAIR_GEN key pair public key blob length is 219 bytes key pair public key blob is [48 89 48 19 6 7 42 134 72 206 61 2 1 6 8 42 134 72 206 61 3 1 7 3 66 0 4 110 106 106 221 176 75 119 181 154 179 115 108 192 148 127 80 203 20 154 165 194 20 40 117 94 117 223 125 118 133 226 230 18 128 20 46 239 61 241 136 41 9 78 202 124 188 192 93 181 229 245 210 78 187 156 152 192 132 255 162 17 51 187 117 4 16 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 4 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 8 203 203 135 115 66 126 231 150 4 8 0 0 0 0 0 0 0 1 4 20 16 1 0 0 0 1 128 128 0 1 128 128 128 1 0 10 0 0 0 1 4 32 117 106 180 43 131 151 71 204 222 211 38 32 214 138 208 98 235 7 172 87 236 205 51 122 54 65 64 58 70 89 127 218] key pair private key blob length is 576 bytes key pair private key blob is [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 1 38 0 0 0 0 0 0 0 1 18 52 234 153 96 242 234 92 129 26 151 136 72 248 23 66 196 52 4 170 78 111 124 89 151 169 22 232 12 154 65 246 71 238 229 101 98 135 230 50 24 66 130 82 190 65 48 151 138 8 183 43 229 56 95 235 90 163 68 81 9 77 56 28 104 192 150 105 31 193 133 24 224 125 104 86 165 104 162 87 247 209 66 173 168 45 232 4 229 134 211 133 24 229 196 10 32 90 129 146 138 115 39 163 206 102 141 49 142 143 55 114 160 210 56 132 237 137 157 136 203 0 20 217 144 233 140 198 26 179 60 218 95 201 29 214 100 144 55 226 195 23 83 105 50 175 174 214 216 130 2 71 17 191 197 26 180 89 147 168 61 236 49 230 64 190 217 199 13 244 173 182 255 91 144 51 231 177 252 232 210 156 130 70 14 30 129 255 82 247 162 116 213 100 248 100 190 125 48 3 168 85 249 192 75 26 221 95 113 27 1 123 130 248 176 164 140 61 141 190 157 241 193 100 2 180 163 73 141 252 213 35 213 158 95 46 85 0 94 159 101 16 31 97 109 63 64 35 238 255 208 175 121 180 84 162 66 210 119 10 131 119 187 27 116 152 2 41 62 175 176 244 123 70 42 51 244 113 238 102 113 195 54 242 80 148 90 145 226 10 180 122 94 143 119 125 187 118 7 28 184 214 205 205 97 18 71 235 186 245 199 246 57 3 208 121 40 73 6 28 64 217 154 216 108 59 46 158 80 133 8 196 11 223 201 199 234 77 99 219 238 244 6 254 96 55 5 88 109 181 57 85 82 64 67 46 13 114 56 74 117 215 61 161 26 37 221 210 18 229 131 11 232 38 101 190 54 241 253 217 100 80 205 45 113 51 237 105 252 159 11 126 74 152 22 138 45 30 188 157 151 101 139 134 16 221 153 56 216 167 210 214 79 150 96 170 83 161 118 219 162 45 113 179 106 87 147 99 222 42 122 194 24 249 53 210 222 206 2 74 232 110 135 6 12 110 53 2 15 144 180 185 58 249 41 54 36 128 61 116 221 158 154 95 142 32 213 89 48 209 47 155 239 2 142 171 218 207 130 140 18 125 86 224 20 5 4 83 108 163 82 243 62 254 77 103 87 90 32 112 50 169 54 139 200 219 92 84 191 177 139 94] Some of the fields in the private key blob follow: WK ID is [3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40] See 6.7.1 of page 182 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Blob version is [18 52] See 3.1.1 on page 141 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf IV is [234 153 96 242 234 92 129 26 151 136 72 248 23 66] Encrypted part is [196 52 4 170 78 111 124 89 151 169 22 232 12 154 65 246 71 238 229 101 98 135 230 50 24 66 130 82 190 65 48 151 138 8 183 43 229 56 95 235 90 163 68 81 9 77 56 28 104 192 150 105 31 193 133 24 224 125 104 86 165 104 162 87 247 209 66 173 168 45 232 4 229 134 211 133 24 229 196 10 32 90 129 146 138 115 39 163 206 102 141 49 142 143 55 114 160 210 56 132 237 137 157 136 203 0 20 217 144 233 140 198 26 179 60 218 95 201 29 214 100 144 55 226 195 23 83 105 50 175 174 214 216 130 2 71 17 191 197 26 180 89 147 168 61 236 49 230 64 190 217 199 13 244 173 182 255 91 144 51 231 177 252 232 210 156 130 70 14 30 129 255 82 247 162 116 213 100 248 100 190 125 48 3 168 85 249 192 75 26 221 95 113 27 1 123 130 248 176 164 140 61 141 190 157 241 193 100 2 180 163 73 141 252 213 35 213 158 95 46 85 0 94 159 101 16 31 97 109 63 64 35 238 255 208 175 121 180 84 162 66 210 119 10 131 119 187 27 116 152 2 41 62 175 176 244 123 70 42 51 244 113 238 102 113 195 54 242 80 148 90 145 226 10 180 122 94 143 119 125 187 118 7 28 184 214 205 205 97 18 71 235 186 245 199 246 57 3 208 121 40 73 6 28 64 217 154 216 108 59 46 158 80 133 8 196 11 223 201 199 234 77 99 219 238 244 6 254 96 55 5 88 109 181 57 85 82 64 67 46 13 114 56 74 117 215 61 161 26 37 221 210 18 229 131 11 232 38 101 190 54 241 253 217 100 80 205 45 113 51 237 105 252 159 11 126 74 152 22 138 45 30 188 157 151 101 139 134 16 221 153 56 216 167 210 214 79 150 96 170 83 161 118 219 162 45 113 179 106 87 147 99 222 42 122 194 24 249 53 210 222 206 2 74 232 110 135 6 12 110 53 2 15 144 180 185 58 249 41 54 36 128 61 116 221 158 154 95 142 32 213 89 48 209 47 155 239 2 142 171 218 207 130 140] MAC is [18 125 86 224 20 5 4 83 108 163 82 243 62 254 77 103 87 90 32 112 50 169 54 139 200 219 92 84 191 177 139 94] MAC is 32 bytes, see field 15 in 3.1 on page 140 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf -----BEGIN HSM ENCRYPTED PRIVATE KEY----- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADsIIxQY2Y9lWElrfi1CQo AAAAAAAAASYAAAAAAAAAARI06plg8upcgRqXiEj4F0LENASqTm98WZepFugMmkH2 R+7lZWKH5jIYQoJSvkEwl4oItyvlOF/rWqNEUQlNOBxowJZpH8GFGOB9aFalaKJX 99FCragt6ATlhtOFGOXECiBagZKKcyejzmaNMY6PN3Kg0jiE7YmdiMsAFNmQ6YzG GrM82l/JHdZkkDfiwxdTaTKvrtbYggJHEb/FGrRZk6g97DHmQL7Zxw30rbb/W5Az 57H86NKcgkYOHoH/UveidNVk+GS+fTADqFX5wEsa3V9xGwF7gviwpIw9jb6d8cFk ArSjSY381SPVnl8uVQBen2UQH2FtP0Aj7v/Qr3m0VKJC0ncKg3e7G3SYAik+r7D0 e0YqM/Rx7mZxwzbyUJRakeIKtHpej3d9u3YHHLjWzc1hEkfruvXH9jkD0HkoSQYc QNma2Gw7Lp5QhQjEC9/Jx+pNY9vu9Ab+YDcFWG21OVVSQEMuDXI4SnXXPaEaJd3S EuWDC+gmZb428f3ZZFDNLXEz7Wn8nwt+SpgWii0evJ2XZYuGEN2ZONin0tZPlmCq U6F226ItcbNqV5Nj3ip6whj5NdLezgJK6G6HBgxuNQIPkLS5OvkpNiSAPXTdnppf jiDVWTDRL5vvAo6r2s+CjBJ9VuAUBQRTbKNS8z7+TWdXWiBwMqk2i8jbXFS/sYte -----END HSM ENCRYPTED PRIVATE KEY----- -----BEGIN PUBLIC KEY----- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEbmpq3bBLd7Was3NswJR/UMsUmqXC FCh1XnXffXaF4uYSgBQu7z3xiCkJTsp8vMBdteX10k67nJjAhP+iETO7dQQQA7CC MUGNmPZVhJa34tQkKAQgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE CMvLh3NCfueWBAgAAAAAAAAAAQQUEAEAAAABgIAAAYCAgAEACgAAAAEEIHVqtCuD l0fM3tMmINaK0GLrB6xX7M0zejZBQDpGWX/a -----END PUBLIC KEY----- Data signed Signature verified Finally, try the fourth suupported curve, P384: ./lab --ex3 --curve P384 Example output selected curve P384 with ObjectID of 1.3.132.0.34 Curve ObjectID in ASN.1 BER encoding is [6 5 43 129 4 0 34] Generated ECDSA PKCS key pair with mechanism CKM_EC_KEY_PAIR_GEN key pair public key blob length is 248 bytes key pair public key blob is [48 118 48 16 6 7 42 134 72 206 61 2 1 6 5 43 129 4 0 34 3 98 0 4 20 236 106 175 76 209 142 54 136 119 12 96 68 207 237 15 207 93 133 101 224 190 191 207 252 8 13 111 41 146 195 110 245 102 246 21 126 198 152 204 142 142 123 85 205 73 71 95 199 156 111 125 60 137 24 103 37 211 215 222 89 119 181 242 0 63 164 49 14 7 40 199 86 111 168 136 8 249 164 117 253 72 33 144 66 15 126 131 230 42 32 37 210 78 27 99 4 16 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 4 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 8 31 146 195 59 47 0 221 196 4 8 0 0 0 0 0 0 0 1 4 20 16 1 0 0 0 1 128 128 0 1 128 128 128 1 0 10 0 0 0 1 4 32 166 134 66 17 102 8 140 118 31 64 4 242 234 134 34 72 132 116 245 10 224 174 74 101 243 172 223 184 156 51 28 103] key pair private key blob length is 720 bytes key pair private key blob is [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 1 38 0 0 0 0 0 0 0 1 18 52 153 221 86 12 9 88 111 233 79 50 0 98 38 116 119 42 179 162 115 61 69 173 2 50 40 5 241 34 125 95 215 44 94 60 200 193 50 47 70 234 63 92 12 149 107 163 199 247 244 21 145 94 176 100 72 240 241 146 134 62 70 238 188 1 31 91 136 108 73 110 218 192 207 194 239 183 109 245 140 135 33 148 169 75 112 120 9 173 218 117 181 74 141 98 52 108 110 115 135 113 187 153 210 17 27 101 149 108 233 171 190 217 178 69 154 188 13 79 167 107 197 222 34 246 90 23 80 87 71 32 39 100 100 38 41 239 210 168 65 58 118 220 16 7 32 148 54 163 80 1 199 139 165 132 161 234 172 7 87 11 31 106 203 50 250 123 9 145 5 40 155 103 123 16 113 60 61 210 215 238 164 150 191 97 200 231 170 17 180 184 90 104 114 10 114 61 129 222 6 139 56 248 177 110 10 53 234 143 90 10 149 134 174 170 32 237 224 29 124 102 218 206 171 105 10 18 16 233 191 119 26 12 167 215 135 23 95 83 89 171 154 14 249 247 35 202 88 83 220 5 191 52 71 15 64 20 21 62 55 241 158 98 38 95 137 193 201 253 122 71 25 10 128 22 53 60 199 175 192 194 104 68 187 83 136 228 246 102 194 153 119 139 178 33 170 80 237 242 75 179 107 184 194 221 45 216 161 217 150 100 224 22 7 94 142 242 114 3 52 237 105 123 39 61 185 226 37 38 159 64 208 219 25 170 246 223 126 122 120 135 86 193 101 6 105 148 156 12 77 162 221 200 34 202 29 228 198 5 193 112 96 95 16 225 1 6 41 252 234 218 227 64 95 16 221 124 2 4 42 209 138 212 11 35 149 12 240 152 187 36 87 60 156 4 138 76 214 193 233 17 174 49 119 133 96 215 49 137 139 45 36 162 230 79 83 100 87 83 13 159 146 143 170 144 34 248 76 97 244 226 63 124 122 121 35 177 81 219 119 21 42 42 40 92 37 220 93 118 245 215 76 129 128 251 187 202 225 112 82 171 55 8 158 70 93 209 70 31 31 251 22 170 11 215 35 190 122 0 48 146 182 84 180 106 192 119 0 227 114 134 98 247 100 13 30 56 20 232 87 56 120 132 197 194 244 138 6 31 224 220 50 114 202 129 226 170 8 168 37 184 206 16 11 55 229 59 26 38 6 74 4 191 232 77 70 242 232 80 3 144 192 248 102 68 155 22 34 97 12 221 63 106 55 248 185 169 207 239 178 95 71 220 127 87 74 14 241 233 45 248 208 51 92 103 59 39 218 52 53 177 164 7 135 195 99 49 135 89 18 132 8 185 51 41 0 0 210 46 166 22 59 21 223 44 65 60 83 41 211 102 10 123 89 57 98 87 183 212 197 96 149 236 104 175 109 207 180 77 52 123 170 159 77 29 255 146 246 94 95 71 63 156 183 227 45 82 160 148 152 87 53 42 161 58] Some of the fields in the private key blob follow: WK ID is [3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40] See 6.7.1 of page 182 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf Blob version is [18 52] See 3.1.1 on page 141 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf IV is [153 221 86 12 9 88 111 233 79 50 0 98 38 116] Encrypted part is [119 42 179 162 115 61 69 173 2 50 40 5 241 34 125 95 215 44 94 60 200 193 50 47 70 234 63 92 12 149 107 163 199 247 244 21 145 94 176 100 72 240 241 146 134 62 70 238 188 1 31 91 136 108 73 110 218 192 207 194 239 183 109 245 140 135 33 148 169 75 112 120 9 173 218 117 181 74 141 98 52 108 110 115 135 113 187 153 210 17 27 101 149 108 233 171 190 217 178 69 154 188 13 79 167 107 197 222 34 246 90 23 80 87 71 32 39 100 100 38 41 239 210 168 65 58 118 220 16 7 32 148 54 163 80 1 199 139 165 132 161 234 172 7 87 11 31 106 203 50 250 123 9 145 5 40 155 103 123 16 113 60 61 210 215 238 164 150 191 97 200 231 170 17 180 184 90 104 114 10 114 61 129 222 6 139 56 248 177 110 10 53 234 143 90 10 149 134 174 170 32 237 224 29 124 102 218 206 171 105 10 18 16 233 191 119 26 12 167 215 135 23 95 83 89 171 154 14 249 247 35 202 88 83 220 5 191 52 71 15 64 20 21 62 55 241 158 98 38 95 137 193 201 253 122 71 25 10 128 22 53 60 199 175 192 194 104 68 187 83 136 228 246 102 194 153 119 139 178 33 170 80 237 242 75 179 107 184 194 221 45 216 161 217 150 100 224 22 7 94 142 242 114 3 52 237 105 123 39 61 185 226 37 38 159 64 208 219 25 170 246 223 126 122 120 135 86 193 101 6 105 148 156 12 77 162 221 200 34 202 29 228 198 5 193 112 96 95 16 225 1 6 41 252 234 218 227 64 95 16 221 124 2 4 42 209 138 212 11 35 149 12 240 152 187 36 87 60 156 4 138 76 214 193 233 17 174 49 119 133 96 215 49 137 139 45 36 162 230 79 83 100 87 83 13 159 146 143 170 144 34 248 76 97 244 226 63 124 122 121 35 177 81 219 119 21 42 42 40 92 37 220 93 118 245 215 76 129 128 251 187 202 225 112 82 171 55 8 158 70 93 209 70 31 31 251 22 170 11 215 35 190 122 0 48 146 182 84 180 106 192 119 0 227 114 134 98 247 100 13 30 56 20 232 87 56 120 132 197 194 244 138 6 31 224 220 50 114 202 129 226 170 8 168 37 184 206 16 11 55 229 59 26 38 6 74 4 191 232 77 70 242 232 80 3 144 192 248 102 68 155 22 34 97 12 221 63 106 55 248 185 169 207 239 178 95 71 220 127 87 74 14 241 233 45 248 208 51 92 103 59 39 218 52 53 177 164 7 135 195 99 49 135 89 18 132 8 185 51 41 0 0 210 46 166 22 59 21 223 44 65 60 83 41 211 102 10 123 89 57 98 87 183 212 197 96 149 236] MAC is [104 175 109 207 180 77 52 123 170 159 77 29 255 146 246 94 95 71 63 156 183 227 45 82 160 148 152 87 53 42 161 58] MAC is 32 bytes, see field 15 in 3.1 on page 140 of http://public.dhe.ibm.com/security/cryptocards/pciecc4/EP11/docs/ep11-structure.pdf -----BEGIN HSM ENCRYPTED PRIVATE KEY----- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADsIIxQY2Y9lWElrfi1CQo AAAAAAAAASYAAAAAAAAAARI0md1WDAlYb+lPMgBiJnR3KrOicz1FrQIyKAXxIn1f 1yxePMjBMi9G6j9cDJVro8f39BWRXrBkSPDxkoY+Ru68AR9biGxJbtrAz8Lvt231 jIchlKlLcHgJrdp1tUqNYjRsbnOHcbuZ0hEbZZVs6au+2bJFmrwNT6drxd4i9loX UFdHICdkZCYp79KoQTp23BAHIJQ2o1ABx4ulhKHqrAdXCx9qyzL6ewmRBSibZ3sQ cTw90tfupJa/YcjnqhG0uFpocgpyPYHeBos4+LFuCjXqj1oKlYauqiDt4B18ZtrO q2kKEhDpv3caDKfXhxdfU1mrmg759yPKWFPcBb80Rw9AFBU+N/GeYiZficHJ/XpH GQqAFjU8x6/AwmhEu1OI5PZmwpl3i7IhqlDt8kuza7jC3S3YodmWZOAWB16O8nID NO1peyc9ueIlJp9A0NsZqvbffnp4h1bBZQZplJwMTaLdyCLKHeTGBcFwYF8Q4QEG Kfzq2uNAXxDdfAIEKtGK1AsjlQzwmLskVzycBIpM1sHpEa4xd4Vg1zGJiy0kouZP U2RXUw2fko+qkCL4TGH04j98enkjsVHbdxUqKihcJdxddvXXTIGA+7vK4XBSqzcI nkZd0UYfH/sWqgvXI756ADCStlS0asB3AONyhmL3ZA0eOBToVzh4hMXC9IoGH+Dc MnLKgeKqCKgluM4QCzflOxomBkoEv+hNRvLoUAOQwPhmRJsWImEM3T9qN/i5qc/v sl9H3H9XSg7x6S340DNcZzsn2jQ1saQHh8NjMYdZEoQIuTMpAADSLqYWOxXfLEE8 UynTZgp7WTliV7fUxWCV7Givbc+0TTR7qp9NHf+S9l5fRz+ct+MtUqCUmFc1KqE6 -----END HSM ENCRYPTED PRIVATE KEY----- -----BEGIN PUBLIC KEY----- MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEFOxqr0zRjjaIdwxgRM/tD89dhWXgvr/P /AgNbymSw271ZvYVfsaYzI6Oe1XNSUdfx5xvfTyJGGcl09feWXe18gA/pDEOByjH Vm+oiAj5pHX9SCGQQg9+g+YqICXSThtjBBADsIIxQY2Y9lWElrfi1CQoBCAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQIH5LDOy8A3cQECAAAAAAAAAAB BBQQAQAAAAGAgAABgICAAQAKAAAAAQQgpoZCEWYIjHYfQATy6oYiSIR09Qrgrkpl 86zfuJwzHGc= -----END PUBLIC KEY----- Data signed Signature verified Each of the curves had a number in its name that indicates how large the key is, in bits. We worked with 224-, 256-, 384-, and 521-bit keys (yes that is 521 bits and not 512 bits but don't ask me why- I first have to get smart enough to understand it myself before I get smart enough to explain it to you coherently- besides, I'm sure Google has the answer). I am smart enough to know that there are 8 bits in a byte and while the key lengths in cryptographic algorithms are usually expressed in bits, the lengths in our exercise output for the various blobs are expressed in bytes. And there's nothing wrong with that, because our key blobs have lots of other metadata and attributes and fields besides just the key itself. That's why I purposely referred to them as key blobs and not keys. Try this handy \"one-line script\" that runs this exercise four times, once for each curve, and then pipes the output to egrep so that we can pick out some lines of interest. You can see how the curve strength impacts the size of the public and private key blobs: for curve in P224 P256 P384 P521 ; do ./lab --ex3 --curve ${ curve } ; done | egrep -ie 'curve|key blob length' Expected Output selected curve P224 with ObjectID of 1.3.132.0.33 Curve ObjectID in ASN.1 BER encoding is [6 5 43 129 4 0 33] key pair public key blob length is 208 bytes key pair private key blob length is 544 bytes selected curve P256 with ObjectID of 1.2.840.10045.3.1.7 Curve ObjectID in ASN.1 BER encoding is [6 8 42 134 72 206 61 3 1 7] key pair public key blob length is 219 bytes key pair private key blob length is 576 bytes selected curve P384 with ObjectID of 1.3.132.0.34 Curve ObjectID in ASN.1 BER encoding is [6 5 43 129 4 0 34] key pair public key blob length is 248 bytes key pair private key blob length is 720 bytes selected curve P521 with ObjectID of 1.3.132.0.35 Curve ObjectID in ASN.1 BER encoding is [6 5 43 129 4 0 35] key pair public key blob length is 286 bytes key pair private key blob length is 896 bytes It makes sense that the larger key sizes produce bigger key blobs. If I ever figure out enough to give a full accounting of the difference in blob sizes, I'll update the lab. If you ever figure it out, please create a GitHub pull request with the answer. Let's move on to our fourth and final exercise.","title":"Run Exercise 3"},{"location":"grep11/lab-exercise4/","text":"Exercise 4 - Wrap and Unwrap a Key \u00b6 Overview of Exercise 4 \u00b6 Data that is not encrypted is referred to as plaintext. Data that is encrypted is referred to as ciphertext. Whether this data is human readable text, like this sentence, or binary data (like a lot of the output in our exercises!), or whatever, is usually of little concern to encryption and decryption algorithms. The input is just a bunch of bits- either 1 or 0 . Keys themselves are just a bunch of bits- 1 's and 0 's. Can you encrypt and decrypt keys with other keys? You sure can. There's nothing magical about that. But, like all disciplines, cryptographers have special terms for encrypting and decrypting keys- they use the term wrapping a key to refer to encrypting a key, and unwrapping a key refers to decrypting a key. There are valid reasons to make the distinction- for example, the PKCS #11 standard allows you to assign attributes to keys, and you can create keys such that they can or cannot wrap or unwrap keys, and you may wish to create different keys for different purposes. In fact, it is considered best practice to not use the same key to encrypt both data and keys, so using different terminology- encrypting data versus wrapping keys allows for easier separation of duties and may make key management easier. In this exercise, the following use case will be demonstrated- securely transmitting a secret key so that both parties have the same secret key and can use it for encryption during a session: Sender wishes to send a secret (i.e., symmetric) key to a recipient. Sender generates a secret key and wraps it with the recipient's public key Sender sends the wrapped key to the recipient- this is safe since it is wrapped with the recipient's public key Recipient receives the wrapped key, and unwraps it with her private key Run Exercise 4 \u00b6 Run the fourth exercise: ./lab --ex4 Example Output Generated AES key Generated PKCS RSA key pair the AES key prior to being wrapped is: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 141 37 0 0 0 0 0 0 0 1 18 52 228 123 210 48 148 72 67 55 62 73 210 121 66 247 116 178 245 24 106 221 115 156 71 47 218 46 103 246 124 74 119 150 39 244 103 45 22 196 216 35 98 215 63 143 111 10 217 35 1 34 26 127 84 98 120 216 45 88 92 129 231 135 244 57 118 125 8 141 119 168 29 141 122 29 224 59 1 244 174 182 103 220 131 195 114 27 143 94 112 118 185 49 140 147 51 10 26 16 150 95 130 1 239 21 212 148 246 182 10 159 243 69 233 30 202 254 52 241 146 79 66 44 9 199 32 56 113 169 227 133 51 177 98 204 240 57 244 188 254 99 38 243 227 153 119 170 28 38 109 86 197 175 193 64 255 113 106 40 94 90 204 5 241 135 72 79 76 42 166 180 59 93 91 62 94 248 153 138 201 11 2 155 224 41 66 230 89 253 94 74] the checksum of the AES key is: [147 241 235] the AES key has been wrapped with a PKCS RSA Public Key The AES key has been unwrapped with the PKCS Private Key corresponding to the PKCS Public Key we used to wrap it with. the AES key after being wrapped and unwrapped is: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 12 0 0 0 0 0 0 0 0 1 18 52 206 249 87 66 227 239 81 119 120 21 113 29 123 27 2 52 241 6 31 39 195 183 118 39 98 185 255 179 31 44 217 72 38 56 126 190 23 230 112 120 180 74 27 118 70 9 145 247 109 197 15 92 126 232 161 192 140 63 241 178 29 188 70 79 29 240 6 39 76 22 244 149 99 241 220 160 157 40 58 42 255 121 3 181 9 118 15 96 170 49 208 117 127 248 187 202 226 92 76 198 142 164 39 85 247 74 203 28 50 106 162 144 217 93 110 120 157 126 106 37 202 133 10 133 162 89 201 186 210 12 93 124 74 231 120 172 149 134 196 232 247 5 228 92 146 119 245 115 107 124 153 218 87 65 119 80 131 101 53 219 210 111 107 216 117 6 45 153 176 221 49 121 208 77 164 68 230 219 190 45 238 82 201 112 126 205 97 110 201 187 28 240 134 33 223 206 209 45 207 159 132 178 222 232 63 160] the checksum of the unwrapped AES key is: [147 241 235 0 0 1 0] I mentioned in the overview of this exercise that you can assign attributes to keys when you create them. The code for this exercise, by default, assigns an attribute that allows the public key it creates to wrap keys, and it assigns an attribute to the private key to allow it to unwrap keys. Run this command which will cause the program to set the applicable attribute for the private key such that it is not allowed to unwrap a key. Observe in the output that, while the wrap operation proceeds, the unwrap fails: ./lab --ex4 --unwrap = false Example output Generated AES key Generated PKCS RSA key pair the AES key prior to being wrapped is: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 141 37 0 0 0 0 0 0 0 1 18 52 120 27 243 16 225 139 153 149 120 188 137 72 50 120 131 243 65 98 62 77 65 60 178 184 93 56 192 2 202 179 211 210 240 252 246 171 56 100 172 203 61 233 216 102 186 60 207 208 1 173 188 223 4 45 199 93 159 251 80 32 171 131 10 228 235 131 98 191 70 58 116 218 179 225 62 235 136 76 246 39 55 21 247 126 181 47 3 130 64 70 198 91 136 21 133 177 138 190 118 139 183 195 32 110 107 230 101 253 127 40 171 124 1 146 32 138 11 148 175 180 54 21 123 51 144 234 167 228 218 128 47 74 26 203 250 95 110 208 47 245 229 198 164 121 76 226 138 122 31 168 169 251 74 149 174 62 88 86 122 204 149 195 200 41 139 250 0 242 226 34 193 78 32 151 250 220 249 249 106 106 231 217 34 139 118 29 206 140 217 75] the checksum of the AES key is: [79 136 190] the AES key has been wrapped with a PKCS RSA Public Key panic: Unwrap AES key error: rpc error: code = Unknown desc = CKR_KEY_FUNCTION_NOT_PERMITTED goroutine 1 [running]: main.wrapAndUnwrapKey(0xc420030001) /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/lab/exercise4.go:110 +0x1543 main.main() /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/lab/main.go:79 +0x35e This command will cause the public key to be created without the ability to wrap a key. The command will fail when trying to wrap the key: ./lab --ex4 --wrap = false Example output Generated AES key Generated PKCS RSA key pair the AES key prior to being wrapped is: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 141 37 0 0 0 0 0 0 0 1 18 52 94 240 28 56 111 164 179 172 71 8 202 169 163 165 249 244 192 122 26 215 148 231 8 62 1 127 152 148 45 31 45 189 172 0 97 131 35 17 231 104 88 103 196 2 96 167 213 198 9 62 10 241 154 128 94 206 4 229 36 89 125 38 231 94 155 212 43 90 44 253 221 170 164 83 13 228 232 156 205 205 183 65 252 45 183 191 75 243 56 130 64 170 140 197 150 91 224 229 88 47 185 97 138 145 93 241 181 206 4 141 225 214 249 62 21 4 83 105 12 209 109 187 124 171 112 222 107 44 203 204 240 23 236 60 27 190 248 201 189 3 112 89 163 28 91 254 220 95 74 11 247 137 54 107 93 106 21 199 166 152 208 200 151 220 233 4 125 105 139 235 83 211 121 166 15 209 229 173 92 2 74 50 107 41 73 150 197 116 162 37] the checksum of the AES key is: [229 2 226] panic: Wrap AES key error: rpc error: code = Unknown desc = CKR_KEY_FUNCTION_NOT_PERMITTED goroutine 1 [running]: main.wrapAndUnwrapKey(0xc420030100) /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/lab/exercise4.go:90 +0x1553 main.main() /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/lab/main.go:79 +0x35e Note The public key has been prevented from wrapping a key, but it could still be used to encrypt data. Congratulations for reaching the end of the lab! We hope you have gotten a taste of the functionality offered by the Crypto Express cards and made accessible to you via the GREP11 server feature of Hyper Protect Virtual Servers. And if you know a bit more about security after doing this lab than you did before, we're pleased about that! We welome your suggestions for improvements or enhancements to the lab. Please do not forget to take your survey for the Webinar and your survey about your Workshop Manager/SkyTap experience. Here is the link for the Workshop Manager/SkyTap survey: Workshop Manager survey","title":"Exercise 4 (Wrap and Unwrap Key)"},{"location":"grep11/lab-exercise4/#exercise-4-wrap-and-unwrap-a-key","text":"","title":"Exercise 4 - Wrap and Unwrap a Key"},{"location":"grep11/lab-exercise4/#overview-of-exercise-4","text":"Data that is not encrypted is referred to as plaintext. Data that is encrypted is referred to as ciphertext. Whether this data is human readable text, like this sentence, or binary data (like a lot of the output in our exercises!), or whatever, is usually of little concern to encryption and decryption algorithms. The input is just a bunch of bits- either 1 or 0 . Keys themselves are just a bunch of bits- 1 's and 0 's. Can you encrypt and decrypt keys with other keys? You sure can. There's nothing magical about that. But, like all disciplines, cryptographers have special terms for encrypting and decrypting keys- they use the term wrapping a key to refer to encrypting a key, and unwrapping a key refers to decrypting a key. There are valid reasons to make the distinction- for example, the PKCS #11 standard allows you to assign attributes to keys, and you can create keys such that they can or cannot wrap or unwrap keys, and you may wish to create different keys for different purposes. In fact, it is considered best practice to not use the same key to encrypt both data and keys, so using different terminology- encrypting data versus wrapping keys allows for easier separation of duties and may make key management easier. In this exercise, the following use case will be demonstrated- securely transmitting a secret key so that both parties have the same secret key and can use it for encryption during a session: Sender wishes to send a secret (i.e., symmetric) key to a recipient. Sender generates a secret key and wraps it with the recipient's public key Sender sends the wrapped key to the recipient- this is safe since it is wrapped with the recipient's public key Recipient receives the wrapped key, and unwraps it with her private key","title":"Overview of Exercise 4"},{"location":"grep11/lab-exercise4/#run-exercise-4","text":"Run the fourth exercise: ./lab --ex4 Example Output Generated AES key Generated PKCS RSA key pair the AES key prior to being wrapped is: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 141 37 0 0 0 0 0 0 0 1 18 52 228 123 210 48 148 72 67 55 62 73 210 121 66 247 116 178 245 24 106 221 115 156 71 47 218 46 103 246 124 74 119 150 39 244 103 45 22 196 216 35 98 215 63 143 111 10 217 35 1 34 26 127 84 98 120 216 45 88 92 129 231 135 244 57 118 125 8 141 119 168 29 141 122 29 224 59 1 244 174 182 103 220 131 195 114 27 143 94 112 118 185 49 140 147 51 10 26 16 150 95 130 1 239 21 212 148 246 182 10 159 243 69 233 30 202 254 52 241 146 79 66 44 9 199 32 56 113 169 227 133 51 177 98 204 240 57 244 188 254 99 38 243 227 153 119 170 28 38 109 86 197 175 193 64 255 113 106 40 94 90 204 5 241 135 72 79 76 42 166 180 59 93 91 62 94 248 153 138 201 11 2 155 224 41 66 230 89 253 94 74] the checksum of the AES key is: [147 241 235] the AES key has been wrapped with a PKCS RSA Public Key The AES key has been unwrapped with the PKCS Private Key corresponding to the PKCS Public Key we used to wrap it with. the AES key after being wrapped and unwrapped is: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 12 0 0 0 0 0 0 0 0 1 18 52 206 249 87 66 227 239 81 119 120 21 113 29 123 27 2 52 241 6 31 39 195 183 118 39 98 185 255 179 31 44 217 72 38 56 126 190 23 230 112 120 180 74 27 118 70 9 145 247 109 197 15 92 126 232 161 192 140 63 241 178 29 188 70 79 29 240 6 39 76 22 244 149 99 241 220 160 157 40 58 42 255 121 3 181 9 118 15 96 170 49 208 117 127 248 187 202 226 92 76 198 142 164 39 85 247 74 203 28 50 106 162 144 217 93 110 120 157 126 106 37 202 133 10 133 162 89 201 186 210 12 93 124 74 231 120 172 149 134 196 232 247 5 228 92 146 119 245 115 107 124 153 218 87 65 119 80 131 101 53 219 210 111 107 216 117 6 45 153 176 221 49 121 208 77 164 68 230 219 190 45 238 82 201 112 126 205 97 110 201 187 28 240 134 33 223 206 209 45 207 159 132 178 222 232 63 160] the checksum of the unwrapped AES key is: [147 241 235 0 0 1 0] I mentioned in the overview of this exercise that you can assign attributes to keys when you create them. The code for this exercise, by default, assigns an attribute that allows the public key it creates to wrap keys, and it assigns an attribute to the private key to allow it to unwrap keys. Run this command which will cause the program to set the applicable attribute for the private key such that it is not allowed to unwrap a key. Observe in the output that, while the wrap operation proceeds, the unwrap fails: ./lab --ex4 --unwrap = false Example output Generated AES key Generated PKCS RSA key pair the AES key prior to being wrapped is: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 141 37 0 0 0 0 0 0 0 1 18 52 120 27 243 16 225 139 153 149 120 188 137 72 50 120 131 243 65 98 62 77 65 60 178 184 93 56 192 2 202 179 211 210 240 252 246 171 56 100 172 203 61 233 216 102 186 60 207 208 1 173 188 223 4 45 199 93 159 251 80 32 171 131 10 228 235 131 98 191 70 58 116 218 179 225 62 235 136 76 246 39 55 21 247 126 181 47 3 130 64 70 198 91 136 21 133 177 138 190 118 139 183 195 32 110 107 230 101 253 127 40 171 124 1 146 32 138 11 148 175 180 54 21 123 51 144 234 167 228 218 128 47 74 26 203 250 95 110 208 47 245 229 198 164 121 76 226 138 122 31 168 169 251 74 149 174 62 88 86 122 204 149 195 200 41 139 250 0 242 226 34 193 78 32 151 250 220 249 249 106 106 231 217 34 139 118 29 206 140 217 75] the checksum of the AES key is: [79 136 190] the AES key has been wrapped with a PKCS RSA Public Key panic: Unwrap AES key error: rpc error: code = Unknown desc = CKR_KEY_FUNCTION_NOT_PERMITTED goroutine 1 [running]: main.wrapAndUnwrapKey(0xc420030001) /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/lab/exercise4.go:110 +0x1543 main.main() /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/lab/main.go:79 +0x35e This command will cause the public key to be created without the ability to wrap a key. The command will fail when trying to wrap the key: ./lab --ex4 --wrap = false Example output Generated AES key Generated PKCS RSA key pair the AES key prior to being wrapped is: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 176 130 49 65 141 152 246 85 132 150 183 226 212 36 40 0 0 0 0 0 0 141 37 0 0 0 0 0 0 0 1 18 52 94 240 28 56 111 164 179 172 71 8 202 169 163 165 249 244 192 122 26 215 148 231 8 62 1 127 152 148 45 31 45 189 172 0 97 131 35 17 231 104 88 103 196 2 96 167 213 198 9 62 10 241 154 128 94 206 4 229 36 89 125 38 231 94 155 212 43 90 44 253 221 170 164 83 13 228 232 156 205 205 183 65 252 45 183 191 75 243 56 130 64 170 140 197 150 91 224 229 88 47 185 97 138 145 93 241 181 206 4 141 225 214 249 62 21 4 83 105 12 209 109 187 124 171 112 222 107 44 203 204 240 23 236 60 27 190 248 201 189 3 112 89 163 28 91 254 220 95 74 11 247 137 54 107 93 106 21 199 166 152 208 200 151 220 233 4 125 105 139 235 83 211 121 166 15 209 229 173 92 2 74 50 107 41 73 150 197 116 162 37] the checksum of the AES key is: [229 2 226] panic: Wrap AES key error: rpc error: code = Unknown desc = CKR_KEY_FUNCTION_NOT_PERMITTED goroutine 1 [running]: main.wrapAndUnwrapKey(0xc420030100) /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/lab/exercise4.go:90 +0x1553 main.main() /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/lab/main.go:79 +0x35e Note The public key has been prevented from wrapping a key, but it could still be used to encrypt data. Congratulations for reaching the end of the lab! We hope you have gotten a taste of the functionality offered by the Crypto Express cards and made accessible to you via the GREP11 server feature of Hyper Protect Virtual Servers. And if you know a bit more about security after doing this lab than you did before, we're pleased about that! We welome your suggestions for improvements or enhancements to the lab. Please do not forget to take your survey for the Webinar and your survey about your Workshop Manager/SkyTap experience. Here is the link for the Workshop Manager/SkyTap survey: Workshop Manager survey","title":"Run Exercise 4"},{"location":"grep11/overview/","text":"IBM Hyper Protect Virtual Servers GREP11 Overview \u00b6 You will be working with the GREP11 feature of the Hyper Protect Virtual Servers on-premises offering. GREP11 is a shorthand term for gRPC protocol-based Enterprise PKCS#11 . PKCS #11 refers to the Public Key Cryptography Standard #11 Cryptographic Token Interface , which is a standard for devices that hold cryptographic information and perform cryptographic functions. gRPC stands for Google Remote Procedure Call, which is a protocol developed by Google, and contributed to open source. gRPC uses HTTP/2 for its transport protocol. Enterprise PKCS#11 , often referred to as EP11 , refers to IBM's library , designed for enterprise usage, that is very similar to the PKCS #11 standard. The PKCS #11 standard covers the following cryptographic categories, and the GREP11 library provides functions in each of these categories: Encryption Decryption Message digests (also known as hashes) Signing and MACing (Message Authentication Codes) Verifying signatures and MACs Key Management- creating symmetric keys, creating asymmetric keys, wrapping and unwrapping keys, and deriving keys from other keys Random number generation - strictly speaking not a cryptographic operation unto itself, but random numbers are often used in cryptographic operations Environment \u00b6 You will be working with the Hyper Protect Virtual Servers command line interface (CLI) running on an x86_64 virtual machine running the Ubuntu 18.04.4 Linux distribution. You will also be using this virtual machine to run programs, written in the Go programming language, that will communicate with the GREP11 server. The GREP11 server runs as a Docker container running in a Hyper Protect Virtual Servers LPAR that runs as a Secure Service Container (SSC) LPAR on an IBM z15 server in the IBM Washington Systems Center in Herndon, Virginia, USA. The Hyper Protect Virtual Servers LPAR is in a private network at the IBM Washington Systems Center and your Ubuntu virtual machine communicates with it through a VPN connection. The details about how you can connect by using the VPN will be shared with you by email Note The client program code used here could also be run on the s390x architecture. IBM provides sample client code, which connects to a GREP11 Server, in two programming languages - Go and JavaScript , both of which are supported on s390x. The client code is written in Go. What has been done for you already \u00b6 Our starting point is having the GREP11 servers running on our Hyper Protect Virtual Servers LPAR. Each GREP11 server is connected to a single domain on an IBM Crypto Express 7S card that is configured to our LPAR. Our Hyper Protect Virtual Servers LPAR has two Crypto Expess 7S cards configured to it, with one domain on each card dedicated to our LPAR. The GREP11 servers are already provisioned. We will describe the process of setting this up so that you will have a reference. Detailed Process \u00b6 Read about how we configured the GREP11 servers. Issue relevant Hyper Protect Virtual Servers CLI commands. Clone the GitHub repository. Run Hyper Protect Virtual Servers commands to inspect the GREP11 setup. Run the GREP11 samples that IBM documentation points to. Run custom exercises that go into greater depth.","title":"IBM Hyper Protect Virtual Servers GREP11 Overview"},{"location":"grep11/overview/#ibm-hyper-protect-virtual-servers-grep11-overview","text":"You will be working with the GREP11 feature of the Hyper Protect Virtual Servers on-premises offering. GREP11 is a shorthand term for gRPC protocol-based Enterprise PKCS#11 . PKCS #11 refers to the Public Key Cryptography Standard #11 Cryptographic Token Interface , which is a standard for devices that hold cryptographic information and perform cryptographic functions. gRPC stands for Google Remote Procedure Call, which is a protocol developed by Google, and contributed to open source. gRPC uses HTTP/2 for its transport protocol. Enterprise PKCS#11 , often referred to as EP11 , refers to IBM's library , designed for enterprise usage, that is very similar to the PKCS #11 standard. The PKCS #11 standard covers the following cryptographic categories, and the GREP11 library provides functions in each of these categories: Encryption Decryption Message digests (also known as hashes) Signing and MACing (Message Authentication Codes) Verifying signatures and MACs Key Management- creating symmetric keys, creating asymmetric keys, wrapping and unwrapping keys, and deriving keys from other keys Random number generation - strictly speaking not a cryptographic operation unto itself, but random numbers are often used in cryptographic operations","title":"IBM Hyper Protect Virtual Servers GREP11 Overview"},{"location":"grep11/overview/#environment","text":"You will be working with the Hyper Protect Virtual Servers command line interface (CLI) running on an x86_64 virtual machine running the Ubuntu 18.04.4 Linux distribution. You will also be using this virtual machine to run programs, written in the Go programming language, that will communicate with the GREP11 server. The GREP11 server runs as a Docker container running in a Hyper Protect Virtual Servers LPAR that runs as a Secure Service Container (SSC) LPAR on an IBM z15 server in the IBM Washington Systems Center in Herndon, Virginia, USA. The Hyper Protect Virtual Servers LPAR is in a private network at the IBM Washington Systems Center and your Ubuntu virtual machine communicates with it through a VPN connection. The details about how you can connect by using the VPN will be shared with you by email Note The client program code used here could also be run on the s390x architecture. IBM provides sample client code, which connects to a GREP11 Server, in two programming languages - Go and JavaScript , both of which are supported on s390x. The client code is written in Go.","title":"Environment"},{"location":"grep11/overview/#what-has-been-done-for-you-already","text":"Our starting point is having the GREP11 servers running on our Hyper Protect Virtual Servers LPAR. Each GREP11 server is connected to a single domain on an IBM Crypto Express 7S card that is configured to our LPAR. Our Hyper Protect Virtual Servers LPAR has two Crypto Expess 7S cards configured to it, with one domain on each card dedicated to our LPAR. The GREP11 servers are already provisioned. We will describe the process of setting this up so that you will have a reference.","title":"What has been done for you already"},{"location":"grep11/overview/#detailed-process","text":"Read about how we configured the GREP11 servers. Issue relevant Hyper Protect Virtual Servers CLI commands. Clone the GitHub repository. Run Hyper Protect Virtual Servers commands to inspect the GREP11 setup. Run the GREP11 samples that IBM documentation points to. Run custom exercises that go into greater depth.","title":"Detailed Process"},{"location":"grep11/run-grep11-samples/","text":"Run the GREP11 Sample code \u00b6 Clone the GitHub repository which has the source code \u00b6 Change to the /home/hyper-protect-lab/go/src/github.com/ibm-developer directory cd ${ HOME } /go/src/github.com/ibm-developer Ensure you are in the directory mentioned in the prior step 1 . You may be able to tell from the command prompt. You can also enter the pwd (\"print working directory\") to be sure, e.g.,: pwd Example Output /home/hyper-protect-lab/go/src/github.com/ibm-developer Clone the GitHub repository used in this lab: git clone https://github.com/silliman/ibm-cloud-hyperprotectcrypto.git Example Output Cloning into 'ibm-cloud-hyperprotectcrypto'... remote: Enumerating objects: 821, done. remote: Counting objects: 100% (821/821), done. remote: Compressing objects: 100% (551/551), done. remote: Total 821 (delta 227), reused 821 (delta 227), pack-reused 0 Receiving objects: 100% (821/821), 9.30 MiB | 8.42 MiB/s, done. Resolving deltas: 100% (227/227), done. Change to the ibm-cloud-hyperprotectcrypto directory which the prior git clone command created: cd ibm-cloud-hyperprotectcrypto Tip Use the pwd command if you cannot already tell by your command prompt that you are in the /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto directory. Run the GREP11 sample code \u00b6 Start your code editor (Visual Studio Code is the code editor used in the examples provided, you can use any code editor of your choice) within your current directory: code . # if typing by hand don't forget the period (for current directory) In a moment you should see the Visual Studio Code window with your current directory structure shown in the Explorer pane in the upper left corner of the window: Expand the golang folder, and then expand the examples folder underneath it. Your Explorer pane should then look similar to this: From the Visual Studio Code menu, select View then Terminal , as shown below: You will see a terminal appear within Visual Studio Code at the bottom: Tip If you hover your mouse over the line above the terminal, when it turns into the \"double arrow\" as highlighted in the above screen snippet, you can drag the line to resize your terminal window. This tip may come in handy for you during the course of the lab. Change to the golang/examples directory within the Visual Studio Code terminal that you just opened: cd golang/examples Your terminal will look like this: Tip I have shown you how to use the Terminal window with Visual Studio Code, which you may find convenient. Your Ubuntu Desktop also provides a Terminal application that you can use to open one or more terminal windows. They behave the same, and which one you use is a personal choice, as long as you are in the correct directory that the instructions expect you to be in. It is convenient to have a terminal window inside Visual Studio Code, but it comes at the expense of some screen real estate being taken away from the source code used in the exercises. Use whichever method works best for you. Test the GREP11 sample code: go test -v Example Output === RUN Example_getMechanismInfo --- PASS: Example_getMechanismInfo (0.29s) === RUN Example_encryptAndDecrypt --- PASS: Example_encryptAndDecrypt (0.84s) === RUN Example_digest --- PASS: Example_digest (0.55s) === RUN Example_signAndVerifyUsingRSAKeyPair --- PASS: Example_signAndVerifyUsingRSAKeyPair (0.50s) === RUN Example_signAndVerifyUsingECDSAKeyPair --- PASS: Example_signAndVerifyUsingECDSAKeyPair (0.52s) === RUN Example_signAndVerifyToTestErrorHandling --- PASS: Example_signAndVerifyToTestErrorHandling (0.51s) === RUN Example_wrapAndUnwrapKey --- PASS: Example_wrapAndUnwrapKey (0.41s) === RUN Example_deriveKey --- PASS: Example_deriveKey (0.61s) === RUN Example_tls --- PASS: Example_tls (0.40s) PASS ok github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/examples 4.653s Explanation of GREP11 sample code \u00b6 The test used the go test subcommand, which does the following: It looks for any file in the current directory named something _test.go. There are two such files in our directory, server_test.go and tls_test.go . It looks for functions in these files named Example_ something , and executes these functions. At the bottom of each of these functions, a series of comment lines, starting with a header line, specifies what the expected output from the function should be. If the output from the function call matches the lines (except for the header line), then the test passes. Otherwise the test fails. In the explorer pane, click on server_test.go or tls_test.go and examine the source code to see these lines. For example, lines 222-227 in server_test.go indicate what the expected output of the Example_encryptAndDecrypt function should be: // Output: // Generated AES Key // Generated IV // Encrypted message // Decrypted message // Hello, this is a very long and creative message without any imagination Note Go is a compiled language, and there are no executable files in this directory- the 'go test' command compiles the source code in the directory into an executable file in order to run the tests, and then cleans up afterwards by removing this executable. Here is an itemization of the functions that our go test -v command tested, with a brief description of each. Our lab exercises in the subsequent sections will go into a little more depth on some of the more interesting of these functions. Example_getMechanismInfo gets a list of PKCS #11 Mechanisms and then retrieves information about one of them. We will delve deeper into this in the first exercise. Example_encryptAndDecrypt creates a secret (i.e., symmetric) key, encrypts data with it, then decrypts it, and ensures the data was unchanged after going through the encryption and decryption. We will look more into this in the second exercise. Example_digest creates a digest 2 , or hash, against some data. Digests are used in digital signatures, which the next two tests cover. Example_signAndVerifyUsingRSAKeyPair creates an RSA public and private key pair and uses the private key to create a digital signature and the public key to verify the digital signature. Example_signAndVerifyUsingECDSAKeyPair creates an elliptic curve public and private key pair and uses the private key to create a digital signature and uses the public key to verify the digital signature. We go into greater depth (and discuss the differences between RSA and Elliptic Curves) in the third exercise. Example_signAndVerifyToTestErrorHandling intentionally causes an error- after a signature is created, the program modifies a byte in it, so that when the signature is verified later, an error occurs. The test passes because the expected error message is listed in the expected test output. Example_wrapAndUnwrapKey creates a public and private key pair and uses the public key to encrypt, or wrap, a symmetric key, which can then only be decrypted, or unwrapped, by the private key. The fourth and final exercise covers this topic. Example_deriveKey illustrates a common algorithm where two sides of a connection each have a public and private key pair, and they use each other's public key in an algorithm that allows each of them to derive an identical secret, i.e., symmetric, key, without ever having sent that secret key across the connection. This is a common use case because encryption and decryption with a symmetric key is much faster than encryption and decryption with public and private keys. The two parties use relatively slow public key cryptography to derive this shared symmetric key at the beginning of their session, and then switch to using this symmetric key for the remainder of the session. This function and all of the functions preceding it in this list are in the server_test.go source file. Example_tls creates an X.509 certificate, starts up an http server that uses this certificate, and has a client connect to the server with TLS authentication, which uses this certificate to establish a session. This test is in the tls_test.go source file. Please proceed to the next section. The Go compiler has traditionally been very picky about where source code files must reside. This situation has eased recently with the introduction of Go modules in newer releases, but our lab is not using Go modules. Go expects to find source files in the ${GOPATH}/src directory hierarchy, and if you do not have the GOPATH environment variable set, it expects fo find source files in the ${HOME}/go/src directory hierarchy. \u21a9 A hash is a fixed-length fingerprint for a set of input data of any size. Since there are an infinite number of possible input combinations, and the hash is fixed-length, in theory two different sets of data could produce the same hash. This is called a collision . In practice, the hash is of sufficient size, and the algorithm to produce it sufficiently complex, that it is computationally infeasible to produce the same hash with two different sets of input. If it can be demonstrated that two different sets of input can produce the same fingerprint by a hashing algorithm, then that algorithm will be considered insecure and fall into disuse in favor of stronger hashing algorithms. \u21a9","title":"Running the GREP11 sample code"},{"location":"grep11/run-grep11-samples/#run-the-grep11-sample-code","text":"","title":"Run the GREP11 Sample code"},{"location":"grep11/run-grep11-samples/#clone-the-github-repository-which-has-the-source-code","text":"Change to the /home/hyper-protect-lab/go/src/github.com/ibm-developer directory cd ${ HOME } /go/src/github.com/ibm-developer Ensure you are in the directory mentioned in the prior step 1 . You may be able to tell from the command prompt. You can also enter the pwd (\"print working directory\") to be sure, e.g.,: pwd Example Output /home/hyper-protect-lab/go/src/github.com/ibm-developer Clone the GitHub repository used in this lab: git clone https://github.com/silliman/ibm-cloud-hyperprotectcrypto.git Example Output Cloning into 'ibm-cloud-hyperprotectcrypto'... remote: Enumerating objects: 821, done. remote: Counting objects: 100% (821/821), done. remote: Compressing objects: 100% (551/551), done. remote: Total 821 (delta 227), reused 821 (delta 227), pack-reused 0 Receiving objects: 100% (821/821), 9.30 MiB | 8.42 MiB/s, done. Resolving deltas: 100% (227/227), done. Change to the ibm-cloud-hyperprotectcrypto directory which the prior git clone command created: cd ibm-cloud-hyperprotectcrypto Tip Use the pwd command if you cannot already tell by your command prompt that you are in the /home/hyper-protect-lab/go/src/github.com/ibm-developer/ibm-cloud-hyperprotectcrypto directory.","title":"Clone the GitHub repository which has the source code"},{"location":"grep11/run-grep11-samples/#run-the-grep11-sample-code_1","text":"Start your code editor (Visual Studio Code is the code editor used in the examples provided, you can use any code editor of your choice) within your current directory: code . # if typing by hand don't forget the period (for current directory) In a moment you should see the Visual Studio Code window with your current directory structure shown in the Explorer pane in the upper left corner of the window: Expand the golang folder, and then expand the examples folder underneath it. Your Explorer pane should then look similar to this: From the Visual Studio Code menu, select View then Terminal , as shown below: You will see a terminal appear within Visual Studio Code at the bottom: Tip If you hover your mouse over the line above the terminal, when it turns into the \"double arrow\" as highlighted in the above screen snippet, you can drag the line to resize your terminal window. This tip may come in handy for you during the course of the lab. Change to the golang/examples directory within the Visual Studio Code terminal that you just opened: cd golang/examples Your terminal will look like this: Tip I have shown you how to use the Terminal window with Visual Studio Code, which you may find convenient. Your Ubuntu Desktop also provides a Terminal application that you can use to open one or more terminal windows. They behave the same, and which one you use is a personal choice, as long as you are in the correct directory that the instructions expect you to be in. It is convenient to have a terminal window inside Visual Studio Code, but it comes at the expense of some screen real estate being taken away from the source code used in the exercises. Use whichever method works best for you. Test the GREP11 sample code: go test -v Example Output === RUN Example_getMechanismInfo --- PASS: Example_getMechanismInfo (0.29s) === RUN Example_encryptAndDecrypt --- PASS: Example_encryptAndDecrypt (0.84s) === RUN Example_digest --- PASS: Example_digest (0.55s) === RUN Example_signAndVerifyUsingRSAKeyPair --- PASS: Example_signAndVerifyUsingRSAKeyPair (0.50s) === RUN Example_signAndVerifyUsingECDSAKeyPair --- PASS: Example_signAndVerifyUsingECDSAKeyPair (0.52s) === RUN Example_signAndVerifyToTestErrorHandling --- PASS: Example_signAndVerifyToTestErrorHandling (0.51s) === RUN Example_wrapAndUnwrapKey --- PASS: Example_wrapAndUnwrapKey (0.41s) === RUN Example_deriveKey --- PASS: Example_deriveKey (0.61s) === RUN Example_tls --- PASS: Example_tls (0.40s) PASS ok github.com/ibm-developer/ibm-cloud-hyperprotectcrypto/golang/examples 4.653s","title":"Run the GREP11 sample code"},{"location":"grep11/run-grep11-samples/#explanation-of-grep11-sample-code","text":"The test used the go test subcommand, which does the following: It looks for any file in the current directory named something _test.go. There are two such files in our directory, server_test.go and tls_test.go . It looks for functions in these files named Example_ something , and executes these functions. At the bottom of each of these functions, a series of comment lines, starting with a header line, specifies what the expected output from the function should be. If the output from the function call matches the lines (except for the header line), then the test passes. Otherwise the test fails. In the explorer pane, click on server_test.go or tls_test.go and examine the source code to see these lines. For example, lines 222-227 in server_test.go indicate what the expected output of the Example_encryptAndDecrypt function should be: // Output: // Generated AES Key // Generated IV // Encrypted message // Decrypted message // Hello, this is a very long and creative message without any imagination Note Go is a compiled language, and there are no executable files in this directory- the 'go test' command compiles the source code in the directory into an executable file in order to run the tests, and then cleans up afterwards by removing this executable. Here is an itemization of the functions that our go test -v command tested, with a brief description of each. Our lab exercises in the subsequent sections will go into a little more depth on some of the more interesting of these functions. Example_getMechanismInfo gets a list of PKCS #11 Mechanisms and then retrieves information about one of them. We will delve deeper into this in the first exercise. Example_encryptAndDecrypt creates a secret (i.e., symmetric) key, encrypts data with it, then decrypts it, and ensures the data was unchanged after going through the encryption and decryption. We will look more into this in the second exercise. Example_digest creates a digest 2 , or hash, against some data. Digests are used in digital signatures, which the next two tests cover. Example_signAndVerifyUsingRSAKeyPair creates an RSA public and private key pair and uses the private key to create a digital signature and the public key to verify the digital signature. Example_signAndVerifyUsingECDSAKeyPair creates an elliptic curve public and private key pair and uses the private key to create a digital signature and uses the public key to verify the digital signature. We go into greater depth (and discuss the differences between RSA and Elliptic Curves) in the third exercise. Example_signAndVerifyToTestErrorHandling intentionally causes an error- after a signature is created, the program modifies a byte in it, so that when the signature is verified later, an error occurs. The test passes because the expected error message is listed in the expected test output. Example_wrapAndUnwrapKey creates a public and private key pair and uses the public key to encrypt, or wrap, a symmetric key, which can then only be decrypted, or unwrapped, by the private key. The fourth and final exercise covers this topic. Example_deriveKey illustrates a common algorithm where two sides of a connection each have a public and private key pair, and they use each other's public key in an algorithm that allows each of them to derive an identical secret, i.e., symmetric, key, without ever having sent that secret key across the connection. This is a common use case because encryption and decryption with a symmetric key is much faster than encryption and decryption with public and private keys. The two parties use relatively slow public key cryptography to derive this shared symmetric key at the beginning of their session, and then switch to using this symmetric key for the remainder of the session. This function and all of the functions preceding it in this list are in the server_test.go source file. Example_tls creates an X.509 certificate, starts up an http server that uses this certificate, and has a client connect to the server with TLS authentication, which uses this certificate to establish a session. This test is in the tls_test.go source file. Please proceed to the next section. The Go compiler has traditionally been very picky about where source code files must reside. This situation has eased recently with the introduction of Go modules in newer releases, but our lab is not using Go modules. Go expects to find source files in the ${GOPATH}/src directory hierarchy, and if you do not have the GOPATH environment variable set, it expects fo find source files in the ${HOME}/go/src directory hierarchy. \u21a9 A hash is a fixed-length fingerprint for a set of input data of any size. Since there are an infinite number of possible input combinations, and the hash is fixed-length, in theory two different sets of data could produce the same hash. This is called a collision . In practice, the hash is of sufficient size, and the algorithm to produce it sufficiently complex, that it is computationally infeasible to produce the same hash with two different sets of input. If it can be demonstrated that two different sets of input can produce the same fingerprint by a hashing algorithm, then that algorithm will be considered insecure and fall into disuse in favor of stronger hashing algorithms. \u21a9","title":"Explanation of GREP11 sample code"},{"location":"reference/hpvs_undeploy/","text":"Undeploying virtual servers \u00b6 You can use the hpvs undeploy command to delete existing virtual server instances along with resources like networks, and quotagroups, that were allocated to that virtual server. Only resources that are not shared with other virtual servers are deleted. This command also deletes all images, and repositories that are not shared with other virtual servers. This procedure is intended for users with the role cloud administrator . Procedure \u00b6 On your x86 or Linux on IBM Z/LinuxONE (i.e., s390x architecture) management server, complete the following steps with root user authority. You can use the configuration yaml file $HOME/hpvs/config/yaml/vs_hpvsopbasessh.yml that you used for creating the virtual server instance. The following is an Example of the vs_hpvsopbasessh.yml file version: v1 type: virtualserver virtualservers: - name: test-hpvsopbasessh host: SSC_LPAR_NAME hostname: hpvsopbasessh-container repoid: HpvsopBaseSSH imagetag: 1.2.1-abcdefg imagefile: HpvsopBaseSSH.tar.gz resourcedefinition: ref: small environment: - key: LOGTARGET value: \"/dev/console\" - key: ROOTFS_LOCK value: \"y\" - key: SSH_PUBLIC_KEY value: \"@/root/hpvs/config/hpvsopbasessh/keys/id_rsa.pub\" networks: - ref: external_network ipaddress: 10.20.4.12 volumes: - name: qg_hpvsopbasessh ref : np-small mounts: - mount_id: new_qg_hpvsopbasessh mountpoint: /newroot filesystem: ext4 size: 10GB - name: qg_passthrough ref: p-small mounts: - mountpoint: /qg_passthrough Note : The configuration yaml file should specify either the imagefile parameter, or the reporegfile parameter, but not both. You can use the hpvs vs list command to view the list of virtual servers. You can undeploy only those virtual servers (and the resources associated with the virtual server) that were created by using the hpvs deploy command, from this list. Run the following command to undeploy the virtual server. hpvs undeploy --config $HOME/hpvs/config/yaml/vs_hpvsopbasessh.yml A message is displayed stating that virtual server(s) and associated networks, storage, images, and repository will be deleted. You are prompted to enter either Yes or No . If you enter Yes , the command execution continues, otherwise it exits the command execution. When you have a large number of virtual servers to undeploy, you can use the following flags to simplify the undeploy operation: --exclude : To exclude virtual servers from the undeploy operation. You can specify a single virtual server, or a comma separated list of virtual servers. --include : To include the virtual servers from the undeploy operation. You can specify a single virtual server, or a comma separated list of virtual servers. If you do not use the --exclude or --include flag, all virtual servers that are listed in the configuration yaml file are undeployed. The --exclude or --include flags are mutually exclusive and you must specify only one of them when you run the hpvs undeploy command. You can run the following commands to verify if the resources associated with the virtual server or virtual servers are deleted. hpvs image list command to verify if the images associated with the virtual server(s) are deleted. hpvs network list command to verify if the networks associated with the virtual server(s) are deleted. hpvs quotagroup list command to verify if the quotagroups associated with the virtual server(s) are deleted. hpvs repository list command to verify if the repositories associated with the virtual server(s) are deleted. Note : The resources that are shared by other virtual servers are not deleted and an appropriate message is displayed.","title":"Undeploying virtual servers"},{"location":"reference/hpvs_undeploy/#undeploying-virtual-servers","text":"You can use the hpvs undeploy command to delete existing virtual server instances along with resources like networks, and quotagroups, that were allocated to that virtual server. Only resources that are not shared with other virtual servers are deleted. This command also deletes all images, and repositories that are not shared with other virtual servers. This procedure is intended for users with the role cloud administrator .","title":"Undeploying virtual servers"},{"location":"reference/hpvs_undeploy/#procedure","text":"On your x86 or Linux on IBM Z/LinuxONE (i.e., s390x architecture) management server, complete the following steps with root user authority. You can use the configuration yaml file $HOME/hpvs/config/yaml/vs_hpvsopbasessh.yml that you used for creating the virtual server instance. The following is an Example of the vs_hpvsopbasessh.yml file version: v1 type: virtualserver virtualservers: - name: test-hpvsopbasessh host: SSC_LPAR_NAME hostname: hpvsopbasessh-container repoid: HpvsopBaseSSH imagetag: 1.2.1-abcdefg imagefile: HpvsopBaseSSH.tar.gz resourcedefinition: ref: small environment: - key: LOGTARGET value: \"/dev/console\" - key: ROOTFS_LOCK value: \"y\" - key: SSH_PUBLIC_KEY value: \"@/root/hpvs/config/hpvsopbasessh/keys/id_rsa.pub\" networks: - ref: external_network ipaddress: 10.20.4.12 volumes: - name: qg_hpvsopbasessh ref : np-small mounts: - mount_id: new_qg_hpvsopbasessh mountpoint: /newroot filesystem: ext4 size: 10GB - name: qg_passthrough ref: p-small mounts: - mountpoint: /qg_passthrough Note : The configuration yaml file should specify either the imagefile parameter, or the reporegfile parameter, but not both. You can use the hpvs vs list command to view the list of virtual servers. You can undeploy only those virtual servers (and the resources associated with the virtual server) that were created by using the hpvs deploy command, from this list. Run the following command to undeploy the virtual server. hpvs undeploy --config $HOME/hpvs/config/yaml/vs_hpvsopbasessh.yml A message is displayed stating that virtual server(s) and associated networks, storage, images, and repository will be deleted. You are prompted to enter either Yes or No . If you enter Yes , the command execution continues, otherwise it exits the command execution. When you have a large number of virtual servers to undeploy, you can use the following flags to simplify the undeploy operation: --exclude : To exclude virtual servers from the undeploy operation. You can specify a single virtual server, or a comma separated list of virtual servers. --include : To include the virtual servers from the undeploy operation. You can specify a single virtual server, or a comma separated list of virtual servers. If you do not use the --exclude or --include flag, all virtual servers that are listed in the configuration yaml file are undeployed. The --exclude or --include flags are mutually exclusive and you must specify only one of them when you run the hpvs undeploy command. You can run the following commands to verify if the resources associated with the virtual server or virtual servers are deleted. hpvs image list command to verify if the images associated with the virtual server(s) are deleted. hpvs network list command to verify if the networks associated with the virtual server(s) are deleted. hpvs quotagroup list command to verify if the quotagroups associated with the virtual server(s) are deleted. hpvs repository list command to verify if the repositories associated with the virtual server(s) are deleted. Note : The resources that are shared by other virtual servers are not deleted and an appropriate message is displayed.","title":"Procedure"},{"location":"reference/hpvs_update/","text":"Updating virtual servers \u00b6 You can update the resources or configuration of a virtual server after the completion of the deploy operation by using the -u , or the --update flag of the hpvs deploy command. The information about the parameters to be updated are read from the configuration yaml file. You can edit the configuration file with the details of the update you want to perform and use this configuration file to run the command. This procedure is intended for users with the role cloud administrator . Procedure \u00b6 On your x86 or Linux on IBM Z/LinuxONE (i.e., s390x architecture) management server, complete the following steps with root user authority. hpvs deploy --update --config $HOME/hpvs/config/demo_byoi.yml Note : It is recommended that you back up the Hyper Protect Virtual Server container by using the hpvs snapshot command before you run the hpvs deploy update command. When you have a large number of virtual servers to update, you can use the following flags to simplify the deploy update operation: --exclude : To exclude virtual servers from the deploy update operation. You can specify a single virtual server, or a comma separated list of virtual servers. --include : To include the virtual servers from the deploy update operation. You can specify a single virtual server, or a comma separated list of virtual servers. If you do not use the --exclude or --include flag, all virtual servers that are listed in the configuration yaml file are updated. The --exclude or --include flags are mutually exclusive and you must specify only one of them when you run the hpvs deploy command along with the --update flag. You can use the --update flag of the hpvs deploy command in the following scenarios: Increase the size of the mountpoint (you might need to increase the size of the quotagroup to accommodate the increase in mountpoint size). Update the repository definition file. Update the network by modifying the network config section in configuration yaml file. If the network not exist, a new network can be created with the specified details. Similarly, you can change an existing IP address. You cannot use the --update flag of the hpvs deploy command in the following scenarios: Add a new mount ID, reduce the size of the mountpoint or reduce the size of the quotagroup. Detach a quotagroup (you cannot detach a quotagtoup by using the hpvs vs update command as well). Doing so might cause errors or lead to an irrecoverable state of the quotagroup and the virtual server. Note : Networks that are detached when you run the hpvs deploy command by specifying the --update flag, are deleted if they not used by any other virtual server. You cannot update the settings of an existing network in the virtual server template file.","title":"Updating virtual servers"},{"location":"reference/hpvs_update/#updating-virtual-servers","text":"You can update the resources or configuration of a virtual server after the completion of the deploy operation by using the -u , or the --update flag of the hpvs deploy command. The information about the parameters to be updated are read from the configuration yaml file. You can edit the configuration file with the details of the update you want to perform and use this configuration file to run the command. This procedure is intended for users with the role cloud administrator .","title":"Updating virtual servers"},{"location":"reference/hpvs_update/#procedure","text":"On your x86 or Linux on IBM Z/LinuxONE (i.e., s390x architecture) management server, complete the following steps with root user authority. hpvs deploy --update --config $HOME/hpvs/config/demo_byoi.yml Note : It is recommended that you back up the Hyper Protect Virtual Server container by using the hpvs snapshot command before you run the hpvs deploy update command. When you have a large number of virtual servers to update, you can use the following flags to simplify the deploy update operation: --exclude : To exclude virtual servers from the deploy update operation. You can specify a single virtual server, or a comma separated list of virtual servers. --include : To include the virtual servers from the deploy update operation. You can specify a single virtual server, or a comma separated list of virtual servers. If you do not use the --exclude or --include flag, all virtual servers that are listed in the configuration yaml file are updated. The --exclude or --include flags are mutually exclusive and you must specify only one of them when you run the hpvs deploy command along with the --update flag. You can use the --update flag of the hpvs deploy command in the following scenarios: Increase the size of the mountpoint (you might need to increase the size of the quotagroup to accommodate the increase in mountpoint size). Update the repository definition file. Update the network by modifying the network config section in configuration yaml file. If the network not exist, a new network can be created with the specified details. Similarly, you can change an existing IP address. You cannot use the --update flag of the hpvs deploy command in the following scenarios: Add a new mount ID, reduce the size of the mountpoint or reduce the size of the quotagroup. Detach a quotagroup (you cannot detach a quotagtoup by using the hpvs vs update command as well). Doing so might cause errors or lead to an irrecoverable state of the quotagroup and the virtual server. Note : Networks that are detached when you run the hpvs deploy command by specifying the --update flag, are deleted if they not used by any other virtual server. You cannot update the settings of an existing network in the virtual server template file.","title":"Procedure"},{"location":"securebuild/build/","text":"Securely Build your Application \u00b6 You will use the Secure Build process to build the two virtual servers that are required for the digital banking application. This topic provides the details for building the Secure Build virtual servers. Prerequisites \u00b6 Ensure that you have all the user IDs and passwords to pull the base images, push the built images, and pull the built images from the remote Docker registry server. Before you build a docker image by using the Hyper Protect base images, you must open the required ports for your application. For more information, see Enabling ports . Procedure to create the MongoDB image \u00b6 On your x86 or Linux on IBM Z/LinuxONE (i.e., s390x architecture) management server, complete the following steps with root user authority. To generate the signing keys, follow the instructions listed in the topic Generating the signing keys . Create the configuration mongo_secure_build.yml file for MongoDB. You can use the $HOME/hpvs/config/securebuild/secure_build.yml.example example file as a reference when updating the file. mongo_secure_build.yml secure_build_workers: sbs: url: 'https://129.40.15.77>' port: '21443' cert_path: '/home/hpvs_user/hpvs/config/securebuild/keys/sbs_cert>' key_path: '/home/hpvs_user/hpvs/config/securebuild/keys/sbs_key>' regfile: id: 'securebuildcontainer472' github: url: 'git@github.ibm.com:sscicpci/SolutionTest_HPVSonPrem_TestApp.git>' branch: 'mongo_sbs' ssh_private_key_path: '/home/hpvs_user/.ssh/id_rsa>' recurse_submodules: 'False' dockerfile_path: './Dockerfile' docker: push_server: 'docker_reg' base_server: 'docker_reg' pull_server: 'docker_reg' repo: 'hpvsdemo/mongo_demo' image_tag_prefix: 'latest' content_trust_base: 'True' manifest_cos: bucket_name: '' api_key: '' resource_crn: '' auth_endpoint: '' endpoint: '' env: whitelist: [\"ROOT_SSH_KEY\",\"SERVER_KEY\", \"RUNQ_ROOTDISK\", \"LOGTARGET\", \"ROOTFS_LOCK\"] # build: # args: signing_key: private_key_path: '/home/hpvs_user/.ssh/hpvs_user/isv_user.private' public_key_path: '/home/hpvs_user/.ssh/hpvs_user/isv_user.pub' Note : You can view the example configuration files at home/hpvs_user/HPVS1221_Production/config/yaml . The application required to build the MongoDB application is available in the GitHub repository (details of repository is specified in the github parameters of the configuration file shown in the previous step) by choosing one of the following options: Use one command to perform all the Secure Build actions including initialization, build, and generating the encrypted repository registration file. This option is recommended if you are building the application by using the Secure Build for the first time. The passphrase used is \"over-the-lazy-dog\". hpvs sb init --config $HOME/hpvs/config/mongo_secure_build.yml --out $HOME/hpvs/config/securebuild/regfiles/encryptedRepoRegistration_mongo.enc --build Use individual commands to perform each step of building the application by using the Secure Build virtual server. This option is recommended if you plan to build the application by using the Secure Build multiple times. In this scenario, you can run the hpvs sb build command for subsequent builds. hpvs sb build --config $HOME/hpvs/config/securebuild/mongo_secure_build.yml hpvs sb regfile --config $HOME/hpvs/config/securebuild/mongo_secure_build.yml --out $HOME/hpvs/config/securebuild/regfiles/encryptedRepoRegistration_mongo.enc You can use the hpvs sb status command to view the progress of the secure build. Example Output After the Secure build process completes, the MongoDB image is pushed to the DockerHub repository, from where it will be later pulled to create the MongoDB virtual server. Procedure to create the digital banking image \u00b6 You will follow the same steps as mentioned in the section above but use a configuration file that specifies the details that are required for the MongoDB virtual server. Create the configuration digital_secure_build.yml file for the digital application. You can use the $HOME/hpvs/config/securebuild/secure_build.yml.example example file as a reference when updating the file. digital_secure_build.yml secure_build_workers: sbs: url: 'https://129.40.15.77>' port: '21443' cert_path: '/home/hpvs_user/hpvs/config/securebuild/keys/sbs_cert>' key_path: '/home/hpvs_user/hpvs/config/securebuild/keys/sbs_key>' regfile: id: 'digital' github: url: 'git@github.ibm.com:sscicpci/SolutionTest_HPVSonPrem_TestApp.git>' branch: 'digitalbank_https_sbs' ssh_private_key_path: '/home/hpvs_user/.ssh/id_rsa>' recurse_submodules: 'False' dockerfile_path: './Dockerfile_with_ARG' docker: # I am using the same registry for all 3 users but you can use 3 different registries. Use <hpvs registry list> command to view the registries push_server: 'docker_reg' base_server: 'docker_reg' pull_server: 'docker_reg' repo: 'hpvsdemo/digitaldemo' image_tag_prefix: 'latest' content_trust_base: 'True' manifest_cos: bucket_name: '' api_key: '' resource_crn: '' auth_endpoint: '' endpoint: '' env: whitelist: [\"ROOT_SSH_KEY\",\"SERVER_KEY\", \"RUNQ_ROOTDISK\", \"LOGTARGET\", \"ROOTFS_LOCK\"] build: args: MONGO_URL: 'mongodb://test:Passw0rd@129.40.15.19:2701/test' signing_key: private_key_path: '/home/hpvs_user/.ssh/hpvs_user/isv_user.private' public_key_path: '/home/hpvs_user/.ssh/hpvs_user/isv_user.pub' Note : You can view the example configuration files at home/hpvs_user/HPVS1221_Production/config/yaml . The application required to build the digital banking application is available in the GitHub repository (details of repository is specified in the github parameters of the configuration file shown in the previous step) by choosing one of the following options: Use one command to perform all the Secure Build actions including initialization, build, and generating the encrypted repository registration file. This option is recommended if you are building the application by using the Secure Build for the first time. The passphrase used is \"over-the-lazy-dog\". hpvs sb init --config $HOME/hpvs/config/securebuild/digital_secure_build.yml --out $HOME/hpvs/config/securebuild/regfiles/encryptedRepoRegistration_digital.enc --build Use individual commands to perform each step of building the application by using the Secure Build virtual server. This option is recommended if you plan to build the application by using the Secure Build multiple times. In this scenario, you can run the hpvs sb build command for subsequent builds. hpvs sb build --config $HOME/hpvs/config/securebuiild/digital_secure_build.yml hpvs sb regfile --config $HOME/hpvs/config/securebuild/digital_secure_build.yml --out $HOME/hpvs/config/securebuild/regfiles/encryptedRepoRegistration_digital.enc You can use the hpvs sb status command to view the progress of the secure build. Example Output Note If the hpvs sb init , hpvs sb build , or the hpvs sb regfile commands fails for any reason, for example you specified incorrect parameters, then you can use the hpvs sb update command to update the configuration of the Secure Build configuration and rerun the commands with the updated configuration. The regfile[id] and docker[repo] parameters cannot be updated by using this command. You can use the hpvs sb log command to view the run time logs of the secure build process, or for troubleshooting or debugging. - The logs are available when you run the hpvs sb init , hpvs sb build , or the hpvs sb regfile commands. You can use the hpvs sb status command to view the status of the last secure build process. You can use the hpvs sb clean command to clean the logs of the secure build process. Build artifacts from the earlier builds are deleted.","title":"Securely Build your Application"},{"location":"securebuild/build/#securely-build-your-application","text":"You will use the Secure Build process to build the two virtual servers that are required for the digital banking application. This topic provides the details for building the Secure Build virtual servers.","title":"Securely Build your Application"},{"location":"securebuild/build/#prerequisites","text":"Ensure that you have all the user IDs and passwords to pull the base images, push the built images, and pull the built images from the remote Docker registry server. Before you build a docker image by using the Hyper Protect base images, you must open the required ports for your application. For more information, see Enabling ports .","title":"Prerequisites"},{"location":"securebuild/build/#procedure-to-create-the-mongodb-image","text":"On your x86 or Linux on IBM Z/LinuxONE (i.e., s390x architecture) management server, complete the following steps with root user authority. To generate the signing keys, follow the instructions listed in the topic Generating the signing keys . Create the configuration mongo_secure_build.yml file for MongoDB. You can use the $HOME/hpvs/config/securebuild/secure_build.yml.example example file as a reference when updating the file. mongo_secure_build.yml secure_build_workers: sbs: url: 'https://129.40.15.77>' port: '21443' cert_path: '/home/hpvs_user/hpvs/config/securebuild/keys/sbs_cert>' key_path: '/home/hpvs_user/hpvs/config/securebuild/keys/sbs_key>' regfile: id: 'securebuildcontainer472' github: url: 'git@github.ibm.com:sscicpci/SolutionTest_HPVSonPrem_TestApp.git>' branch: 'mongo_sbs' ssh_private_key_path: '/home/hpvs_user/.ssh/id_rsa>' recurse_submodules: 'False' dockerfile_path: './Dockerfile' docker: push_server: 'docker_reg' base_server: 'docker_reg' pull_server: 'docker_reg' repo: 'hpvsdemo/mongo_demo' image_tag_prefix: 'latest' content_trust_base: 'True' manifest_cos: bucket_name: '' api_key: '' resource_crn: '' auth_endpoint: '' endpoint: '' env: whitelist: [\"ROOT_SSH_KEY\",\"SERVER_KEY\", \"RUNQ_ROOTDISK\", \"LOGTARGET\", \"ROOTFS_LOCK\"] # build: # args: signing_key: private_key_path: '/home/hpvs_user/.ssh/hpvs_user/isv_user.private' public_key_path: '/home/hpvs_user/.ssh/hpvs_user/isv_user.pub' Note : You can view the example configuration files at home/hpvs_user/HPVS1221_Production/config/yaml . The application required to build the MongoDB application is available in the GitHub repository (details of repository is specified in the github parameters of the configuration file shown in the previous step) by choosing one of the following options: Use one command to perform all the Secure Build actions including initialization, build, and generating the encrypted repository registration file. This option is recommended if you are building the application by using the Secure Build for the first time. The passphrase used is \"over-the-lazy-dog\". hpvs sb init --config $HOME/hpvs/config/mongo_secure_build.yml --out $HOME/hpvs/config/securebuild/regfiles/encryptedRepoRegistration_mongo.enc --build Use individual commands to perform each step of building the application by using the Secure Build virtual server. This option is recommended if you plan to build the application by using the Secure Build multiple times. In this scenario, you can run the hpvs sb build command for subsequent builds. hpvs sb build --config $HOME/hpvs/config/securebuild/mongo_secure_build.yml hpvs sb regfile --config $HOME/hpvs/config/securebuild/mongo_secure_build.yml --out $HOME/hpvs/config/securebuild/regfiles/encryptedRepoRegistration_mongo.enc You can use the hpvs sb status command to view the progress of the secure build. Example Output After the Secure build process completes, the MongoDB image is pushed to the DockerHub repository, from where it will be later pulled to create the MongoDB virtual server.","title":"Procedure to create the MongoDB image"},{"location":"securebuild/build/#procedure-to-create-the-digital-banking-image","text":"You will follow the same steps as mentioned in the section above but use a configuration file that specifies the details that are required for the MongoDB virtual server. Create the configuration digital_secure_build.yml file for the digital application. You can use the $HOME/hpvs/config/securebuild/secure_build.yml.example example file as a reference when updating the file. digital_secure_build.yml secure_build_workers: sbs: url: 'https://129.40.15.77>' port: '21443' cert_path: '/home/hpvs_user/hpvs/config/securebuild/keys/sbs_cert>' key_path: '/home/hpvs_user/hpvs/config/securebuild/keys/sbs_key>' regfile: id: 'digital' github: url: 'git@github.ibm.com:sscicpci/SolutionTest_HPVSonPrem_TestApp.git>' branch: 'digitalbank_https_sbs' ssh_private_key_path: '/home/hpvs_user/.ssh/id_rsa>' recurse_submodules: 'False' dockerfile_path: './Dockerfile_with_ARG' docker: # I am using the same registry for all 3 users but you can use 3 different registries. Use <hpvs registry list> command to view the registries push_server: 'docker_reg' base_server: 'docker_reg' pull_server: 'docker_reg' repo: 'hpvsdemo/digitaldemo' image_tag_prefix: 'latest' content_trust_base: 'True' manifest_cos: bucket_name: '' api_key: '' resource_crn: '' auth_endpoint: '' endpoint: '' env: whitelist: [\"ROOT_SSH_KEY\",\"SERVER_KEY\", \"RUNQ_ROOTDISK\", \"LOGTARGET\", \"ROOTFS_LOCK\"] build: args: MONGO_URL: 'mongodb://test:Passw0rd@129.40.15.19:2701/test' signing_key: private_key_path: '/home/hpvs_user/.ssh/hpvs_user/isv_user.private' public_key_path: '/home/hpvs_user/.ssh/hpvs_user/isv_user.pub' Note : You can view the example configuration files at home/hpvs_user/HPVS1221_Production/config/yaml . The application required to build the digital banking application is available in the GitHub repository (details of repository is specified in the github parameters of the configuration file shown in the previous step) by choosing one of the following options: Use one command to perform all the Secure Build actions including initialization, build, and generating the encrypted repository registration file. This option is recommended if you are building the application by using the Secure Build for the first time. The passphrase used is \"over-the-lazy-dog\". hpvs sb init --config $HOME/hpvs/config/securebuild/digital_secure_build.yml --out $HOME/hpvs/config/securebuild/regfiles/encryptedRepoRegistration_digital.enc --build Use individual commands to perform each step of building the application by using the Secure Build virtual server. This option is recommended if you plan to build the application by using the Secure Build multiple times. In this scenario, you can run the hpvs sb build command for subsequent builds. hpvs sb build --config $HOME/hpvs/config/securebuiild/digital_secure_build.yml hpvs sb regfile --config $HOME/hpvs/config/securebuild/digital_secure_build.yml --out $HOME/hpvs/config/securebuild/regfiles/encryptedRepoRegistration_digital.enc You can use the hpvs sb status command to view the progress of the secure build. Example Output Note If the hpvs sb init , hpvs sb build , or the hpvs sb regfile commands fails for any reason, for example you specified incorrect parameters, then you can use the hpvs sb update command to update the configuration of the Secure Build configuration and rerun the commands with the updated configuration. The regfile[id] and docker[repo] parameters cannot be updated by using this command. You can use the hpvs sb log command to view the run time logs of the secure build process, or for troubleshooting or debugging. - The logs are available when you run the hpvs sb init , hpvs sb build , or the hpvs sb regfile commands. You can use the hpvs sb status command to view the status of the last secure build process. You can use the hpvs sb clean command to clean the logs of the secure build process. Build artifacts from the earlier builds are deleted.","title":"Procedure to create the digital banking image"},{"location":"securebuild/cleanup/","text":"Clean up your Environment \u00b6 You can complete the following steps to clean up your environment when you have finished exploring the features of this hosted trial. Cleanup Secure Build Server \u00b6 Cleanup virtual server hpvs vs delete --name <virtualserver_name> Cleanup Quotagroup hpvs quotagroup delete --name <quotagroup_name> Cleanup Application \u00b6 Cleanup HPVS deployment hpvs vs delete --name <repoid> Where is the name of the repoid specified in the yaml file, for example: repoid: SecureDockerBuild in the securebuild.yml file. Cleanup Quotagroup hpvs quotagroup delete --name <repoid> Where is the name of the repoid specified in the yaml file, for example: repoid: mongodemo in the mongo_demo.yml file Cleanup Repository \u00b6 hpvs repository delete --id <repoid> --force Cleanup Docker Token \u00b6 Delete the existing Docker Token by logging into your Docker Hub account and following these instructions Cleanup GitHub SSH key \u00b6 Delete the SSH key you added for the lab following steps 1-3 of these instructions","title":"Clean up your Environment"},{"location":"securebuild/cleanup/#clean-up-your-environment","text":"You can complete the following steps to clean up your environment when you have finished exploring the features of this hosted trial.","title":"Clean up your Environment"},{"location":"securebuild/cleanup/#cleanup-secure-build-server","text":"Cleanup virtual server hpvs vs delete --name <virtualserver_name> Cleanup Quotagroup hpvs quotagroup delete --name <quotagroup_name>","title":"Cleanup Secure Build Server"},{"location":"securebuild/cleanup/#cleanup-application","text":"Cleanup HPVS deployment hpvs vs delete --name <repoid> Where is the name of the repoid specified in the yaml file, for example: repoid: SecureDockerBuild in the securebuild.yml file. Cleanup Quotagroup hpvs quotagroup delete --name <repoid> Where is the name of the repoid specified in the yaml file, for example: repoid: mongodemo in the mongo_demo.yml file","title":"Cleanup Application"},{"location":"securebuild/cleanup/#cleanup-repository","text":"hpvs repository delete --id <repoid> --force","title":"Cleanup Repository"},{"location":"securebuild/cleanup/#cleanup-docker-token","text":"Delete the existing Docker Token by logging into your Docker Hub account and following these instructions","title":"Cleanup Docker Token"},{"location":"securebuild/cleanup/#cleanup-github-ssh-key","text":"Delete the SSH key you added for the lab following steps 1-3 of these instructions","title":"Cleanup GitHub SSH key"},{"location":"securebuild/create-server-hpvsdeploy/","text":"Create your Secure Build Server by using a config file \u00b6 You can create the Secure Build virtual server by using the hpvs deploy command by specifying a configuration yaml file as an input for the hpvs deploy command. This is the recommended option to provision the instance because of it's ease of use, and is also an easier method of creating multiple instances quickly. Procedure to create a Secure Build virtual server (for building the MongoDB image) \u00b6 See the topic Create your Secure Build Server for details about the certificate generation. Update the template file $HOME/hpvs/config/templates/virtualserver.template.yml based on the networking configuration, quotagroup, and resource settings of the Hyper Protect Virtual Server instance if necessary. For details about the virtual server template file, see the Prerequisites page . Create the configuration yaml file securebuild.yml for the instance by referring to the example file $HOME/hpvs/config/securebuild/vs_securebuild.yml. The vs_securebuild.yml has the configuration details for the virtual server and refers to the corresponding sections of the virtualserver.template.yml when you run the hpvs deploy command. For example, the resourcedefinition: ref value refers to the resourcedefinitiontemplate definition in the template file. Example of a Secure Build virtual server configuration file version: v1 type: virtualserver virtualservers: - name: test_securebuild host: test2 repoid: SecureDockerBuild imagetag: 1.2.3-release-f78a642 imagefile: /home/hpvs_user/hpvs/config/securebuild/images/SecureDockerBuild.tar.gz resourcedefinition: ref: small environment: - key: ROOTFS_LOCK value: \"y\" - key: CLIENT_CRT value: \"@/home/hpvs_user/hpvs/config/securebuild/keys/sbs_withbase64.cert\" # provide certificate file in base64 format - key: RUNQ_ROOTDISK value: newroot ports: - containerport: 443 protocol: tcp hostport: 21443 volumes: - name: qg_securebuild ref: np-medium mounts: - mountpoint: /data filesystem: ext4 size: 16GB mount_id: data - mountpoint: /docker filesystem: ext4 size: 16GB mount_id: docker - mountpoint: /newroot filesystem: ext4 size: 10GB mount_id: newroot reset_root: false This Secure Build virtual server is used to build the MongoDB image. Note : You can view the example configuration files at home/hpvs_user/HPVS1221_Production/config/yaml . Create the Secure Build virtual server by using the configurations in the yaml file. hpvs deploy --config $HOME/hpvs/config/securebuild/securebuild.yaml --templatefile ../../templates/virtualserver.template.yml Example of the command hpvs deploy --config $HOME/hpvs/config/securebuild/securebuild.yaml --templatefile ../../templates/virtualserver.template.yml Your Secure Build Server is now up and running. It is available at the IP Address of the Hyper Protect Virtual Server LPAR and port (GuestPort) specified. This Secure Build virtual Server will be used to build the MongoDB image. Example Output Procedure to create the MongoDB virtual server \u00b6 You will follow the same steps as mentioned in the section: Procedure to create a Secure Build virtual server (for building the MongoDB image), but use a configuration file that specifies the details that are required for the MongoDB virtual server. To run the digital banking application, the digital virtual server requires the MongoDB virtual to be up and running already. Create the configuration file mongo_demo.yml for the MongoDB virtual server by referring to the example vs_configfile_readme.yaml available in $HOME/home/hpvs/config . The following is an example of the configuration file: mongo_demo.yml version: v1 type: virtualserver virtualservers: - name: test_mongo host: test2 repoid: mongodemo imagetag: latest imagefile: /home/hpvs_user/hpvs/config/securebuild/regfiles/encryptedRepoRegistration_mongo.enc resourcedefinition: ref: small networks: - ref: external_network ipaddress: 129.40.15.19 volumes: - name: qg_securebuild ref: np-medium mounts: - mount_id: data mountpoint: /data filesystem: ext4 size: 10GB Tip Step 3 of \"Procedure to create the MongoDB image\" from the topic Securely Build your Application generates the encrypted registration file encryptedRepoRegistration_mongo.enc that is used in the above example yaml file. You can view the example configuration files at home/hpvs_user/HPVS1221_Production/config/yaml . Create the MongoDB virtual server by using the configurations in the yaml file (in this step, the MongoDB image is pulled from DockerHub). hpvs deploy --config $HOME/hpvs/config/vs_configfile_readme.yml --templatefile ../../templates/virtualserver.template.yml Example of the command hpvs deploy --config $HOME/hpvs/config/mongo_demo.yml --templatefile ../../templates/virtualserver.template.yml Example Output Procedure to create a Secure Build virtual server (for building the digital banking application image) \u00b6 You can use the same configuration file that had you created earlier for deploying the Secure Build virtual server by deleting the virtual server that was created (test_securebuild), and running the same steps as listed in the section: Procedure to create a Secure Build virtual server (for building the MongoDB image). The Secure Build virtual server thus created is used to build the digital banking application image. Alternatively, you can also create another configuration file with the details of the Secure Build Server and create another virtual server, and use this virtual server to build the digital banking application image. Procedure to create the digital virtual server \u00b6 You will follow the same steps as mentioned in the section: Procedure to create a Secure Build virtual server (for building the MongoDB image), but use a configuration file that specifies the details that are required for the digital virtual server. Create the configuration file for the digital application virtual server by referring to the example vs_configfile_readme.yaml available in $HOME/home/hpvs/config . This following is an example of the configuration file: digital_demo.yml version: v1 type: virtualserver virtualservers: - name: test_digital host: test2 repoid: mongodemo imagetag: latest imagefile: /home/hpvs_user/hpvs/config/securebuild/regfiles/encryptedRepoRegistration_digital.enc resourcedefinition: ref: small networks: - ref: external_network ipaddress: 129.40.15.20 environment: - key: LOGTARGET value: /dev/console - key: ROOTFS_LOCK value: \"y\" - key: ROOT_SSH_KEY value: '@/home/hpvs_user/.ssh/id_rsa' - key: RUNQ_ROOTDISK value: new_qg_digitalbank volumes: - mounts: - filesystem: ext4 mount_id: new_qg_digitalbank mountpoint: /newroot size: 10GB - filesystem: ext4 mount_id: data mountpoint: /data size: 10GB name: qg_hpvs_digitalbank ref: np-medium Note : You can view the example configuration files at home/hpvs_user/HPVS1221_Production/config/yaml . Create the digital application virtual server by using the configurations in the yaml file (in this step, the digital banking application image is pulled from DockerHub). hpvs deploy --config $HOME/hpvs/config/vs_configfile_readme.yml --templatefile ../../templates/virtualserver.template.yml Example of the command hpvs deploy --config $HOME/hpvs/config/digital_demo.yml --templatefile ../../templates/virtualserver.template.yml Example Output Note You can assign IP addresses and hostnames for containers as necessary for your purposes but using the docker network and host ports is a nice way to quickly get running without having to use up IP addresses on your network. You can use the hpvs undeploy command to delete a virtual server. For more information, see Undeploying virtual servers . You can update the resources or configuration of a virtual server after the completion of the deploy operation by using the -u , or the --update flag of the hpvs deploy command. For more information, see Updating virtual servers .","title":"Create your Secure Build Server by using a configuration file"},{"location":"securebuild/create-server-hpvsdeploy/#create-your-secure-build-server-by-using-a-config-file","text":"You can create the Secure Build virtual server by using the hpvs deploy command by specifying a configuration yaml file as an input for the hpvs deploy command. This is the recommended option to provision the instance because of it's ease of use, and is also an easier method of creating multiple instances quickly.","title":"Create your Secure Build Server by using a config file"},{"location":"securebuild/create-server-hpvsdeploy/#procedure-to-create-a-secure-build-virtual-server-for-building-the-mongodb-image","text":"See the topic Create your Secure Build Server for details about the certificate generation. Update the template file $HOME/hpvs/config/templates/virtualserver.template.yml based on the networking configuration, quotagroup, and resource settings of the Hyper Protect Virtual Server instance if necessary. For details about the virtual server template file, see the Prerequisites page . Create the configuration yaml file securebuild.yml for the instance by referring to the example file $HOME/hpvs/config/securebuild/vs_securebuild.yml. The vs_securebuild.yml has the configuration details for the virtual server and refers to the corresponding sections of the virtualserver.template.yml when you run the hpvs deploy command. For example, the resourcedefinition: ref value refers to the resourcedefinitiontemplate definition in the template file. Example of a Secure Build virtual server configuration file version: v1 type: virtualserver virtualservers: - name: test_securebuild host: test2 repoid: SecureDockerBuild imagetag: 1.2.3-release-f78a642 imagefile: /home/hpvs_user/hpvs/config/securebuild/images/SecureDockerBuild.tar.gz resourcedefinition: ref: small environment: - key: ROOTFS_LOCK value: \"y\" - key: CLIENT_CRT value: \"@/home/hpvs_user/hpvs/config/securebuild/keys/sbs_withbase64.cert\" # provide certificate file in base64 format - key: RUNQ_ROOTDISK value: newroot ports: - containerport: 443 protocol: tcp hostport: 21443 volumes: - name: qg_securebuild ref: np-medium mounts: - mountpoint: /data filesystem: ext4 size: 16GB mount_id: data - mountpoint: /docker filesystem: ext4 size: 16GB mount_id: docker - mountpoint: /newroot filesystem: ext4 size: 10GB mount_id: newroot reset_root: false This Secure Build virtual server is used to build the MongoDB image. Note : You can view the example configuration files at home/hpvs_user/HPVS1221_Production/config/yaml . Create the Secure Build virtual server by using the configurations in the yaml file. hpvs deploy --config $HOME/hpvs/config/securebuild/securebuild.yaml --templatefile ../../templates/virtualserver.template.yml Example of the command hpvs deploy --config $HOME/hpvs/config/securebuild/securebuild.yaml --templatefile ../../templates/virtualserver.template.yml Your Secure Build Server is now up and running. It is available at the IP Address of the Hyper Protect Virtual Server LPAR and port (GuestPort) specified. This Secure Build virtual Server will be used to build the MongoDB image. Example Output","title":"Procedure to create a Secure Build virtual server (for building the MongoDB image)"},{"location":"securebuild/create-server-hpvsdeploy/#procedure-to-create-the-mongodb-virtual-server","text":"You will follow the same steps as mentioned in the section: Procedure to create a Secure Build virtual server (for building the MongoDB image), but use a configuration file that specifies the details that are required for the MongoDB virtual server. To run the digital banking application, the digital virtual server requires the MongoDB virtual to be up and running already. Create the configuration file mongo_demo.yml for the MongoDB virtual server by referring to the example vs_configfile_readme.yaml available in $HOME/home/hpvs/config . The following is an example of the configuration file: mongo_demo.yml version: v1 type: virtualserver virtualservers: - name: test_mongo host: test2 repoid: mongodemo imagetag: latest imagefile: /home/hpvs_user/hpvs/config/securebuild/regfiles/encryptedRepoRegistration_mongo.enc resourcedefinition: ref: small networks: - ref: external_network ipaddress: 129.40.15.19 volumes: - name: qg_securebuild ref: np-medium mounts: - mount_id: data mountpoint: /data filesystem: ext4 size: 10GB Tip Step 3 of \"Procedure to create the MongoDB image\" from the topic Securely Build your Application generates the encrypted registration file encryptedRepoRegistration_mongo.enc that is used in the above example yaml file. You can view the example configuration files at home/hpvs_user/HPVS1221_Production/config/yaml . Create the MongoDB virtual server by using the configurations in the yaml file (in this step, the MongoDB image is pulled from DockerHub). hpvs deploy --config $HOME/hpvs/config/vs_configfile_readme.yml --templatefile ../../templates/virtualserver.template.yml Example of the command hpvs deploy --config $HOME/hpvs/config/mongo_demo.yml --templatefile ../../templates/virtualserver.template.yml Example Output","title":"Procedure to create the MongoDB virtual server"},{"location":"securebuild/create-server-hpvsdeploy/#procedure-to-create-a-secure-build-virtual-server-for-building-the-digital-banking-application-image","text":"You can use the same configuration file that had you created earlier for deploying the Secure Build virtual server by deleting the virtual server that was created (test_securebuild), and running the same steps as listed in the section: Procedure to create a Secure Build virtual server (for building the MongoDB image). The Secure Build virtual server thus created is used to build the digital banking application image. Alternatively, you can also create another configuration file with the details of the Secure Build Server and create another virtual server, and use this virtual server to build the digital banking application image.","title":"Procedure to create a Secure Build virtual server (for building the digital banking application image)"},{"location":"securebuild/create-server-hpvsdeploy/#procedure-to-create-the-digital-virtual-server","text":"You will follow the same steps as mentioned in the section: Procedure to create a Secure Build virtual server (for building the MongoDB image), but use a configuration file that specifies the details that are required for the digital virtual server. Create the configuration file for the digital application virtual server by referring to the example vs_configfile_readme.yaml available in $HOME/home/hpvs/config . This following is an example of the configuration file: digital_demo.yml version: v1 type: virtualserver virtualservers: - name: test_digital host: test2 repoid: mongodemo imagetag: latest imagefile: /home/hpvs_user/hpvs/config/securebuild/regfiles/encryptedRepoRegistration_digital.enc resourcedefinition: ref: small networks: - ref: external_network ipaddress: 129.40.15.20 environment: - key: LOGTARGET value: /dev/console - key: ROOTFS_LOCK value: \"y\" - key: ROOT_SSH_KEY value: '@/home/hpvs_user/.ssh/id_rsa' - key: RUNQ_ROOTDISK value: new_qg_digitalbank volumes: - mounts: - filesystem: ext4 mount_id: new_qg_digitalbank mountpoint: /newroot size: 10GB - filesystem: ext4 mount_id: data mountpoint: /data size: 10GB name: qg_hpvs_digitalbank ref: np-medium Note : You can view the example configuration files at home/hpvs_user/HPVS1221_Production/config/yaml . Create the digital application virtual server by using the configurations in the yaml file (in this step, the digital banking application image is pulled from DockerHub). hpvs deploy --config $HOME/hpvs/config/vs_configfile_readme.yml --templatefile ../../templates/virtualserver.template.yml Example of the command hpvs deploy --config $HOME/hpvs/config/digital_demo.yml --templatefile ../../templates/virtualserver.template.yml Example Output Note You can assign IP addresses and hostnames for containers as necessary for your purposes but using the docker network and host ports is a nice way to quickly get running without having to use up IP addresses on your network. You can use the hpvs undeploy command to delete a virtual server. For more information, see Undeploying virtual servers . You can update the resources or configuration of a virtual server after the completion of the deploy operation by using the -u , or the --update flag of the hpvs deploy command. For more information, see Updating virtual servers .","title":"Procedure to create the digital virtual server"},{"location":"securebuild/create-server/","text":"Create your Secure Build Server \u00b6 Complete the steps detailed in this topic to create the Secure Build virtual server. This method uses atomic commands to create the virtual server and requires you to enter several configuration information using multiple commands. All of this is automated and creating the virtual server is simplified when you use the hpvs dpeloy command, which is explained in the next topic. Creating the certificate and key to securely communicate with Secure Build Server \u00b6 Run the following command. cd $HOME/hpvs/config/securebuild/keys Create the certificate and key to securely communicate with Secure Build Server. openssl req -newkey rsa:2048 \\ -new -nodes -x509 \\ -days 3650 \\ -out sbs.cert \\ -keyout sbs.key \\ -subj \"/C=GB/O=IBM/CN=johndoe.example.com\" Note If you see errors like random number generator:RAND_load_file:Cannot open file , then run the following commands. openssl rand -out $HOME/.rnd -hex 256 Run the following command to change the certificate to base64 encoding. echo $(cat sbs.cert | base64) | tr -d ' ' >> sbs_base64.cert Creating the quotagroup for the Secure Build Server \u00b6 hpvs quotagroup create --name \"qg_securebuild\" --size = 40GB Example Output +-------------+----------------+ | name | qg_securebuild | | filesystem | btrfs | | passthrough | false | | pool_id | lv_data_pool | | size | 40GB | | available | 40GB | | containers | [] | +-------------+----------------+ Creating the Secure Build Server \u00b6 hpvs vs create --name test_securebuild --repo SecureDockerBuild \\ --tag 1 .2.3-release-f78a642 --cpu 2 --ram 2048 \\ --quotagroup \"{quotagroup = qg_securebuild, mountid = new, mount = /newroot, filesystem = ext4, size = 16GB}\" \\ --quotagroup \"{quotagroup = qg_securebuild, mountid = data, mount = /data, filesystem = ext4, size = 16GB}\" \\ --quotagroup \"{quotagroup = qg_securebuild, mountid = docker, mount = /docker, filesystem = ext4, size = 16GB}\" \\ --env ={ EX_VOLUMES = \"/docker,/data\" ,ROOTFS_LOCK = y,CLIENT_CRT = $cert } \\ --ports \"{containerport = 443, protocol = tcp, hostport = 21443}\" Example Output We can see that the quotagroup is now being used hpvs quotagroup show --name \"sb_user\" Example Output +-------------+--------------------------------+ | PROPERTIES | VALUES | +-------------+--------------------------------+ | name | qg_securebuild | | filesystem | btrfs | | passthrough | false | | pool_id | lv_data_pool | | size | 40GB | | available | 12GB | | containers | Container:test_securebuild | | | Mountids: \"new\" , \"data\" , \"docker\" | | | | | | | +-------------+--------------------------------+ Your Secure Build Server is now up and running! It is available at the IP Address of the Hyper Protect Virtual Server LPAR and port (GuestPort) specified. This Secure Build virtual Server will be used to build the MongoDB image. To build the banking application image, another Secure Build virtual sever is required, see Create your Secure Build Server using a yaml file for details. Note You can assign IP addresses and hostnames for containers as necessary for your purposes but using the docker network and host ports is a nice way to quickly get running without having to use up IP addresses on your network.","title":"Create your Secure Build Server"},{"location":"securebuild/create-server/#create-your-secure-build-server","text":"Complete the steps detailed in this topic to create the Secure Build virtual server. This method uses atomic commands to create the virtual server and requires you to enter several configuration information using multiple commands. All of this is automated and creating the virtual server is simplified when you use the hpvs dpeloy command, which is explained in the next topic.","title":"Create your Secure Build Server"},{"location":"securebuild/create-server/#creating-the-certificate-and-key-to-securely-communicate-with-secure-build-server","text":"Run the following command. cd $HOME/hpvs/config/securebuild/keys Create the certificate and key to securely communicate with Secure Build Server. openssl req -newkey rsa:2048 \\ -new -nodes -x509 \\ -days 3650 \\ -out sbs.cert \\ -keyout sbs.key \\ -subj \"/C=GB/O=IBM/CN=johndoe.example.com\" Note If you see errors like random number generator:RAND_load_file:Cannot open file , then run the following commands. openssl rand -out $HOME/.rnd -hex 256 Run the following command to change the certificate to base64 encoding. echo $(cat sbs.cert | base64) | tr -d ' ' >> sbs_base64.cert","title":"Creating the certificate and key to securely communicate with Secure Build Server"},{"location":"securebuild/create-server/#creating-the-quotagroup-for-the-secure-build-server","text":"hpvs quotagroup create --name \"qg_securebuild\" --size = 40GB Example Output +-------------+----------------+ | name | qg_securebuild | | filesystem | btrfs | | passthrough | false | | pool_id | lv_data_pool | | size | 40GB | | available | 40GB | | containers | [] | +-------------+----------------+","title":"Creating the quotagroup for the Secure Build Server"},{"location":"securebuild/create-server/#creating-the-secure-build-server","text":"hpvs vs create --name test_securebuild --repo SecureDockerBuild \\ --tag 1 .2.3-release-f78a642 --cpu 2 --ram 2048 \\ --quotagroup \"{quotagroup = qg_securebuild, mountid = new, mount = /newroot, filesystem = ext4, size = 16GB}\" \\ --quotagroup \"{quotagroup = qg_securebuild, mountid = data, mount = /data, filesystem = ext4, size = 16GB}\" \\ --quotagroup \"{quotagroup = qg_securebuild, mountid = docker, mount = /docker, filesystem = ext4, size = 16GB}\" \\ --env ={ EX_VOLUMES = \"/docker,/data\" ,ROOTFS_LOCK = y,CLIENT_CRT = $cert } \\ --ports \"{containerport = 443, protocol = tcp, hostport = 21443}\" Example Output We can see that the quotagroup is now being used hpvs quotagroup show --name \"sb_user\" Example Output +-------------+--------------------------------+ | PROPERTIES | VALUES | +-------------+--------------------------------+ | name | qg_securebuild | | filesystem | btrfs | | passthrough | false | | pool_id | lv_data_pool | | size | 40GB | | available | 12GB | | containers | Container:test_securebuild | | | Mountids: \"new\" , \"data\" , \"docker\" | | | | | | | +-------------+--------------------------------+ Your Secure Build Server is now up and running! It is available at the IP Address of the Hyper Protect Virtual Server LPAR and port (GuestPort) specified. This Secure Build virtual Server will be used to build the MongoDB image. To build the banking application image, another Secure Build virtual sever is required, see Create your Secure Build Server using a yaml file for details. Note You can assign IP addresses and hostnames for containers as necessary for your purposes but using the docker network and host ports is a nice way to quickly get running without having to use up IP addresses on your network.","title":"Creating the Secure Build Server"},{"location":"securebuild/deploy-app/","text":"Deploy your Securely Built Application as a Hyper Protect Virtual Server \u00b6 The example application used to showcase the Secure Build virtual server is the digital banking application, that requires two Secure Build virtual servers, one for building the MongoDB application and the second one for the digital banking application. Two virtual servers are created for the images, one for MongoDB, and one for the digital banking application. The following steps are required to deploy this application: Create a Secure Build virtual server for building the MongoDB image. See the section: \"Procedure to create a Secure Build virtual server (for building the MongoDB image) in the topic Create your HPVS Secure Build Server by using a configuration file , or Create your HPVS Secure Build Server . Build the MongoDB image by using the Secure Build process. See the section: \"Procedure to create the MongoDB image\" in the topic Securely Build your Application . Create a MongoDB virtual server. This server must be up and running before you create the digital banking virtual server. See the section \"Procedure to create the MongoDB virtual server\" in the topic Create your HPVS Secure Build Server by using a configuration file . Create a Secure Build virtual server for building the digital application image. See the section: \"Procedure to create a Secure Build virtual server (for building the digital banking application image)\" in the topic Create your HPVS Secure Build Server by using a configuration file . Build the digital banking image by using the Secure Build process. See the section: \"Procedure to create the digital banking image\" in the topic Securely Build your Application . Create a Secure Build virtual server for deploying the digital application image. See the section: Procedure to create the digital virtual server\" in the topic Create your HPVS Secure Build Server by using a configuration file . When you complete the steps listed above, the application is deployed and you can access the digital banking application. See Welcome to the Digital Banking Application for details.","title":"Deploy your Securely Built Application as a Hyper Protect Virtual Server"},{"location":"securebuild/deploy-app/#deploy-your-securely-built-application-as-a-hyper-protect-virtual-server","text":"The example application used to showcase the Secure Build virtual server is the digital banking application, that requires two Secure Build virtual servers, one for building the MongoDB application and the second one for the digital banking application. Two virtual servers are created for the images, one for MongoDB, and one for the digital banking application. The following steps are required to deploy this application: Create a Secure Build virtual server for building the MongoDB image. See the section: \"Procedure to create a Secure Build virtual server (for building the MongoDB image) in the topic Create your HPVS Secure Build Server by using a configuration file , or Create your HPVS Secure Build Server . Build the MongoDB image by using the Secure Build process. See the section: \"Procedure to create the MongoDB image\" in the topic Securely Build your Application . Create a MongoDB virtual server. This server must be up and running before you create the digital banking virtual server. See the section \"Procedure to create the MongoDB virtual server\" in the topic Create your HPVS Secure Build Server by using a configuration file . Create a Secure Build virtual server for building the digital application image. See the section: \"Procedure to create a Secure Build virtual server (for building the digital banking application image)\" in the topic Create your HPVS Secure Build Server by using a configuration file . Build the digital banking image by using the Secure Build process. See the section: \"Procedure to create the digital banking image\" in the topic Securely Build your Application . Create a Secure Build virtual server for deploying the digital application image. See the section: Procedure to create the digital virtual server\" in the topic Create your HPVS Secure Build Server by using a configuration file . When you complete the steps listed above, the application is deployed and you can access the digital banking application. See Welcome to the Digital Banking Application for details.","title":"Deploy your Securely Built Application as a Hyper Protect Virtual Server"},{"location":"securebuild/digital_banking/","text":"Welcome to the Digital Banking Application \u00b6 Overview \u00b6 This application is a secure application found at this GitHub repository . This application is built for your smartphone, it updates your balance instantly, sends intelligent notifications, and is easy to use. While this application is a dummy one that was created for demo purposes, running this type of application on Hyper Protect enables you to protect your digital assets from bad actors such as malicious server administrators. Info This application inherits the security benefits of the Hyper Protect Virtual Server platform. This ensures that a legitimate version of the application is running (Secure Image Build process) and that administrators cannot compromise the application (Hyper Protect Virtual Server deployment). Accessing the application \u00b6 You can click the following link to start using the application: https://129.40.15.20:3100/index.html You can explore the Digital Banking application before moving on.","title":"Welcome to the Digital Banking Application"},{"location":"securebuild/digital_banking/#welcome-to-the-digital-banking-application","text":"","title":"Welcome to the Digital Banking Application"},{"location":"securebuild/digital_banking/#overview","text":"This application is a secure application found at this GitHub repository . This application is built for your smartphone, it updates your balance instantly, sends intelligent notifications, and is easy to use. While this application is a dummy one that was created for demo purposes, running this type of application on Hyper Protect enables you to protect your digital assets from bad actors such as malicious server administrators. Info This application inherits the security benefits of the Hyper Protect Virtual Server platform. This ensures that a legitimate version of the application is running (Secure Image Build process) and that administrators cannot compromise the application (Hyper Protect Virtual Server deployment).","title":"Overview"},{"location":"securebuild/digital_banking/#accessing-the-application","text":"You can click the following link to start using the application: https://129.40.15.20:3100/index.html You can explore the Digital Banking application before moving on.","title":"Accessing the application"},{"location":"securebuild/overview/","text":"Hyper Protect Virtual Servers Secure Build overview \u00b6 Prerequisites \u00b6 See the Prerequisites page to complete the prerequisites for this trial if you want to use your own application. This includes creating accounts and credentials to access the Source Code Management (SCM) GitHub and the Docker Image Management (Docker Registry) Docker Hub . For more information about creating the certificate and key to securely communicate with Secure Build Server, see Create your Secure Build Server . The Big Picture \u00b6 There are 5 steps of the Secure Build process: SETUP ENABLEPORTS BUILD REGISTER DEPLOY ACCESS CLEAN UP These points are explained in more detail in their respective sections below. The steps detailed here help you deploy the digital banking application that is provided as an example as a part of the hosted trial environment. To deploy your own application, complete the prerequisites ( Prerequisites page ), then refer the IBM Knowledge Center topic: Building your application with the Secure Build virtual server for detailed instructions. SETUP \u00b6 Configure your environment with the necessary credentials to connect to GitHub and Docker Hub respectively. Then you must create the certificate and key to securely communicate with the Secure Build Server (for more information see Create your Secure Build Server ). ENABLEPORTS \u00b6 Before you build a docker image by using the Hyper Protect base images, you must open the required ports for your application. For more information, see Enabling ports . BUILD \u00b6 To securely build a Docker Image. See Create your HPVS Secure Build Server , or Create your HPVS Secure Build Server by using a config file , and Securely Build your Application . The Secure Build Process leverages a Hyper Protect Virtual Server , called the Secure Build Server, to establish trust and security in the Docker Content Trust process. This ensure images verified using the Notary service architecture were safely built and signed. This is done by generating the repository and root keys used to establish trust with the Notary Service inside of the Secure Build Server to guarantee that the initial keys used for a repository are trusted on first use (solving the TOFU problem). The table details The full list of the keys used during the Secure Build lifecycle. Key Name Key Function Private Key Location How Created Owned by Whom Image Signing Key Pushing Docker images to a Docker repository Encrypted volume on the Secure Build container Created by the remote registry server on first push to the remote repository, and written to Secure Build container ISV or application developer Manifest Signing Key Signing a manifest created by Secure Build Encrypted volume on the Secure Build container Created by the Secure Build container when an image is built ISV or application developer Client certificate and Key Used by the cloud administrator to securely interact with the Secure Build REST API, contains certificate and private key Client Created on creation of the Secure Build container and provided to the client as the file specified in their CLIENT_CRT_KEY setting Cloud administrator REGISTER \u00b6 Register your securely built Docker image with your Secure Service Container to verify its validity. See Generating the signing keys , and Deploy your Securely Built Application as a Hyper Protect Virtual Server . DEPLOY \u00b6 Deploy your application (from the verified repository) as a Hyper Protect Virtual Server within its own secure environment (see Deploy your Securely Built Application as a Hyper Protect Virtual Server ). ACCESS \u00b6 Access your application with security built-in. See Welcome to the Digital Banking Application . CLEANUP \u00b6 Clean up your environment for future users. See Clean up your environment .","title":"Hyper Protect Virtual Servers (HPVS) Secure Build overview"},{"location":"securebuild/overview/#hyper-protect-virtual-servers-secure-build-overview","text":"","title":"Hyper Protect Virtual Servers Secure Build overview"},{"location":"securebuild/overview/#prerequisites","text":"See the Prerequisites page to complete the prerequisites for this trial if you want to use your own application. This includes creating accounts and credentials to access the Source Code Management (SCM) GitHub and the Docker Image Management (Docker Registry) Docker Hub . For more information about creating the certificate and key to securely communicate with Secure Build Server, see Create your Secure Build Server .","title":"Prerequisites"},{"location":"securebuild/overview/#the-big-picture","text":"There are 5 steps of the Secure Build process: SETUP ENABLEPORTS BUILD REGISTER DEPLOY ACCESS CLEAN UP These points are explained in more detail in their respective sections below. The steps detailed here help you deploy the digital banking application that is provided as an example as a part of the hosted trial environment. To deploy your own application, complete the prerequisites ( Prerequisites page ), then refer the IBM Knowledge Center topic: Building your application with the Secure Build virtual server for detailed instructions.","title":"The Big Picture"},{"location":"securebuild/overview/#setup","text":"Configure your environment with the necessary credentials to connect to GitHub and Docker Hub respectively. Then you must create the certificate and key to securely communicate with the Secure Build Server (for more information see Create your Secure Build Server ).","title":"SETUP"},{"location":"securebuild/overview/#enableports","text":"Before you build a docker image by using the Hyper Protect base images, you must open the required ports for your application. For more information, see Enabling ports .","title":"ENABLEPORTS"},{"location":"securebuild/overview/#build","text":"To securely build a Docker Image. See Create your HPVS Secure Build Server , or Create your HPVS Secure Build Server by using a config file , and Securely Build your Application . The Secure Build Process leverages a Hyper Protect Virtual Server , called the Secure Build Server, to establish trust and security in the Docker Content Trust process. This ensure images verified using the Notary service architecture were safely built and signed. This is done by generating the repository and root keys used to establish trust with the Notary Service inside of the Secure Build Server to guarantee that the initial keys used for a repository are trusted on first use (solving the TOFU problem). The table details The full list of the keys used during the Secure Build lifecycle. Key Name Key Function Private Key Location How Created Owned by Whom Image Signing Key Pushing Docker images to a Docker repository Encrypted volume on the Secure Build container Created by the remote registry server on first push to the remote repository, and written to Secure Build container ISV or application developer Manifest Signing Key Signing a manifest created by Secure Build Encrypted volume on the Secure Build container Created by the Secure Build container when an image is built ISV or application developer Client certificate and Key Used by the cloud administrator to securely interact with the Secure Build REST API, contains certificate and private key Client Created on creation of the Secure Build container and provided to the client as the file specified in their CLIENT_CRT_KEY setting Cloud administrator","title":"BUILD"},{"location":"securebuild/overview/#register","text":"Register your securely built Docker image with your Secure Service Container to verify its validity. See Generating the signing keys , and Deploy your Securely Built Application as a Hyper Protect Virtual Server .","title":"REGISTER"},{"location":"securebuild/overview/#deploy","text":"Deploy your application (from the verified repository) as a Hyper Protect Virtual Server within its own secure environment (see Deploy your Securely Built Application as a Hyper Protect Virtual Server ).","title":"DEPLOY"},{"location":"securebuild/overview/#access","text":"Access your application with security built-in. See Welcome to the Digital Banking Application .","title":"ACCESS"},{"location":"securebuild/overview/#cleanup","text":"Clean up your environment for future users. See Clean up your environment .","title":"CLEANUP"},{"location":"securebuild/sbs-ports-setup/","text":"Enabling ports \u00b6 Before you build a docker image by using the Hyper Protect base images, you must open the required ports for your application. The following information shows an example of how you can open the ports before building the docker image. #Here is the example on how you can re-write the iptable rules and open the required ports *filter :INPUT DROP [4:180] :FORWARD DROP [0:0] :OUTPUT DROP [0:0] -A INPUT -i lo -j ACCEPT -A INPUT -s 127.0.0.0/8 -j DROP -A INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT -A INPUT -p udp -m state --state ESTABLISHED -j ACCEPT -A INPUT -p icmp -m state --state ESTABLISHED -j ACCEPT # -A OUTPUT -o lo -j ACCEPT -A OUTPUT -p tcp -m state --state NEW,ESTABLISHED -j ACCEPT -A OUTPUT -p udp -m state --state NEW,ESTABLISHED -j ACCEPT -A OUTPUT -p icmp -m state --state NEW,ESTABLISHED -j ACCEPT # # Since by default all ports are blocked on HPVS Base image you could open the required ports by doing the following. # This is an example where you can open port 22 which is required for SSH access. -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT COMMIT Place this iptables.conf in your Docker build path and add an entry in the Docker file to use the iptables.conf, as shown below. COPY iptables.conf /etc/iptables/ If you are using base images as parent images, then you must initialize the systemd service by including following line in your Docker file: CMD [\"/sbin/init\"] After the Docker file is updated, you can build your docker image by using Secure Build.","title":"Enabling ports"},{"location":"securebuild/sbs-ports-setup/#enabling-ports","text":"Before you build a docker image by using the Hyper Protect base images, you must open the required ports for your application. The following information shows an example of how you can open the ports before building the docker image. #Here is the example on how you can re-write the iptable rules and open the required ports *filter :INPUT DROP [4:180] :FORWARD DROP [0:0] :OUTPUT DROP [0:0] -A INPUT -i lo -j ACCEPT -A INPUT -s 127.0.0.0/8 -j DROP -A INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT -A INPUT -p udp -m state --state ESTABLISHED -j ACCEPT -A INPUT -p icmp -m state --state ESTABLISHED -j ACCEPT # -A OUTPUT -o lo -j ACCEPT -A OUTPUT -p tcp -m state --state NEW,ESTABLISHED -j ACCEPT -A OUTPUT -p udp -m state --state NEW,ESTABLISHED -j ACCEPT -A OUTPUT -p icmp -m state --state NEW,ESTABLISHED -j ACCEPT # # Since by default all ports are blocked on HPVS Base image you could open the required ports by doing the following. # This is an example where you can open port 22 which is required for SSH access. -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT COMMIT Place this iptables.conf in your Docker build path and add an entry in the Docker file to use the iptables.conf, as shown below. COPY iptables.conf /etc/iptables/ If you are using base images as parent images, then you must initialize the systemd service by including following line in your Docker file: CMD [\"/sbin/init\"] After the Docker file is updated, you can build your docker image by using Secure Build.","title":"Enabling ports"}]}